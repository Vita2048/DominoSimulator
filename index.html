<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domino Simulator with TeslaBot</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: #333;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: default;
        }
        #toolbar {
            position: absolute; top: 0; left: 0; width: 200px; height: 100%;
            background-color: rgba(255, 255, 255, 0.85); border-right: 1px solid #ccc;
            padding: 20px; box-sizing: border-box; display: flex; flex-direction: column;
            z-index: 10; box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;
            overflow-y: auto; 
        }
        .toolbar-title { font-size: 18px; font-weight: bold; margin-bottom: 20px; text-align: center; }
        .toolbar-section { margin-bottom: 20px; }
        .toolbar-section-title { font-size: 14px; font-weight: bold; margin-bottom: 10px; color: #555; }
        .toolbar-button { display: flex; align-items: center; padding: 8px 12px; margin-bottom: 8px; background-color: #f5f5f5; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        .toolbar-button:hover { background-color: #e0e0e0; }
        .toolbar-button.active { background-color: #d0d0d0; }
        .toolbar-button.start { background-color: #e6ffe6; }
        .toolbar-button.start:hover { background-color: #d6efd6; }
        .toolbar-button.reset { background-color: #fff0e6; }
        .toolbar-button.reset:hover { background-color: #f5e6d6; }
        .toolbar-button.clear { background-color: #ffe6e6; }
        .toolbar-button.clear:hover { background-color: #f5d6d6; }
        .draggable-domino { width: 40px; height: 80px; background-color: #fff; border: 2px solid #333; margin: 10px auto; border-radius: 4px; cursor: grab; display: flex; align-items: center; justify-content: center; }
        .draggable-domino:active { cursor: grabbing; }
        .checkbox-container { display: flex; align-items: center; margin-bottom: 8px; }
        .checkbox-container input { margin-right: 8px; }
        #corner-panel { position: absolute; top: 20px; right: 20px; background-color: rgba(255, 255, 255, 0.8); border-radius: 4px; padding: 10px; display: flex; flex-direction: column; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); z-index: 10; }
        #corner-panel button { margin-bottom: 8px; padding: 8px 12px; background-color: #f5f5f5; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        #corner-panel button:hover { background-color: #e0e0e0; }
        #help-button { width: 24px; height: 24px; background-color: #f0f0f0; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-top: 10px; align-self: center; }
        #modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 100; }
        #help-modal { background-color: white; padding: 20px; border-radius: 8px; max-width: 500px; width: 80%; max-height: 80%; overflow-y: auto; }
        #help-modal h2 { margin-top: 0; }
        #close-modal { float: right; background: none; border: none; font-size: 18px; cursor: pointer; }
        #notification { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7); color: white; padding: 10px 20px; border-radius: 4px; font-size: 14px; opacity: 0; transition: opacity 0.3s; z-index: 30; }
        #custom-context-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            padding: 5px 0;
            z-index: 1000;
            display: none;
            min-width: 160px; /* Adjusted for new item */
        }
        #custom-context-menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #custom-context-menu li {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
        }
        #custom-context-menu li:hover {
            background-color: #f0f0f0;
        }
        #custom-context-menu li.separator {
            height: 1px;
            background-color: #eee;
            margin: 5px 0;
            padding: 0;
        }
		#file-input { display: none; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="toolbar">
        <div class="toolbar-title">Domino Simulator</div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Add Domino</div>
            <div class="draggable-domino" id="domino-template">
                <svg width="20" height="40" viewBox="0 0 20 40"><rect x="2" y="2" width="16" height="36" fill="white" stroke="black" stroke-width="1"/><circle cx="10" cy="10" r="2" fill="black"/><circle cx="10" cy="30" r="2" fill="black"/></svg>
            </div>
        </div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Add Batch</div>
            <div class="toolbar-button" id="add-batch-button">
                <div class="toolbar-button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <rect x="4" y="6" width="4" height="12" fill="#333"/>
                        <rect x="10" y="6" width="4" height="12" fill="#333"/>
                        <rect x="16" y="6" width="4" height="12" fill="#333"/>
                    </svg>
                </div>
                <span>Add Batch Line</span>
            </div>
            <div class="toolbar-button" id="add-batch-circle-button"> <div class="toolbar-button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="8" stroke="#333" stroke-width="2" fill="none"/>
                    </svg>
                </div>
                <span>Add Batch Circle</span>
            </div>
            <div class="toolbar-button" id="add-batch-spiral-button">
                <div class="toolbar-button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <path d="M12 2 A2 2 0 0 1 12 6 A6 6 0 0 1 12 18 A10 10 0 0 1 12 22" fill="none" stroke="#333" stroke-width="2"/>
                    </svg>
                </div>
                <span>Add Batch Spiral</span>
            </div>			
        </div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Simulation</div>
            <div class="toolbar-button reset" id="reset-button"><div class="toolbar-button-icon"><svg viewBox="0 0 24 24" width="20" height="20"><path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z" fill="#ff9800"/></svg></div><span>Reset Scene</span></div>
            <div class="toolbar-button clear" id="clear-button"><div class="toolbar-button-icon"><svg viewBox="0 0 24 24" width="20" height="20"><path d="M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19M8,9H16V19H8V9M15.5,4L14.5,3H9.5L8.5,4H5V6H19V4H15.5Z" fill="#f44336"/></svg></div><span>Clear Canvas</span></div>
        </div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">File Operations</div>
            <div class="toolbar-button load" id="load-button"><div class="toolbar-button-icon"><svg viewBox="0 0 24 24" width="20" height="20"><path d="M19 12H15.5L13 9.5L10.5 12H7L10 15L13 18L16 15H19V12ZM5 3H19C20.1 3 21 3.9 21 5V19C21 20.1 20.1 21 19 21H5C3.9 21 3 20.1 3 19V5C3 3.9 3.9 3 5 3Z" fill="#2196f3"/></svg></div><span>Load Scene</span></div>
            <div class="toolbar-button save" id="save-button"><div class="toolbar-button-icon"><svg viewBox="0 0 24 24" width="20" height="20"><path d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM10 16L7 13L10 10H7V8H13V14H10V16ZM17 16H14V14H17V16Z" fill="#9c27b0"/></svg></div><span>Save Scene</span></div>
        </div>
        <div class="toolbar-section">		
            <div class="toolbar-section-title">Display</div>
            <div class="checkbox-container"><input type="checkbox" id="toggle-grid" checked><label for="toggle-grid">Show Grid</label></div>
        </div>
    </div>
    <div id="corner-panel">
        <button id="toggle-orbit">Lock Camera</button> 
        <button id="reset-camera">Reset Camera</button>
        <div id="help-button">?</div>
    </div>
    <div id="custom-context-menu">
        <ul>
            <li id="context-move">Move (T)</li>
            <li id="context-rotate">Rotate (R)</li>
            <li class="separator"></li>
            <li id="context-start-simulation">Start Simulation (Space)</li>
            <li id="context-start-simulation-bot">Start Simulation Bot</li>
            <li class="separator"></li>
            <li id="context-delete">Delete (Del)</li>
        </ul>
    </div>
    <div id="notification"></div>
    <div id="modal-overlay">
        <div id="help-modal">
            <button id="close-modal">Ã—</button>
            <h2>Domino Simulator Help</h2>
            <h3>Controls</h3>
            <ul>
                <li><strong>Add Domino:</strong> Drag from the toolbar to the canvas (snaps to grid)</li>
                <li><strong>Add Batch Line:</strong> Click "Add Batch Line", enter number (2-20), drag to place. <strong>Use mouse wheel to rotate the line preview.</strong></li>
                <li><strong>Add Batch Circle:</strong> Click "Add Batch Circle", enter number (20-40), drag to place center</li>
                <li><strong>Select:</strong> Left-click on a domino</li>
                <li><strong>Hover:</strong> Mouse over a domino to highlight blue</li>
                <li><strong>Move (T):</strong> Right-click domino -> Move, then left-click & drag</li>
                <li><strong>Rotate (R):</strong> Right-click domino -> Rotate, then left-click & drag horizontally</li>
                <li><strong>Delete (Del):</strong> Right-click domino -> Delete, or press Delete/Backspace</li>
                <li><strong>Start Simulation (Space):</strong> Press Spacebar or use context menu arrows</li>
                <li><strong>Start Simulation Bot:</strong> Right-click domino -> Start Simulation Bot, then click direction arrow.</li>
                <li><strong>Reset:</strong> Click the reset button</li>
                <li><strong>Clear:</strong> Remove all dominoes</li>
				<li><strong>Load Scene:</strong> Click "Load Scene" to upload an XML file</li>
                <li><strong>Save Scene:</strong> Click "Save Scene" to download the scene as an XML file</li>
                <li><strong>Toggle Grid (G):</strong> Checkbox or press G</li>
                <li><strong>Context Menu:</strong> Right-click on a domino</li>
            </ul>
            <h3>Camera Controls</h3>
            <ul>
                <li><strong>Rotate View:</strong> Left-click and drag on empty space</li>
                <li><strong>Pan:</strong> Right-click and drag or middle mouse drag</li>
                <li><strong>Zoom:</strong> Scroll with mouse wheel</li>
                <li><strong>Lock Camera:</strong> Toggle button in top-right</li>
                <li><strong>Reset Camera:</strong> Button in top-right</li>
            </ul>
        </div>
    </div>
    <input type="file" id="file-input" accept=".xml" style="display: none;" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script> {/* Added FBXLoader */}
	<script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.min.js"></script>
    <script>
        // --- Constants ---
        const DOMINO_TALL = 2.01642;
        const DOMINO_WIDE = 1.01067; // Corresponds to local Z-axis of physics body
        const DOMINO_THICK = 0.258223; // Corresponds to local X-axis of physics body
        const PLANE_SIZE = 100;
        const GRID_SIZE = 100;
        const GRID_DIVISIONS = 100;
        const GRID_UNIT_SIZE = 1;
        const MIN_PLACEMENT_DISTANCE = 1; 
        const SELECT_COLOR = 0x555555;
        const HOVER_COLOR = 0x0055ff;
        const COLLISION_COLOR = 0xff0000;
        const IMPULSE_MAGNITUDE = 3.5; // Adjusted for potentially heavier bot interaction if needed
        const ARROW_COLOR_DEFAULT = 0xff0000;
        const ARROW_COLOR_HOVER = 0x0077ff;
        const BOT_URL = 'https://vita2048.github.io/DominoSimulator/TeslaBotWalkOnSportPushYUpZForward1.fbx';
		
        const BOT_ORIGINAL_HEIGHT = 2.64047; // meters

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xE0E0E0);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 30);
        camera.lookAt(0, 0, 0);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(20, 35, 25);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096;
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 100;
        directionalLight.shadow.camera.left = -PLANE_SIZE / 2;
        directionalLight.shadow.camera.right = PLANE_SIZE / 2;
        directionalLight.shadow.camera.top = PLANE_SIZE / 2;
        directionalLight.shadow.camera.bottom = -PLANE_SIZE / 2;
        directionalLight.shadow.bias = -0.0005;
        scene.add(directionalLight);

        // --- Physics ---
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.solver.iterations = 30;
        world.solver.tolerance = 0.001;
        world.allowSleep = true;
        world.defaultContactMaterial.restitution = 0.0;
        world.defaultContactMaterial.contactEquationStiffness = 1e6;
        world.defaultContactMaterial.contactEquationRelaxation = 3;

        const groundPhysMaterial = new CANNON.Material("groundMaterial");
        const dominoPhysMaterial = new CANNON.Material("dominoMaterial");

        const groundDominoContactMaterial = new CANNON.ContactMaterial(
            groundPhysMaterial,
            dominoPhysMaterial,
            { friction: 0.01, restitution: 0.0, contactEquationStiffness: 1e5, contactEquationRelaxation: 2.0 }
        );
        world.addContactMaterial(groundDominoContactMaterial);
        const dominoDominoContactMaterial = new CANNON.ContactMaterial(
            dominoPhysMaterial,
            dominoPhysMaterial,
            {
                friction: 0.005,
                restitution: 0.0,
                contactEquationStiffness: 1e6,
                contactEquationRelaxation: 1.5,
                contactSkinSize: 0
            }
        );
        world.addContactMaterial(dominoDominoContactMaterial);

        // --- Ground ---
        const groundGeometry = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0xbbbbbb, roughness: 0.8, metalness: 0.2 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        ground.name = "Ground";
        scene.add(ground);
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, material: groundPhysMaterial });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        groundBody.position.set(0, 0.01, 0); 
        world.addBody(groundBody);

        // --- Grid Helper ---
        const grid = new THREE.GridHelper(GRID_SIZE, GRID_DIVISIONS, 0x666666, 0xaaaaaa);
        grid.position.y = 0.01; 
        grid.material.opacity = 0.6;
        grid.material.transparent = true;
        grid.visible = true;
        scene.add(grid);

        // --- Controls ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 80;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;

        // --- State Variables ---
        let dominoes = []; 
        let dominoData = []; 
        let selectedDominoData = null;
        let hoveredDominoData = null;
        let hoveredSimulationArrow = null;
        let isSimulating = false;
        let isAddingDomino = false; 
        let previewDomino = null; 
        let previewBatchGroup = null; 
        let previewBatchCount = 0;
        let previewCircleGroup = null; 
        let previewCircleCount = 0;
        let previewSpiralGroup = null;
        let previewSpiralCount = 0;
		
        let lastMousePosition = { x: 0, y: 0 };
        let translationMode = false;
        let rotationMode = false;
        let isMoving = false;
        let isRotating = false;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const contextMenu = document.getElementById('custom-context-menu');
        let isSelectingSimulationDirection = false;
        let simulationTargetData = null; // Used for both regular and bot simulation selection phase
        let dominoModel = null; 
        let rotationArrowSprite = null;

        // Bot-specific state variables
        let teslaBotModel = null;
		let teslaBotWalkingModel = null;
        let botAnimationMixer = null;
        let botPushAction = null;
        let isBotAnimatingPush = false; // True when bot is actively playing its push animation
        let botTargetDominoData = null; // Stores the domino the bot will push (set before animation)
        let botPushDirection = null;    // Stores the direction ('positiveX' or 'negativeX') for the bot push
        let isSelectingBotSimulationDirection = false; // True when choosing arrow for bot push
		let botBaseOffset;
		let botBBox=null;
		

        // --- Load GLB Model (Domino) ---
        const gltfLoader = new THREE.GLTFLoader(); // Renamed from 'loader' to avoid conflict
        gltfLoader.load(
            'https://vita2048.github.io/DominoSimulator/OneBlockVerticalTransformed.glb',
            (gltf) => {
                dominoModel = gltf.scene;
                dominoModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        child.userData.isDomino = true; 
                        if (child.material) {
                            child.material = new THREE.MeshStandardMaterial({
                                map: child.material.map || null,
                                normalMap: child.material.normalMap || null,
                                roughness: child.material.roughness || 0.7,
                                metalness: child.material.metalness || 0.1,
                                emissive: new THREE.Color(0x000000),
                                emissiveIntensity: 1,
                                color: child.material.color || 0xffffff
                            });
                            if (child.geometry) child.geometry.computeBoundingBox(); 
                        }
                    }
                });
                const box = new THREE.Box3().setFromObject(dominoModel);
                const size = new THREE.Vector3();
                box.getSize(size);
                const scaleFactor = DOMINO_TALL / size.y;
                dominoModel.scale.set(scaleFactor, scaleFactor, scaleFactor);

                const scaledBox = new THREE.Box3().setFromObject(dominoModel);
                dominoModel.userData.pivotToBottomY = scaledBox.min.y; 
                
                console.log("Scaled domino model size:", scaledBox.getSize(new THREE.Vector3()));
                createPreviewDomino(); 
            },
            undefined, 
            (error) => {
                console.error("Error loading GLB domino model:", error);
                showNotification("Error: Could not load domino model.", true);
            }
        );

        // --- Load TeslaBot FBX Model ---
const fbxLoader = new THREE.FBXLoader();
fbxLoader.load(
    BOT_URL,
    (object) => {
        teslaBotModel = object;
        teslaBotModel.scale.set(0.012, 0.012, 0.012);
        teslaBotModel.rotation.set(0, 0, 0);

        botBBox = new THREE.Box3().setFromObject(teslaBotModel);
        teslaBotModel.traverse((child) => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => {
                            mat.metalness = 0.3;
                            mat.roughness = 0.7;
                        });
                    } else {
                        child.material.metalness = 0.3;
                        child.material.roughness = 0.7;
                    }
                }
            }
        });

        if (object.animations && object.animations.length) {
            botAnimationMixer = new THREE.AnimationMixer(teslaBotModel);
            console.log(`Found ${object.animations.length} animation clips in FBX:`);
            object.animations.forEach(clip => {
                console.log(`- Clip name: "${clip.name}", Duration: ${clip.duration.toFixed(2)}s`);
            });

            // Attempt to find clips by specific names
            // Adjust these names if the console log shows different ones.
            let walkClip = object.animations.find(clip => clip.name === 'Walk');
            let pushClip = object.animations.find(clip => clip.name === 'Push');

            // Fallback or alternative names if the simple ones aren't found
            if (!walkClip) {
                walkClip = object.animations.find(clip => clip.name === 'Armature|Walk');
            }
            if (!walkClip) { // Try another common pattern if Autodesk FBX Review shows "Walk" but it's nested
                // More robust check for names that *contain* Walk, case-insensitive
                walkClip = object.animations.find(clip => clip.name.toLowerCase().includes('walk'));
            }


            if (!pushClip) {
                pushClip = object.animations.find(clip => clip.name === 'Armature|Push');
            }
            if (!pushClip) { // Try another common pattern
                // More robust check for names that *contain* Push, case-insensitive
                pushClip = object.animations.find(clip => clip.name.toLowerCase().includes('push'));
            }


            if (!walkClip) {
                console.error("Walk animation clip not found. Please check FBX animation names. Available clips:", object.animations.map(c => c.name));
            } else {
                console.log(`Found Walk clip: "${walkClip.name}", Duration ${walkClip.duration.toFixed(2)}s`);
                botWalkAction = botAnimationMixer.clipAction(walkClip);
                botWalkAction.setLoop(THREE.LoopRepeat, Infinity);
                botWalkAction.clampWhenFinished = false;
                botWalkAction.timeScale = 1; // Keep animation playback speed normal
            }

            if (!pushClip) {
                console.error("Push animation clip not found. Please check FBX animation names. Available clips:", object.animations.map(c => c.name));
            } else {
                console.log(`Found Push clip: "${pushClip.name}", Duration ${pushClip.duration.toFixed(2)}s`);
                botPushAction = botAnimationMixer.clipAction(pushClip);
                botPushAction.setLoop(THREE.LoopOnce);
                botPushAction.clampWhenFinished = true;
            }
            
            // Additional check: ensure actions are created if clips are valid
            if (!botWalkAction) console.error("botWalkAction was not created.");
            if (!botPushAction) console.error("botPushAction was not created.");

        } else {
            console.warn("TeslaBot model loaded, but no animations found in the 'animations' array.");
        }

        teslaBotModel.visible = false;
        scene.add(teslaBotModel);
        console.log("TeslaBot model processed.");

        // --- IMPORTANT NOTE FOR BOT MOVEMENT SPEED ---
        // To adjust the bot's physical walking speed to match its animation,
        // you need to modify the 'walkingSpeed' variable.
        // This variable is located in the 'positionAndAnimateBot' function
        // elsewhere in your main HTML file.
        //
        // Example:
        // Inside function positionAndAnimateBot(...):
        //   ...
        //   const distance = startPosition.distanceTo(finalBotPosition);
        //   const walkingSpeed = 1.5; // <<< CHANGE THIS VALUE
        //   // Try increasing it, e.g., to 2.5 or 3.0, to make the bot move faster.
        //   // const walkingSpeed = 3.0;
        //   const moveDuration = distance / walkingSpeed;
        //   ...
        //
        // The 'timeScale' property of botWalkAction (set above) controls the
        // animation playback speed itself. For your request ("keep the leg movement as it is"),
        // botWalkAction.timeScale should generally remain 1.
        // The 'walkingSpeed' variable controls how fast the bot's model translates
        // across the scene.
    },
    (xhr) => { /* console.log((xhr.loaded / xhr.total * 100) + '% loaded - Bot'); */ },
    (error) => {
        console.error("Error loading TeslaBot FBX model:", error);
        showNotification("Error: Could not load TeslaBot model.", true);
    }
);


		
    // --- Save/Load Functionality ---
    function saveSceneToXML() {
        if (dominoData.length === 0) {
            showNotification("No dominoes to save!", true);
            return;
        }

        let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
        xml += '<DominoScene>\n';
        dominoData.forEach((data, index) => {
            const pos = data.initialBasePosition;
            const quat = data.mesh.quaternion; 

            xml += `  <Domino id="${index}">\n`;
            xml += `    <Position x="${pos.x}" y="${pos.y}" z="${pos.z}" />\n`;
            xml += `    <Quaternion x="${quat.x}" y="${quat.y}" z="${quat.z}" w="${quat.w}" />\n`;
            xml += `  </Domino>\n`;
        });
        xml += '</DominoScene>';

        const blob = new Blob([xml], { type: 'text/xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'domino_scene.xml';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showNotification("Scene saved as domino_scene.xml");
    }

    function loadSceneFromXML(event) {
        const file = event.target.files[0];
        if (!file) {
            showNotification("No file selected.", true);
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            const text = e.target.result;
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(text, 'text/xml');
                const errorNode = xmlDoc.querySelector('parsererror');
                if (errorNode) {
                    showNotification("Error parsing XML file.", true);
                    return;
                }

                clearCanvas();

                const dominoNodes = xmlDoc.getElementsByTagName('Domino');
                for (let i = 0; i < dominoNodes.length; i++) {
                    const dominoNode = dominoNodes[i]; 
                    const posNode = dominoNode.getElementsByTagName('Position')[0];
                    const quatNode = dominoNode.getElementsByTagName('Quaternion')[0]; 

                    const pos = new THREE.Vector3(
                        parseFloat(posNode.getAttribute('x')),
                        parseFloat(posNode.getAttribute('y')),
                        parseFloat(posNode.getAttribute('z'))
                    );

                    const qx = parseFloat(quatNode.getAttribute('x'));
                    const qy = parseFloat(quatNode.getAttribute('y'));
                    const qz = parseFloat(quatNode.getAttribute('z'));
                    const qw = parseFloat(quatNode.getAttribute('w'));
                    const loadedQuaternion = new THREE.Quaternion(qx, qy, qz, qw);
                    
                    const newDomino = createDomino(pos, 0); 

                    if (newDomino) {
                        newDomino.mesh.quaternion.copy(loadedQuaternion);
                        newDomino.body.quaternion.copy(loadedQuaternion);
                        newDomino.body.wakeUp(); 
                        newDomino.initialQuat.copy(loadedQuaternion); 
                    }
                }
                showNotification(`Loaded ${dominoNodes.length} dominoes.`);
            } catch (err) {
                showNotification("Error loading scene: " + err.message, true);
                console.error("Error loading scene:", err);
            }
        };
        reader.onerror = function() {
            showNotification("Error reading file.", true);
        };
        reader.readAsText(file);
        document.getElementById('file-input').value = '';
    }
	
    function createPreviewSpiral(numberOfPieces, spiralGrowthRate = 0.6) {
        if (previewSpiralGroup) {
            scene.remove(previewSpiralGroup);
            previewSpiralGroup.traverse(child => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                        else child.material.dispose();
                    }
                }
            });
        }
        previewSpiralGroup = new THREE.Group();
        const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;
        const N = numberOfPieces;
        const dominoLength = DOMINO_WIDE;
        const desiredSpacing = dominoLength * 1; 
        const startingRadius = dominoLength * 2; 
        const positions = [];
        let currentRadius = startingRadius;
        let currentAngle = 0;
        positions.push({ radius: currentRadius, angle: currentAngle });
        
        for (let i = 1; i < N; i++) {
            const angleIncrement = desiredSpacing / currentRadius;
            currentAngle += angleIncrement;
            const baseRadiusIncrement = desiredSpacing / (2 * Math.PI);
            const radiusIncrement = baseRadiusIncrement * spiralGrowthRate;
            currentRadius += radiusIncrement;
            positions.push({ radius: currentRadius, angle: currentAngle });
        }
        
        for (let i = 0; i < positions.length; i++) {
            const { radius, angle } = positions[i];
            const posX = radius * Math.cos(angle);
            const posZ = radius * Math.sin(angle);
            
            const singlePreview = dominoModel.clone();
            singlePreview.traverse((child) => {
                if (child.isMesh) {
                    child.material = child.material.clone();
                    child.material.transparent = true;
                    child.material.opacity = 0.6;
                    child.userData.isDomino = true;
                }
            });
            singlePreview.position.set(posX, 0 - modelPivotCorrection, posZ);
            const tangentAngle = angle + Math.PI/2;
            singlePreview.rotation.y = -tangentAngle;
            previewSpiralGroup.add(singlePreview);
        }
        scene.add(previewSpiralGroup);
        previewSpiralCount = numberOfPieces;
    }

    function onAddBatchSpiral() {
        if (isSimulating || !dominoModel) return;
        const numDominosStr = prompt("Enter number of pieces for the spiral (20-80):", "40");
        if (numDominosStr === null) return;
        const n = parseInt(numDominosStr);
        if (isNaN(n) || n < 20 || n > 80) {
            showNotification("Invalid number. Please enter a value between 20 and 80.", true);
            return;
        }

        if (previewDomino) { previewDomino.visible = false; }
        previewDomino = null;
        if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewBatchGroup = null; previewBatchCount = 0; }
        if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewCircleGroup = null; previewCircleCount = 0; }
        if (previewSpiralGroup) { scene.remove(previewSpiralGroup); previewSpiralGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewSpiralGroup = null; previewSpiralCount = 0; }

        createPreviewSpiral(n);
        isAddingDomino = true;
        controls.enabled = false;
        document.body.style.cursor = 'grabbing';
        hideContextMenu();
    }

    // --- Domino Creation ---
    function createPreviewDomino() {
        if (!dominoModel) return;
        if (previewDomino) { 
            scene.remove(previewDomino);
            previewDomino.traverse(child => { if (child.isMesh) {if (child.geometry) child.geometry.dispose(); if (child.material) child.material.dispose();} });
        }
        previewDomino = dominoModel.clone();
        previewDomino.traverse((child) => {
            if (child.isMesh) {
                child.material = child.material.clone(); 
                child.material.transparent = true;
                child.material.opacity = 0.6;
                child.userData.isDomino = true;
            }
        });
        const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;
        previewDomino.position.y = 0 - modelPivotCorrection; 
        previewDomino.rotation.y = 0; 
        previewDomino.visible = false;
        scene.add(previewDomino);
    }

    function createDomino(basePosition, rotationY = 0) {
        if (!dominoModel) {
            showNotification("Error: Domino model not ready.", true);
            return null;
        }

        const dominoMesh = dominoModel.clone();
        dominoMesh.userData.isDomino = true;
        const modelPivotToBottomY_offset = dominoModel.userData.pivotToBottomY || 0;
        dominoMesh.userData.modelPivotToBottomY = modelPivotToBottomY_offset;
        
        dominoMesh.position.set(basePosition.x, basePosition.y - modelPivotToBottomY_offset, basePosition.z);


        const euler = new THREE.Euler(0, rotationY, 0, 'XYZ');
        dominoMesh.quaternion.setFromEuler(euler);

        dominoMesh.traverse((child) => {
            if (child.isMesh && child.material) {
                child.material = child.material.clone(); 
                child.userData.isDominoPart = true;
            }
        });
        scene.add(dominoMesh);

        const shape = new CANNON.Box(new CANNON.Vec3(DOMINO_THICK / 2, DOMINO_TALL / 2, DOMINO_WIDE / 2));
        const bodyCoMPosition = new CANNON.Vec3(basePosition.x, basePosition.y + DOMINO_TALL / 2, basePosition.z);
        const dominoBody = new CANNON.Body({
            mass: 1.0,
            position: bodyCoMPosition,
            shape: shape,
            material: dominoPhysMaterial,
            linearDamping: 0.15,
            angularDamping: 0.4,
            collisionResponse: true
        });

        dominoBody.quaternion.copy(dominoMesh.quaternion);
        dominoBody.allowSleep = true;
        dominoBody.sleepSpeedLimit = 0.5;
        dominoBody.sleepTimeLimit = 1.0;
        dominoMesh.userData.body = dominoBody;
        dominoBody.userData = { mesh: dominoMesh }; 

        const data = {
            mesh: dominoMesh,
            body: dominoBody,
            initialBasePosition: basePosition.clone(), 
            initialQuat: new THREE.Quaternion().copy(dominoMesh.quaternion) 
        };

        dominoData.push(data);
        dominoes.push(dominoMesh); 
        world.addBody(dominoBody);
        return data;
    }
        
    // --- Collision & Placement ---
    function snapToGrid(position) {
        const snappedX = Math.round(position.x / GRID_UNIT_SIZE) * GRID_UNIT_SIZE;
        const snappedZ = Math.round(position.z / GRID_UNIT_SIZE) * GRID_UNIT_SIZE;
        return new THREE.Vector3(snappedX, position.y, snappedZ); 
    }

    function checkDominoCollision(positionToCheck, excludeData = null) {
        const snappedCheckPos = snapToGrid(positionToCheck); 

        for (const data of dominoData) {
            if (data === excludeData) continue; 
            const existingSnappedBasePos = snapToGrid(data.initialBasePosition); 
            
            const dx = existingSnappedBasePos.x - snappedCheckPos.x;
            const dz = existingSnappedBasePos.z - snappedCheckPos.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            if (distance < GRID_UNIT_SIZE * 0.9) return true; 
        }
        return false;
    }

    function mouseToWorld(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(ground); 
        return intersects.length > 0 ? intersects[0].point : null;
    }

    // --- Highlighting ---
    function setEmissive(dominoData, colorHex = 0x000000, intensity = 1) {
        if (!dominoData || !dominoData.mesh) return;
        dominoData.mesh.traverse((child) => {
            if (child.isMesh && child.material && child.material.emissive) {
                child.material.emissive.setHex(colorHex);
                child.material.emissiveIntensity = intensity;
            }
        });
    }

    function findDominoDataFromObject(object) {
        let current = object;
        while (current) {
            if (current.userData && current.userData.body) {
                return dominoData.find(data => data.mesh === current);
            }
            if (current.parent && current.parent.userData && current.parent.userData.body && current.userData.isDominoPart) {
                 return dominoData.find(data => data.mesh === current.parent);
            }
            current = current.parent;
        }
        return null;
    }

    function updateHoverEffect(event) {
        if (isAddingDomino || isSimulating || translationMode || rotationMode || isSelectingSimulationDirection || isSelectingBotSimulationDirection || isBotAnimatingPush) {
            if (hoveredDominoData && hoveredDominoData !== selectedDominoData) {
                setEmissive(hoveredDominoData, 0x000000); 
            }
            hoveredDominoData = null;
            return;
        }

        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects(dominoes, true); 
        let currentlyHoveredData = null;

        if (intersects.length > 0) {
            currentlyHoveredData = findDominoDataFromObject(intersects[0].object);
        }

        if (hoveredDominoData !== currentlyHoveredData) {
            if (hoveredDominoData && hoveredDominoData !== selectedDominoData) {
                setEmissive(hoveredDominoData, 0x000000); 
            }
            if (currentlyHoveredData && currentlyHoveredData !== selectedDominoData) {
                setEmissive(currentlyHoveredData, HOVER_COLOR, 1.5); 
            }
            hoveredDominoData = currentlyHoveredData;
        }
    }

    // --- Selection & Manipulation ---
    function selectDomino(dataToSelect) {
        if (selectedDominoData === dataToSelect && dataToSelect !== null) return; 

        if (selectedDominoData) {
            setEmissive(selectedDominoData, 0x000000); 
        }

        if ((isSelectingSimulationDirection || isSelectingBotSimulationDirection) && selectedDominoData !== dataToSelect) {
            clearSimulationArrows(); 
        }

        selectedDominoData = dataToSelect;

        if (selectedDominoData) {
            setEmissive(selectedDominoData, SELECT_COLOR, 1.5); 
            if (hoveredDominoData === selectedDominoData) {
                hoveredDominoData = null; 
            }
        } else {
            if (translationMode || rotationMode) { 
                translationMode = false;
                rotationMode = false;
                isMoving = false;
                isRotating = false;
                document.body.style.cursor = 'default';
                controls.enabled = true;
                if (rotationArrowSprite) scene.remove(rotationArrowSprite);
            }
            if (hoveredDominoData) {
                 setEmissive(hoveredDominoData, HOVER_COLOR, 1.5);
            }
        }
        hideContextMenu();
    }

    function createRotationArrows() {
        const canvas = document.createElement('canvas');
        const canvasSize = 128; 
        canvas.width = canvasSize;
        canvas.height = canvasSize;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#ff0000'; 
        ctx.fillStyle = '#ff0000';   
        ctx.lineWidth = 8;         
        ctx.lineCap = 'round';     
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = canvasSize * 0.3125; 
        const arrowLength = canvasSize * 0.125; 
        const arrowheadAngle = Math.PI / 6; 
        const startAngle = Math.PI * 0.25; 
        const endAngle = Math.PI * 1.75;   
        ctx.save();
        ctx.translate(centerX, centerY); 
        ctx.rotate(-Math.PI / 2);        
        ctx.translate(-centerX, -centerY); 
        ctx.beginPath(); 
        ctx.arc(centerX, centerY, radius, startAngle, endAngle, false);
        ctx.stroke(); 
        function drawArrowhead(ctx, x, y, direction, length, angle) { 
            ctx.save(); ctx.beginPath(); ctx.translate(x, y); ctx.rotate(direction);
            ctx.moveTo(0, 0);
            const wingX = -length; const wingY1 = length * Math.tan(angle / 2); const wingY2 = -length * Math.tan(angle / 2);
            ctx.lineTo(wingX, wingY1); ctx.lineTo(wingX, wingY2); ctx.closePath();
            ctx.fill(); ctx.restore();
        }
        const startX = centerX + radius * Math.cos(startAngle - 0.2);
        const startY = centerY + radius * Math.sin(startAngle - 0.2);
        const directionStart = startAngle + Math.PI / 2 + Math.PI;
        const endX = centerX + radius * Math.cos(endAngle + 0.2);
        const endY = centerY + radius * Math.sin(endAngle + 0.2);
        const directionEnd = endAngle + Math.PI / 2;
        drawArrowhead(ctx, startX, startY, directionStart, arrowLength, arrowheadAngle * 2);
        drawArrowhead(ctx, endX, endY, directionEnd, arrowLength, arrowheadAngle * 2);
        ctx.restore(); 
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true; 
        const planeSize = 3; 
        const geometry = new THREE.PlaneGeometry(planeSize, planeSize);
        const material = new THREE.MeshBasicMaterial({ 
            map: texture,          
            color: 0xffffff,       
            transparent: true,     
            alphaTest: 0.1,        
            depthTest: false,      
            depthWrite: false,     
            side: THREE.DoubleSide 
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.rotation.x = -Math.PI / 2;
        mesh.position.y = 0.01; 
        mesh.visible = false;
        mesh.userData.isRotationArrow = true; 
        mesh.renderOrder = 1;               
        return mesh;
    }

    function animateRotation(data) {
        if (!data || !data.mesh || !data.body || !scene || typeof DOMINO_TALL === 'undefined') return;
        if (!rotationArrowSprite) rotationArrowSprite = createRotationArrows();

        const visualYPosition = data.mesh.position.y + (data.mesh.userData.modelPivotToBottomY || 0) + DOMINO_TALL * 0.75;
        rotationArrowSprite.position.set(data.mesh.position.x, visualYPosition + 0.5, data.mesh.position.z);
        rotationArrowSprite.rotation.x = -Math.PI / 2; 
        rotationArrowSprite.visible = true;
        scene.add(rotationArrowSprite);

        const initialBodyQuaternion = data.body.quaternion.clone();
        let totalRotationOffset = 0;
        let lastMousePosition = { x: 0, y: 0 }; 

        function updateRotation(event) {
            if (!rotationMode || !selectedDominoData || selectedDominoData !== data) {
                document.removeEventListener('mousemove', updateRotation);
                if (rotationArrowSprite) {
                    scene.remove(rotationArrowSprite);
                    rotationArrowSprite.visible = false;
                    if (rotationArrowSprite.material.map) rotationArrowSprite.material.map.dispose();
                    rotationArrowSprite.material.dispose();
                    rotationArrowSprite.geometry.dispose();
                }
                return;
            }
            const deltaX = event.clientX - lastMousePosition.x;
            const rotationSpeed = 0.01;
            totalRotationOffset += deltaX * rotationSpeed;

            const rotationQuaternion = new CANNON.Quaternion();
            rotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), totalRotationOffset);
            data.body.quaternion.copy(initialBodyQuaternion).mult(rotationQuaternion, data.body.quaternion);
            data.body.quaternion.normalize();
            data.mesh.quaternion.copy(data.body.quaternion);

            const currentBaseY = data.mesh.position.y + (data.mesh.userData.modelPivotToBottomY || 0);
            rotationArrowSprite.position.set(data.mesh.position.x, currentBaseY + DOMINO_TALL * 0.75 + 0.5, data.mesh.position.z);

            if (data.userData && data.userData.collisionHelper) {
                data.userData.collisionHelper.quaternion.copy(data.body.quaternion);
            }
            lastMousePosition = { x: event.clientX, y: event.clientY };
        }
        document.addEventListener('mousemove', updateRotation, false);
        rotationMode = true;
    }

    function createSimulationArrowHelper(origin, directionVec, color, userDataDirection) {
        const length = 1.0; const headLength = 0.3; const headWidth = 0.2;
        const arrowHelper = new THREE.ArrowHelper(directionVec.clone().normalize(), origin, length, color, headLength, headWidth);
        arrowHelper.userData.isSimulationArrow = true;
        arrowHelper.userData.direction = userDataDirection; 
        arrowHelper.userData.originalColor = color;
        arrowHelper.userData.isPulsing = false;
        arrowHelper.userData.pulseTime = 0;
        arrowHelper.line.userData = { isSimulationArrowPart: true, parentArrow: arrowHelper };
        arrowHelper.cone.userData = { isSimulationArrowPart: true, parentArrow: arrowHelper };
        return arrowHelper;
    }

    function clearSimulationArrows() {
        const arrowsToRemove = scene.children.filter(child => child.userData && child.userData.isSimulationArrow);
        arrowsToRemove.forEach(arrow => {
            if (hoveredSimulationArrow === arrow) {
                if (arrow.cone) arrow.cone.scale.set(1, 1, 1); 
                hoveredSimulationArrow = null;
            }
            scene.remove(arrow); 
        });
        // Reset states for both types of simulation selections
        if (isSelectingSimulationDirection || isSelectingBotSimulationDirection) {
            isSelectingSimulationDirection = false;
            isSelectingBotSimulationDirection = false;
            simulationTargetData = null; // Clear target for both
            document.body.style.cursor = 'default';
            if (!isBotAnimatingPush && !isSimulating) controls.enabled = true; 
        }
    }

    // --- Context Menu Logic ---
    function showContextMenu(event, targetData) {
        hideContextMenu(); 
        selectDomino(targetData); 
        contextMenu.style.left = `${event.clientX}px`;
        contextMenu.style.top = `${event.clientY}px`;
        contextMenu.style.display = 'block';

        document.getElementById('context-move').onclick = () => {
            translationMode = true; rotationMode = false; isMoving = true; isRotating = false;
            lastMousePosition = { x: event.clientX, y: event.clientY };
            showNotification("Move: Domino follows mouse. Left-click to fix. Esc to cancel.");
            document.body.style.cursor = 'move'; controls.enabled = false; 
            hideContextMenu();
        };

        document.getElementById('context-rotate').onclick = () => {
            rotationMode = true; translationMode = false; isRotating = true; isMoving = false;
            lastMousePosition = { x: event.clientX, y: event.clientY };
            showNotification("Rotate: Drag mouse horizontally. Left-click to fix. Esc to cancel.");
            document.body.style.cursor = 'ew-resize'; controls.enabled = false;
            animateRotation(targetData);
            hideContextMenu();
        };

        document.getElementById('context-start-simulation').onclick = () => {
            if (!targetData || !targetData.body) return;
            hideContextMenu();
            clearSimulationArrows(); 

            const bodyPos = targetData.body.position; 
            const bodyQuat = targetData.body.quaternion; 
            const localX = new THREE.Vector3(1, 0, 0); 
            const worldNormalPositiveX = new THREE.Vector3().copy(localX).applyQuaternion(
                new THREE.Quaternion(bodyQuat.x, bodyQuat.y, bodyQuat.z, bodyQuat.w)
            );
            const worldNormalNegativeX = worldNormalPositiveX.clone().negate();
            const faceOffsetDistance = DOMINO_WIDE / 2 + 0.1; 

            const arrowOriginPositiveX = new THREE.Vector3(bodyPos.x, bodyPos.y, bodyPos.z)
                .add(worldNormalPositiveX.clone().multiplyScalar(faceOffsetDistance));
            const arrowOriginNegativeX = new THREE.Vector3(bodyPos.x, bodyPos.y, bodyPos.z)
                .add(worldNormalNegativeX.clone().multiplyScalar(faceOffsetDistance));
            
            const positiveXArrow = createSimulationArrowHelper(arrowOriginPositiveX, worldNormalPositiveX, ARROW_COLOR_DEFAULT, 'positiveX');
            scene.add(positiveXArrow);
            const negativeXArrow = createSimulationArrowHelper(arrowOriginNegativeX, worldNormalNegativeX, ARROW_COLOR_DEFAULT, 'negativeX');
            scene.add(negativeXArrow);

            showNotification("Click a red arrow to apply impulse in that direction.");
            isSelectingSimulationDirection = true;
            isSelectingBotSimulationDirection = false; // Ensure other mode is off
            simulationTargetData = targetData; 
            controls.enabled = false; 
        };
        
        document.getElementById('context-start-simulation-bot').onclick = () => {
            if (!targetData || !targetData.body || !teslaBotModel) {
                showNotification("TeslaBot model not ready or no domino selected.", true);
                return;
            }
            hideContextMenu();
            clearSimulationArrows(); 

            const bodyPos = targetData.body.position;
            const bodyQuat = targetData.body.quaternion;
            const localX = new THREE.Vector3(1, 0, 0); // Push is along domino's local X (thickness)
            const worldNormalPositiveX = new THREE.Vector3().copy(localX).applyQuaternion(
                new THREE.Quaternion(bodyQuat.x, bodyQuat.y, bodyQuat.z, bodyQuat.w)
            );
            const worldNormalNegativeX = worldNormalPositiveX.clone().negate();
            
            // UPDATE THIS LINE: Use DOMINO_THICK for offset if push is along thickness
            const faceOffsetDistance = DOMINO_THICK / 2 + 0.1; // Offset from center to face, plus a small gap

            const arrowOriginPositiveX = new THREE.Vector3(bodyPos.x, bodyPos.y, bodyPos.z)
                .add(worldNormalPositiveX.clone().multiplyScalar(faceOffsetDistance));
            const arrowOriginNegativeX = new THREE.Vector3(bodyPos.x, bodyPos.y, bodyPos.z)
                .add(worldNormalNegativeX.clone().multiplyScalar(faceOffsetDistance));

            const positiveXArrow = createSimulationArrowHelper(arrowOriginPositiveX, worldNormalPositiveX, ARROW_COLOR_DEFAULT, 'positiveX_bot');
            scene.add(positiveXArrow);
            const negativeXArrow = createSimulationArrowHelper(arrowOriginNegativeX, worldNormalNegativeX, ARROW_COLOR_DEFAULT, 'negativeX_bot');
            scene.add(negativeXArrow);

            showNotification("Click a red arrow for Bot to push in that direction.");
            isSelectingBotSimulationDirection = true;
            isSelectingSimulationDirection = false; 
            simulationTargetData = targetData; 
            controls.enabled = false;
        };


        document.getElementById('context-delete').onclick = () => {
            deleteSelectedDomino();
            hideContextMenu();
        };
    }

    function deleteSelectedDomino() {
        if (!selectedDominoData) return;
        const dataToDelete = selectedDominoData;
        selectDomino(null); 

        scene.remove(dataToDelete.mesh);
        if (world.bodies.includes(dataToDelete.body)) {
            world.removeBody(dataToDelete.body);
        }

        if (dataToDelete.userData && dataToDelete.userData.collisionHelper) {
            scene.remove(dataToDelete.userData.collisionHelper);
            if (dataToDelete.userData.collisionHelperUpdater) {
                world.removeEventListener('postStep', dataToDelete.userData.collisionHelperUpdater);
            }
        }

        const meshIndex = dominoes.indexOf(dataToDelete.mesh);
        if (meshIndex > -1) dominoes.splice(meshIndex, 1);
        const dataIndex = dominoData.indexOf(dataToDelete);
        if (dataIndex > -1) dominoData.splice(dataIndex, 1);

        dataToDelete.mesh.traverse((child) => {
            if (child.isMesh) {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (child.material.map) child.material.map.dispose();
                    if (Array.isArray(child.material)) {
                        child.material.forEach(m => m.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            }
        });
        showNotification('Domino Deleted');
    }

    function hideContextMenu() {
        contextMenu.style.display = 'none';
        document.getElementById('context-move').onclick = null;
        document.getElementById('context-rotate').onclick = null;
        document.getElementById('context-start-simulation').onclick = null;
        document.getElementById('context-start-simulation-bot').onclick = null;
        document.getElementById('context-delete').onclick = null;
    }

    // --- Bot Placement and Animation ---
// --- Bot Placement and Animation ---
function positionAndAnimateBot(targetDominoDataForBot, pushDirForBot, startPosition = new THREE.Vector3(0, 0, 0)) {
    if (!teslaBotModel || !botAnimationMixer || !botWalkAction || !botPushAction || !targetDominoDataForBot) {
        console.error("Animation failed:", {
            teslaBotModel: !!teslaBotModel,
            botAnimationMixer: !!botAnimationMixer,
            botWalkAction: !!botWalkAction,
            botPushAction: !!botPushAction,
            targetDominoDataForBot: !!targetDominoDataForBot
        });
        showNotification("TeslaBot or target not ready for animation.", true);
        isBotAnimatingPush = false;
        if (!isSimulating) controls.enabled = true;
        return;
    }

    isBotAnimatingPush = true;
    controls.enabled = false;

    const dominoBody = targetDominoDataForBot.body;
    const dominoQuaternion = new THREE.Quaternion(
        dominoBody.quaternion.x,
        dominoBody.quaternion.y,
        dominoBody.quaternion.z,
        dominoBody.quaternion.w
    );

    let pushWorldDirection = new THREE.Vector3(pushDirForBot === 'positiveX' ? 1 : -1, 0, 0);
    pushWorldDirection.applyQuaternion(dominoQuaternion);

    const botPlacementDirection = pushWorldDirection.clone().negate();

    const finalBotPosition = new THREE.Vector3().copy(dominoBody.position);
    const botOffsetDistance = (DOMINO_THICK / 2) + 0.5 + 0.58;
    finalBotPosition.addScaledVector(botPlacementDirection, botOffsetDistance);

    /*const botBBox = new THREE.Box3().setFromObject(teslaBotModel);
    finalBotPosition.y = -botBBox.min.y;
    startPosition.y = -botBBox.min.y;*/
	
	finalBotPosition.y = 0; // Set bot's base directly on the ground
startPosition.y = 0;    // Ensure start position is also on the ground

    teslaBotModel.position.copy(startPosition);
    teslaBotModel.rotation.set(0, 0, 0);
    teslaBotModel.up.set(0, 1, 0);
    teslaBotModel.visible = true;

    const lookAtTarget = new THREE.Vector3().copy(dominoBody.position);
    lookAtTarget.y = startPosition.y;
    teslaBotModel.lookAt(lookAtTarget);
    teslaBotModel.rotateY(Math.PI);

    const distance = startPosition.distanceTo(finalBotPosition);
    const walkingSpeed = 3.3;
    const moveDuration = distance / walkingSpeed;
    console.log(`Distance: ${distance.toFixed(2)}m, Move Duration: ${moveDuration.toFixed(2)}s`);

    botAnimationMixer.stopAllAction();
    botWalkAction.reset();
    botWalkAction.setLoop(THREE.LoopRepeat, Infinity);
    botWalkAction.timeScale = 1;
    botWalkAction.play();
    console.log("Walking animation started, duration:", botWalkAction.getClip().duration);

    const startTime = performance.now();
    let lastTime = startTime;
    let hasTransitionedToPush = false;

    function moveBot() {
        const currentTime = performance.now();
        const delta = (currentTime - lastTime) / 1000;
        const totalElapsed = (currentTime - startTime) / 1000;
        lastTime = currentTime;
        const t = Math.min(totalElapsed / moveDuration, 1);

        teslaBotModel.position.lerpVectors(startPosition, finalBotPosition, t);

        const lookAtTarget = new THREE.Vector3().copy(dominoBody.position);
        lookAtTarget.y = teslaBotModel.position.y;
        teslaBotModel.lookAt(lookAtTarget);
        teslaBotModel.rotateY(Math.PI);

        botAnimationMixer.update(delta);
        console.log(`Walk animation time: ${botWalkAction.time.toFixed(2)}s, t: ${t.toFixed(2)}, totalElapsed: ${totalElapsed.toFixed(2)}s, moveDuration: ${moveDuration.toFixed(2)}s, isWalkRunning: ${botWalkAction.isRunning()}`);

        if (t >= 1 && totalElapsed >= moveDuration && !hasTransitionedToPush) {
            hasTransitionedToPush = true;
            botWalkAction.stop(); // Stop walk to prevent blending
            botPushAction.reset();
            botPushAction.setLoop(THREE.LoopOnce);
            botPushAction.clampWhenFinished = true;
            botPushAction.play();
            console.log("Push animation started, duration:", botPushAction.getClip().duration);
            console.log("Bot position at push:", teslaBotModel.position);

            const onAnimationFinish = (event) => {
                if (event.action === botPushAction) {
                    console.log("Push animation finished");
                    botAnimationMixer.removeEventListener('finished', onAnimationFinish);

                    let localImpulse = new CANNON.Vec3();
                    if (pushDirForBot === 'positiveX') localImpulse.set(IMPULSE_MAGNITUDE || 10, 0, 0);
                    else localImpulse.set(-(IMPULSE_MAGNITUDE || 10), 0, 0);

                    const appPointLocal = new CANNON.Vec3(
                        pushDirForBot === 'positiveX' ? -DOMINO_THICK / 2 : DOMINO_THICK / 2,
                        DOMINO_TALL * 0.45,
                        0
                    );

                    const worldImpulse = dominoBody.quaternion.vmult(localImpulse);
                    const worldApplicationPoint = dominoBody.quaternion.vmult(appPointLocal);
                    worldApplicationPoint.vadd(dominoBody.position, worldApplicationPoint);

                    console.log("Applying impulse:", worldImpulse, "at point:", worldApplicationPoint);
                    console.log("Domino mass:", dominoBody.mass, "Domino position:", dominoBody.position);

                    startSimulation({
                        targetBody: dominoBody,
                        worldImpulse: worldImpulse,
                        worldApplicationPoint: worldApplicationPoint
                    });

                    setTimeout(() => {
                        teslaBotModel.visible = false;
                        isBotAnimatingPush = false;
                        if (!isSimulating) controls.enabled = true;
                        showNotification("Domino collapse started");
                        console.log("Domino velocity after push:", dominoBody.velocity);
                    }, botPushAction.getClip().duration * 1000);
                }
            };
            botAnimationMixer.addEventListener('finished', onAnimationFinish);

            showNotification("TeslaBot is pushing...");
        } else if (t < 1) {
            requestAnimationFrame(moveBot);
        }
    }

    setTimeout(() => {
        if (isBotAnimatingPush && botWalkAction.isRunning() && !hasTransitionedToPush) {
            console.log("Fallback: Forcing push animation");
            botWalkAction.stop();
            moveBot();
        }
    }, (moveDuration + 3) * 1000);

    console.log("Starting bot animation, startTime:", startTime);
    requestAnimationFrame(moveBot);
}

    // --- Simulation Control ---
    function startSimulation(impulseData = null) { 
        if (dominoData.length === 0 && !impulseData) {
            showNotification("Add some dominoes first!");
            return;
        }
        if (isSimulating) return;

        clearSimulationArrows(); 
        isSimulating = true;
        world.allowSleep = false; 
        dominoData.forEach(data => data.body.wakeUp()); 

        if (impulseData && impulseData.targetBody) {
            impulseData.targetBody.wakeUp();
            impulseData.targetBody.applyImpulse(impulseData.worldImpulse, impulseData.worldApplicationPoint);
            showNotification("Simulation started with selected impulse!");
        } else if (selectedDominoData && selectedDominoData.body && !isBotAnimatingPush) { // Ensure bot isn't handling this
            selectedDominoData.body.wakeUp();
            // Default impulse if started via spacebar or generic context menu (not bot)
            const localImpulse = new CANNON.Vec3(IMPULSE_MAGNITUDE, 0, 0); 
            const appPointLocal = new CANNON.Vec3( -DOMINO_THICK / 2, DOMINO_TALL * 0.45, 0 ); 
            const worldImpulse = selectedDominoData.body.quaternion.vmult(localImpulse);
            const worldApplicationPoint = selectedDominoData.body.quaternion.vmult(appPointLocal);
            worldApplicationPoint.vadd(selectedDominoData.body.position, worldApplicationPoint); 
            selectedDominoData.body.applyImpulse(worldImpulse, worldApplicationPoint);
            showNotification("Simulation started with default impulse on selected domino!");
        } else if (dominoData.length > 0 && !impulseData) { // No impulse data means it wasn't a directed start
            showNotification("Select a domino or use context menu to start simulation with impulse.", true);
            isSimulating = false; 
            world.allowSleep = true;
            return;
        }

        translationMode = false; rotationMode = false; isAddingDomino = false;
        isMoving = false; isRotating = false;
        document.body.style.cursor = 'default';
        if (previewDomino) previewDomino.visible = false;
        if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewBatchGroup = null; previewBatchCount = 0;}
        if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewCircleGroup = null; previewCircleCount = 0;}
        if (previewSpiralGroup) { scene.remove(previewSpiralGroup); previewSpiralGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewSpiralGroup = null; previewSpiralCount = 0;}
        // Do not re-enable controls here if bot is animating, it will handle it.
        // If simulation started without bot, and bot wasn't animating, controls are fine.
    }

    function resetSimulation() {
        isSimulating = false;
        world.allowSleep = true; 
        clearSimulationArrows();
        hideContextMenu();

        if (teslaBotModel) teslaBotModel.visible = false;
        if (botAnimationMixer) botAnimationMixer.stopAllAction();
        isBotAnimatingPush = false;
        botTargetDominoData = null;
        botPushDirection = null;
        isSelectingBotSimulationDirection = false;


        if (translationMode || rotationMode || isAddingDomino) {
            translationMode = false; rotationMode = false; isAddingDomino = false;
            isMoving = false; isRotating = false;
            document.body.style.cursor = 'default';
            if (previewDomino) previewDomino.visible = false;
            if (previewBatchGroup) {
                scene.remove(previewBatchGroup); previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewBatchGroup = null; previewBatchCount = 0;
            }
            if (previewCircleGroup) { 
                scene.remove(previewCircleGroup); previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewCircleGroup = null; previewCircleCount = 0;
            }
            if (previewSpiralGroup) { 
                scene.remove(previewSpiralGroup); previewSpiralGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewSpiralGroup = null; previewSpiralCount = 0;
            }
            if (rotationArrowSprite) scene.remove(rotationArrowSprite);
        }
        controls.enabled = true; 

        dominoData.forEach(data => {
            const basePos = data.initialBasePosition; 
            const modelPivotOffsetY = data.mesh.userData.modelPivotToBottomY || 0;

            data.body.position.set(basePos.x, basePos.y + DOMINO_TALL / 2, basePos.z); 
            data.body.quaternion.copy(data.initialQuat);
            data.body.velocity.set(0, 0, 0);
            data.body.angularVelocity.set(0, 0, 0);
            data.body.sleep(); 

            data.mesh.position.set(basePos.x, basePos.y - modelPivotOffsetY, basePos.z);
            data.mesh.quaternion.copy(data.initialQuat);
            setEmissive(data, 0x000000); 

            if (data.userData && data.userData.collisionHelper) {
                data.userData.collisionHelper.position.copy(data.body.position);
                data.userData.collisionHelper.quaternion.copy(data.body.quaternion);
            }
        });

        selectDomino(null); 
        hoveredDominoData = null; 

        if (hoveredSimulationArrow) {
            setArrowColor(hoveredSimulationArrow, hoveredSimulationArrow.userData.originalColor);
            if (hoveredSimulationArrow.cone) hoveredSimulationArrow.cone.scale.set(1, 1, 1);
            hoveredSimulationArrow.userData.isPulsing = false;
            hoveredSimulationArrow = null;
        }
        showNotification('Simulation Reset');
    }

    function clearCanvas() {
        resetSimulation(); 
        dominoData.forEach(data => {
            scene.remove(data.mesh);
            if (world.bodies.includes(data.body)) world.removeBody(data.body);
            if (data.userData && data.userData.collisionHelper) {
                scene.remove(data.userData.collisionHelper);
                 if (data.userData.collisionHelperUpdater) { 
                    world.removeEventListener('postStep', data.userData.collisionHelperUpdater);
                }
            }
            data.mesh.traverse((child) => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                         if (child.material.map) child.material.map.dispose();
                         if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
            });
        });
        dominoes = []; 
        dominoData = [];
		selectDomino(null); 
        hoveredDominoData = null; 
        showNotification('Canvas Cleared');
    }

    // --- UI Helpers ---
    function showNotification(message, isError = false) {
        const notification = document.getElementById('notification');
        notification.textContent = message;
        notification.style.backgroundColor = isError ? 'rgba(200, 0, 0, 0.8)' : 'rgba(0, 0, 0, 0.7)';
        notification.style.opacity = '1';
        setTimeout(() => { notification.style.opacity = '0'; }, isError ? 3000 : 2000);
    }

    function toggleOrbitControls() {
        controls.enabled = !controls.enabled;
        document.getElementById('toggle-orbit').textContent = controls.enabled ? 'Lock Camera' : 'Unlock Camera';
        if (controls.enabled && (translationMode || rotationMode || isAddingDomino || isSelectingSimulationDirection || isSelectingBotSimulationDirection || isBotAnimatingPush)) {
            // If controls are re-enabled while an action is pending, cancel the action.
            translationMode = false; rotationMode = false; isAddingDomino = false; 
            isMoving = false; isRotating = false;
            isBotAnimatingPush = false; // Stop bot animation if it was happening
            if (botAnimationMixer) botAnimationMixer.stopAllAction();
            if (teslaBotModel) teslaBotModel.visible = false;

            document.body.style.cursor = 'default';
            if (previewDomino) previewDomino.visible = false;
            if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewBatchGroup = null; previewBatchCount = 0; }
            if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewCircleGroup = null; previewCircleCount = 0; }
            if (previewSpiralGroup) { scene.remove(previewSpiralGroup); previewSpiralGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewSpiralGroup = null; previewSpiralCount = 0; }
            clearSimulationArrows(); // This will also reset isSelecting...Direction flags
            if (rotationArrowSprite) scene.remove(rotationArrowSprite);
        }
    }

    function onStartDragDominoTemplate(event) {
        if (event.button !== 0) return; 
        if (isSimulating || !dominoModel || isBotAnimatingPush) return;
        
        if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewBatchGroup = null; previewBatchCount = 0; }
        if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewCircleGroup = null; previewCircleCount = 0; }
        if (previewSpiralGroup) { scene.remove(previewSpiralGroup); previewSpiralGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewSpiralGroup = null; previewSpiralCount = 0; }


        isAddingDomino = true;
        if (!previewDomino) createPreviewDomino(); 
        else previewDomino.visible = true; 
        
        if (previewDomino) { 
            previewDomino.rotation.y = 0; 
        }
        controls.enabled = false; 
        document.body.style.cursor = 'grabbing';
        hideContextMenu();
    }

    function onAddBatch() { // For Batch Line
        if (isSimulating || !dominoModel || isBotAnimatingPush) return;
        const numDominosStr = prompt("Enter number of dominos for the batch line (2-20):", "5");
        if (numDominosStr === null) return; 
        const n = parseInt(numDominosStr);
        if (isNaN(n) || n < 2 || n > 20) {
            showNotification("Invalid number. Please enter a value between 2 and 20.", true);
            return;
        }

        if (previewDomino) { previewDomino.visible = false; }
        previewDomino = null; 
        if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewCircleGroup = null; previewCircleCount = 0; }
        if (previewSpiralGroup) { scene.remove(previewSpiralGroup); previewSpiralGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewSpiralGroup = null; previewSpiralCount = 0; }
        if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewBatchGroup = null; previewBatchCount = 0; }
            
        createPreviewBatch(n); 
        isAddingDomino = true; 
        controls.enabled = false;
        document.body.style.cursor = 'grabbing';
        hideContextMenu();
    }
    
    function onAddBatchCircle() { 
        if (isSimulating || !dominoModel || isBotAnimatingPush) return;
        const numDominosStr = prompt("Enter number of pieces for the circle (20-40):", "30");
        if (numDominosStr === null) return; 
        const n = parseInt(numDominosStr);
        if (isNaN(n) || n < 20 || n > 40) {
            showNotification("Invalid number. Please enter a value between 20 and 40.", true);
            return;
        }

        if (previewDomino) { previewDomino.visible = false; }
        previewDomino = null;
        if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewBatchGroup = null; previewBatchCount = 0; }
        if (previewSpiralGroup) { scene.remove(previewSpiralGroup); previewSpiralGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewSpiralGroup = null; previewSpiralCount = 0; }
        if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewCircleGroup = null; previewCircleCount = 0; }


        createPreviewCircle(n);
        isAddingDomino = true;
        controls.enabled = false;
        document.body.style.cursor = 'grabbing';
        hideContextMenu();
    }

    function createPreviewBatch(n) { // For Line Batch
        if (previewBatchGroup) { 
            scene.remove(previewBatchGroup);
            previewBatchGroup.traverse(child => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) child.material.forEach(m=>m.dispose());
                        else child.material.dispose();
                    }
                }
            });
        }
        previewBatchGroup = new THREE.Group();
        previewBatchGroup.rotation.y = 0; 
        const spacing = 1.0; 
        const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;

        for (let i = 0; i < n; i++) {
            const singlePreview = dominoModel.clone();
            singlePreview.traverse((child) => {
                if (child.isMesh) {
                    child.material = child.material.clone();
                    child.material.transparent = true;
                    child.material.opacity = 0.6;
                    child.userData.isDomino = true;
                }
            });
            const zPos = (i - (n - 1) / 2) * spacing; 
            singlePreview.position.set(0, 0 - modelPivotCorrection, zPos); 
            singlePreview.rotation.y = Math.PI / 2; 
            previewBatchGroup.add(singlePreview);
        }
        scene.add(previewBatchGroup);
        previewBatchCount = n;
    }

    function createPreviewCircle(numberOfPieces) { 
        if (previewCircleGroup) {
            scene.remove(previewCircleGroup);
            previewCircleGroup.traverse(child => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                        else child.material.dispose();
                    }
                }
            });
        }
        previewCircleGroup = new THREE.Group();
        const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;
        const N = numberOfPieces;
        const radius = (DOMINO_WIDE * N) / (2 * Math.PI);
        const anglePerSegment = (2 * Math.PI) / N;
        
        for (let i = 0; i < N; i++) {
            const angle = i * anglePerSegment; 
            const posX = radius * Math.cos(angle); 
            const posZ = radius * Math.sin(angle);
            const singlePreview = dominoModel.clone();
            singlePreview.traverse((child) => {
                if (child.isMesh) {
                    child.material = child.material.clone();
                    child.material.transparent = true;
                    child.material.opacity = 0.6;
                    child.userData.isDomino = true;
                }
            });
            singlePreview.position.set(posX, 0 - modelPivotCorrection, posZ);
            singlePreview.rotation.y = (Math.PI/2) - angle;
            previewCircleGroup.add(singlePreview);
        }
        scene.add(previewCircleGroup);
        previewCircleCount = numberOfPieces;
    }

    function updatePreviewBatchVisuals(snappedBasePosForGroupCenter) {
        if (!previewBatchGroup || previewBatchCount === 0) return;

        if (snappedBasePosForGroupCenter) { 
            previewBatchGroup.position.copy(snappedBasePosForGroupCenter);
        }
        
        previewBatchGroup.updateMatrixWorld(true); 

        let collisionInBatch = false;
        const tempWorldPosCheck = new THREE.Vector3();
        for (let i = 0; i < previewBatchCount; i++) {
            const childPreview = previewBatchGroup.children[i];
            childPreview.getWorldPosition(tempWorldPosCheck); 
            
            if (checkDominoCollision(tempWorldPosCheck)) { 
                collisionInBatch = true;
                break;
            }
        }
        previewBatchGroup.traverse((child) => {
            if (child.isMesh && child.material && child.userData.isDomino) {
                child.material.color.setHex(collisionInBatch ? 0xff8888 : 0xffffff);
                child.material.opacity = collisionInBatch ? 0.4 : 0.6;
            }
        });
    }


    // --- Event Listeners Setup ---
    function initEventListeners() {
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            hideContextMenu();
        }, false);

        const canvasContainer = document.getElementById('canvas-container');
        canvasContainer.addEventListener('mousedown', onMouseDown, false);
        canvasContainer.addEventListener('mousemove', onMouseMove, false);
        canvasContainer.addEventListener('mouseup', onMouseUp, false);
        canvasContainer.addEventListener('contextmenu', onContextMenu, false); 
        canvasContainer.addEventListener('wheel', onMouseWheel, { passive: false }); 

        window.addEventListener('keydown', onKeyDown, false);
        window.addEventListener('mousedown', (event) => {
            if (contextMenu.style.display === 'block' && !contextMenu.contains(event.target)) {
                hideContextMenu();
            }
        }, true); 

        document.getElementById('domino-template').addEventListener('mousedown', onStartDragDominoTemplate);
        document.getElementById('add-batch-button').addEventListener('click', onAddBatch);
        document.getElementById('add-batch-circle-button').addEventListener('click', onAddBatchCircle); 
        document.getElementById('add-batch-spiral-button').addEventListener('click', onAddBatchSpiral);
        document.getElementById('reset-button').addEventListener('click', resetSimulation);
        document.getElementById('clear-button').addEventListener('click', clearCanvas);
        document.getElementById('save-button').addEventListener('click', saveSceneToXML);
        document.getElementById('load-button').addEventListener('click', () => {
            const fileInput = document.getElementById('file-input');
            if (fileInput) {
                fileInput.click(); 
            } else {
                showNotification("Error: File input element not found!", true);
            }
        });

        const fileInput = document.getElementById('file-input');
        if (fileInput) {
            fileInput.addEventListener('change', loadSceneFromXML);
        } else {
            console.error("File input element (#file-input) not found in DOM.");
            showNotification("Error: File input not initialized!", true);
        }
        document.getElementById('toggle-grid').addEventListener('change', (event) => { grid.visible = event.target.checked; });
        document.getElementById('toggle-orbit').addEventListener('click', toggleOrbitControls);
        document.getElementById('reset-camera').addEventListener('click', () => {
            controls.reset(); 
            camera.position.set(0, 20, 30); 
            camera.lookAt(0, 0, 0);
            controls.update(); 
            if (!controls.enabled) {
                controls.enabled = true;
                document.getElementById('toggle-orbit').textContent = 'Lock Camera';
            }
        });
        document.getElementById('help-button').addEventListener('click', () => { document.getElementById('modal-overlay').style.display = 'flex'; });
        document.getElementById('close-modal').addEventListener('click', () => { document.getElementById('modal-overlay').style.display = 'none'; });
        document.getElementById('modal-overlay').addEventListener('click', (event) => {
            if (event.target === document.getElementById('modal-overlay')) {
                document.getElementById('modal-overlay').style.display = 'none';
            }
        });
    }

    function setArrowColor(arrow, color) {
        if (arrow && arrow.line && arrow.cone) {
            arrow.line.material.color.setHex(color);
            arrow.cone.material.color.setHex(color);
        }
    }

    function onMouseDown(event) {
        if (event.button !== 0 || isBotAnimatingPush) return; // Ignore if bot is currently animating
        
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        // --- Bot Simulation Arrow Click ---
if (isSelectingBotSimulationDirection && simulationTargetData && teslaBotModel && botAnimationMixer && botWalkAction && botPushAction) {
    const simulationArrows = scene.children.filter(c => c.userData && c.userData.isSimulationArrow);
    const intersectsArrows = raycaster.intersectObjects(simulationArrows, true);

    if (intersectsArrows.length > 0) {
        let clickedArrowPart = intersectsArrows[0].object;
        let actualArrow = clickedArrowPart.userData.parentArrow || (clickedArrowPart.userData.isSimulationArrow ? clickedArrowPart : null);

        if (actualArrow && (actualArrow.userData.direction === 'positiveX_bot' || actualArrow.userData.direction === 'negativeX_bot')) {
            const directionForBot = actualArrow.userData.direction.startsWith('positiveX') ? 'positiveX' : 'negativeX';

            // Store target and direction
            botTargetDominoData = simulationTargetData;
            botPushDirection = directionForBot;

            // Call animation
            positionAndAnimateBot(botTargetDominoData, botPushDirection);

            isSelectingBotSimulationDirection = false;
            simulationTargetData = null;
            clearSimulationArrows();
            return;
        }
    } else {
        clearSimulationArrows();
        showNotification("Bot simulation direction selection canceled.");
    }
    return;
}


        // --- Regular Simulation Arrow Click ---
        if (isSelectingSimulationDirection && simulationTargetData) {
            const simulationArrows = scene.children.filter(c => c.userData && c.userData.isSimulationArrow);
            const intersectsArrows = raycaster.intersectObjects(simulationArrows, true); 

            if (intersectsArrows.length > 0) {
                let clickedArrowPart = intersectsArrows[0].object;
                let actualArrow = clickedArrowPart.userData.parentArrow || (clickedArrowPart.userData.isSimulationArrow ? clickedArrowPart : null);
                
                if (actualArrow && (actualArrow.userData.direction === 'positiveX' || actualArrow.userData.direction === 'negativeX')) {
                    const direction = actualArrow.userData.direction; 
                    let localImpulse = new CANNON.Vec3();
                    if (direction === 'positiveX') localImpulse.set(IMPULSE_MAGNITUDE, 0, 0); 
                    else localImpulse.set(-IMPULSE_MAGNITUDE, 0, 0); 
                    
                    const appPointLocal = new CANNON.Vec3(
                        direction === 'positiveX' ? -DOMINO_THICK / 2 : DOMINO_THICK / 2, 
                        DOMINO_TALL * 0.45, 0
                    );
                    
                    const worldImpulse = simulationTargetData.body.quaternion.vmult(localImpulse);
                    const worldApplicationPoint = simulationTargetData.body.quaternion.vmult(appPointLocal);
                    worldApplicationPoint.vadd(simulationTargetData.body.position, worldApplicationPoint);
                    
                    startSimulation({
                        targetBody: simulationTargetData.body,
                        worldImpulse: worldImpulse,
                        worldApplicationPoint: worldApplicationPoint
                    });
                    // isSelectingSimulationDirection is reset by clearSimulationArrows called in startSimulation
                    return; 
                }
            } else { // Clicked outside arrows
                clearSimulationArrows(); // This will reset isSelectingSimulationDirection
                showNotification("Simulation direction selection canceled.");
            }
            return; 
        }

        if (isMoving && translationMode && selectedDominoData) { 
            isMoving = false; translationMode = false;
            document.body.style.cursor = 'default'; controls.enabled = true;
            const modelPivotOffsetY = selectedDominoData.mesh.userData.modelPivotToBottomY || 0;
            
            const currentBasePosition = selectedDominoData.mesh.position.clone();
            currentBasePosition.y = 0; 

            const collision = checkDominoCollision(currentBasePosition, selectedDominoData);
            setEmissive(selectedDominoData, collision ? COLLISION_COLOR : SELECT_COLOR, 1.5);
            if (collision) {
                showNotification("Warning: Domino placement overlaps! Reverting.", true);
                const oldBase = selectedDominoData.initialBasePosition; 
                selectedDominoData.mesh.position.set(oldBase.x, oldBase.y - modelPivotOffsetY, oldBase.z);
                selectedDominoData.body.position.set(oldBase.x, oldBase.y + DOMINO_TALL / 2, oldBase.z);
            } else {
                showNotification("Position fixed.");
                selectedDominoData.initialBasePosition.copy(currentBasePosition); 
                selectedDominoData.body.position.set(currentBasePosition.x, currentBasePosition.y + DOMINO_TALL / 2, currentBasePosition.z);
            }
            if (selectedDominoData.userData && selectedDominoData.userData.collisionHelper) {
                selectedDominoData.userData.collisionHelper.position.copy(selectedDominoData.body.position);
            }
            return;
        }
        if (isRotating && rotationMode && selectedDominoData) { 
            isRotating = false; rotationMode = false;
            document.body.style.cursor = 'default'; controls.enabled = true;
            selectedDominoData.initialQuat.copy(selectedDominoData.body.quaternion); 
            setEmissive(selectedDominoData, SELECT_COLOR, 1.5);
            showNotification("Rotation fixed.");
            if (rotationArrowSprite) {
                scene.remove(rotationArrowSprite);
                rotationArrowSprite.visible = false;
            }
            return;
        }

        const intersectsDominoes = raycaster.intersectObjects(dominoes, true);
        if (intersectsDominoes.length > 0 && !isSimulating) {
            const clickedDominoData = findDominoDataFromObject(intersectsDominoes[0].object);
            if (clickedDominoData) {
                selectDomino(clickedDominoData);
            } else {
                 if (!isSelectingSimulationDirection && !isSelectingBotSimulationDirection) selectDomino(null); 
            }
        } else {
             if (!isSelectingSimulationDirection && !isSelectingBotSimulationDirection) selectDomino(null); 
        }
    }

    function onMouseMove(event) {
        if (!dominoModel || isBotAnimatingPush) return; // Ignore if bot is animating

        const currentMouse = new THREE.Vector2(
            ((event.clientX - renderer.domElement.getBoundingClientRect().left) / renderer.domElement.width) * 2 - 1,
            -((event.clientY - renderer.domElement.getBoundingClientRect().top) / renderer.domElement.height) * 2 + 1
        );
        raycaster.setFromCamera(currentMouse, camera);
        const worldPos = mouseToWorld(event); 
        const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;

        if (isAddingDomino && worldPos) {
            const basePosForGroupOrDomino = snapToGrid(worldPos); 

            if (previewDomino) {
                previewDomino.position.set(basePosForGroupOrDomino.x, basePosForGroupOrDomino.y - modelPivotCorrection, basePosForGroupOrDomino.z);
                const collision = checkDominoCollision(basePosForGroupOrDomino); 
                previewDomino.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.color.setHex(collision ? 0xff8888 : 0xffffff);
                        child.material.opacity = collision ? 0.4 : 0.6;
                    }
                });
            } else if (previewBatchGroup && previewBatchCount > 0) {
                updatePreviewBatchVisuals(basePosForGroupOrDomino); 
            } else if (previewCircleGroup) {
                previewCircleGroup.position.copy(basePosForGroupOrDomino); 
                let collisionInCircle = false;
                const tempWorldPosCheck = new THREE.Vector3();
                previewCircleGroup.updateMatrixWorld(true);
                for (const childPreview of previewCircleGroup.children) {
                    childPreview.getWorldPosition(tempWorldPosCheck);
                    if (checkDominoCollision(tempWorldPosCheck)) { 
                        collisionInCircle = true; break;
                    }
                }
                previewCircleGroup.traverse((child) => {
                    if (child.isMesh && child.material && child.userData.isDomino) {
                        child.material.color.setHex(collisionInCircle ? 0xff8888 : 0xffffff);
                        child.material.opacity = collisionInCircle ? 0.4 : 0.6;
                    }
                });
            } else if (previewSpiralGroup) {
                previewSpiralGroup.position.copy(basePosForGroupOrDomino); 
                let collisionInSpiral = false;
                const tempWorldPosCheck = new THREE.Vector3();
                previewSpiralGroup.updateMatrixWorld(true);
                for (const childPreview of previewSpiralGroup.children) {
                    childPreview.getWorldPosition(tempWorldPosCheck);
                    if (checkDominoCollision(tempWorldPosCheck)) { 
                        collisionInSpiral = true; break;
                    }
                }
                previewSpiralGroup.traverse((child) => {
                    if (child.isMesh && child.material && child.userData.isDomino) {
                        child.material.color.setHex(collisionInSpiral ? 0xff8888 : 0xffffff);
                        child.material.opacity = collisionInSpiral ? 0.4 : 0.6;
                    }
                });
            }
        }
        else if (selectedDominoData && isMoving && translationMode && worldPos) {
            const snappedBasePos = snapToGrid(worldPos); 
            selectedDominoData.mesh.position.set(snappedBasePos.x, snappedBasePos.y - modelPivotCorrection, snappedBasePos.z);
            selectedDominoData.body.position.set(snappedBasePos.x, snappedBasePos.y + DOMINO_TALL / 2, snappedBasePos.z);
            selectedDominoData.body.wakeUp(); 

            const collision = checkDominoCollision(snappedBasePos, selectedDominoData);
            setEmissive(selectedDominoData, collision ? COLLISION_COLOR : SELECT_COLOR, 1.5);

            if (selectedDominoData.userData && selectedDominoData.userData.collisionHelper) {
                selectedDominoData.userData.collisionHelper.position.copy(selectedDominoData.body.position);
            }
        } 
        else if (isSelectingSimulationDirection || isSelectingBotSimulationDirection) { // Combined check
            const simulationArrows = scene.children.filter(c => c.userData && c.userData.isSimulationArrow);
            let intersectedArrowThisFrame = null;
            if (simulationArrows.length > 0) {
                const intersects = raycaster.intersectObjects(simulationArrows, true);
                if (intersects.length > 0) {
                    let obj = intersects[0].object;
                    intersectedArrowThisFrame = obj.userData.parentArrow || (obj.userData.isSimulationArrow ? obj : null);
                }
            }

            if (hoveredSimulationArrow && hoveredSimulationArrow !== intersectedArrowThisFrame) {
                setArrowColor(hoveredSimulationArrow, hoveredSimulationArrow.userData.originalColor);
                hoveredSimulationArrow.userData.isPulsing = false;
                if (hoveredSimulationArrow.cone) hoveredSimulationArrow.cone.scale.set(1, 1, 1); 
            }
            if (intersectedArrowThisFrame) {
                setArrowColor(intersectedArrowThisFrame, ARROW_COLOR_HOVER);
                intersectedArrowThisFrame.userData.isPulsing = true; 
                document.body.style.cursor = 'pointer';
            } else {
                document.body.style.cursor = 'default';
            }
            hoveredSimulationArrow = intersectedArrowThisFrame;
        } 
        else if (!isSimulating) {
            updateHoverEffect(event);
        }
        lastMousePosition = { x: event.clientX, y: event.clientY };
    }

    function onMouseWheel(event) {
        if (isAddingDomino && previewBatchGroup && previewBatchCount > 0 && !isBotAnimatingPush) {
            event.preventDefault(); 
            event.stopPropagation(); 

            const rotationAmount = (event.deltaY < 0 ? 1 : -1) * (Math.PI / 36); 
            previewBatchGroup.rotation.y += rotationAmount;
            
            updatePreviewBatchVisuals(previewBatchGroup.position); 
        }
    }


    function onMouseUp(event) {
        if (event.button !== 0 || !dominoModel || isBotAnimatingPush) return; // Ignore if bot is animating

        if (isAddingDomino) {
            const worldPosAtMouseUp = mouseToWorld(event); 
            if (worldPosAtMouseUp) {
                const snappedAnchorPos = snapToGrid(worldPosAtMouseUp); 

                if (previewDomino) {
                    const collision = checkDominoCollision(snappedAnchorPos);
                    if (!collision) {
                        createDomino(snappedAnchorPos, previewDomino.rotation.y);
                    } else {
                        showNotification("Placement overlaps existing domino!", true);
                    }
                    previewDomino.visible = false;
                } else if (previewBatchGroup && previewBatchCount > 0) {
                    let collisionInBatch = false;
                    const finalPositionsAndRotations = [];
                    const tempWorldPosPlace = new THREE.Vector3();
                    const worldQuaternion = new THREE.Quaternion();
                    const euler = new THREE.Euler();

                    previewBatchGroup.position.copy(snappedAnchorPos);
                    previewBatchGroup.updateMatrixWorld(true); 

                    for (let i = 0; i < previewBatchCount; i++) {
                        const childPreview = previewBatchGroup.children[i];
                        childPreview.getWorldPosition(tempWorldPosPlace); 

                        if (checkDominoCollision(tempWorldPosPlace)) { 
                            collisionInBatch = true; break;
                        }

                        childPreview.getWorldQuaternion(worldQuaternion);
                        euler.setFromQuaternion(worldQuaternion, 'YXZ'); 

                        finalPositionsAndRotations.push({
                            position: tempWorldPosPlace.clone(), 
                            rotationY: euler.y 
                        });
                    }

                    if (!collisionInBatch) {
                        finalPositionsAndRotations.forEach(pr => {
                            pr.position.y = 0; 
                            createDomino(pr.position, pr.rotationY);
                        });
                    } else {
                        showNotification("Batch line placement overlaps existing dominoes!", true);
                    }
                    scene.remove(previewBatchGroup);
                    previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}});
                    previewBatchGroup = null;
                    previewBatchCount = 0;
                } else if (previewCircleGroup) {
                    previewCircleGroup.position.copy(snappedAnchorPos);
                    previewCircleGroup.updateMatrixWorld(true);

                    let collisionInCircle = false;
                    const finalDominosToCreate = [];
                    
                    for (const childPreview of previewCircleGroup.children) {
                        const tempPos = new THREE.Vector3();
                        childPreview.getWorldPosition(tempPos); 
                        
                        if (checkDominoCollision(tempPos)) { 
                            collisionInCircle = true; break;
                        }
                        const tempQuat = new THREE.Quaternion();
                        const tempEuler = new THREE.Euler();
                        childPreview.getWorldQuaternion(tempQuat);
                        tempEuler.setFromQuaternion(tempQuat, 'YXZ');

                        finalDominosToCreate.push({
                            position: tempPos.clone(), 
                            rotationY: tempEuler.y
                        });
                    }

                    if (!collisionInCircle) {
                        finalDominosToCreate.forEach(d => {
                            d.position.y = 0; 
                            createDomino(d.position, d.rotationY);
                        });
                    } else {
                        showNotification("Batch circle placement overlaps existing dominoes!", true);
                    }
                    scene.remove(previewCircleGroup);
                    previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}});
                    previewCircleGroup = null;
                    previewCircleCount = 0;
                } else if (previewSpiralGroup) {
                    previewSpiralGroup.position.copy(snappedAnchorPos);
                    previewSpiralGroup.updateMatrixWorld(true);
                    
                    let collisionInSpiral = false;
                    const finalDominosToCreate = [];
                    
                    for (const childPreview of previewSpiralGroup.children) {
                        const tempPos = new THREE.Vector3();
                        childPreview.getWorldPosition(tempPos); 

                        if (checkDominoCollision(tempPos)) { 
                            collisionInSpiral = true; break;
                        }
                        const tempQuat = new THREE.Quaternion();
                        const tempEuler = new THREE.Euler();
                        childPreview.getWorldQuaternion(tempQuat);
                        tempEuler.setFromQuaternion(tempQuat, 'YXZ');
                        finalDominosToCreate.push({
                            position: tempPos.clone(), 
                            rotationY: tempEuler.y
                        });
                    }

                    if (!collisionInSpiral) {
                        finalDominosToCreate.forEach(d => {
                            d.position.y = 0; 
                            createDomino(d.position, d.rotationY);
                        });
                    } else {
                        showNotification("Batch spiral placement overlaps existing dominoes!", true);
                    }
                    scene.remove(previewSpiralGroup);
                    previewSpiralGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}});
                    previewSpiralGroup = null;
                    previewSpiralCount = 0;
                }
            }
            isAddingDomino = false;
            document.body.style.cursor = 'default';
            controls.enabled = true;
        }
    }

    function onContextMenu(event) {
        event.preventDefault(); 
        if (isSimulating || isAddingDomino || isMoving || isRotating || isBotAnimatingPush) return; 

        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects(dominoes, true);
        if (intersects.length > 0) {
            const targetData = findDominoDataFromObject(intersects[0].object);
            if (targetData) {
                showContextMenu(event, targetData); 
            }
        } else {
            hideContextMenu(); 
            selectDomino(null); 
        }
    }

    function onKeyDown(event) {
        const key = event.key.toLowerCase();
        if (isBotAnimatingPush && key !== 'escape') return; // Allow escape to cancel bot animation potentially

        if (key === 'escape') {
            hideContextMenu();
            let modeCancelled = false;
            if (isAddingDomino) {
                if (previewDomino) previewDomino.visible = false;
                if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewBatchGroup = null; previewBatchCount = 0; }
                if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewCircleGroup = null; previewCircleCount = 0; }
                if (previewSpiralGroup) { scene.remove(previewSpiralGroup); previewSpiralGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewSpiralGroup = null; previewSpiralCount = 0; }
                isAddingDomino = false;
                modeCancelled = true;
            } else if (translationMode || rotationMode) { 
                if (selectedDominoData) {
                    const basePos = selectedDominoData.initialBasePosition; 
                    const modelPivotOffsetY = selectedDominoData.mesh.userData.modelPivotToBottomY || 0;
                    selectedDominoData.mesh.position.set(basePos.x, basePos.y - modelPivotOffsetY, basePos.z);
                    selectedDominoData.mesh.quaternion.copy(selectedDominoData.initialQuat);
                    selectedDominoData.body.position.set(basePos.x, basePos.y + DOMINO_TALL / 2, basePos.z);
                    selectedDominoData.body.quaternion.copy(selectedDominoData.initialQuat);
                    setEmissive(selectedDominoData, SELECT_COLOR, 1.5); 
                    if (rotationArrowSprite) { scene.remove(rotationArrowSprite); rotationArrowSprite.visible = false; }
                    if (selectedDominoData.userData && selectedDominoData.userData.collisionHelper) {
                        selectedDominoData.userData.collisionHelper.position.copy(selectedDominoData.body.position);
                        selectedDominoData.userData.collisionHelper.quaternion.copy(selectedDominoData.body.quaternion);
                    }
                }
                translationMode = false; rotationMode = false;
                isMoving = false; isRotating = false;
                modeCancelled = true;
            } else if (isSelectingSimulationDirection || isSelectingBotSimulationDirection) {
                clearSimulationArrows(); // This will reset the flags and enable controls
                showNotification("Direction selection canceled.");
                modeCancelled = true; 
            } else if (isBotAnimatingPush) { // Cancel bot animation
                if (botAnimationMixer) botAnimationMixer.stopAllAction();
                if (teslaBotModel) teslaBotModel.visible = false;
                isBotAnimatingPush = false;
                botTargetDominoData = null;
                botPushDirection = null;
                controls.enabled = true;
                showNotification("Bot animation canceled.");
                modeCancelled = true;
            }


            if (modeCancelled) {
                document.body.style.cursor = 'default';
                if (!isSimulating && !isBotAnimatingPush) controls.enabled = true; // Ensure controls are enabled if not simulating/botting
                if (!isAddingDomino && !translationMode && !rotationMode && !isSelectingSimulationDirection && !isSelectingBotSimulationDirection && !isBotAnimatingPush) {
                     // Only show "Action Canceled" if no other specific message was shown
                    if (!isSimulating) showNotification("Action canceled.");
                }
            } else if (!isSimulating) { 
                selectDomino(null);
            }
            return; 
        }

        if (selectedDominoData && !translationMode && !rotationMode && !isSelectingSimulationDirection && !isSelectingBotSimulationDirection && !isSimulating && !isBotAnimatingPush) {
            switch (key) {
                case 'delete': case 'backspace': deleteSelectedDomino(); break;
                case 't': 
                    document.getElementById('context-move').onclick = () => { 
                        translationMode = true; rotationMode = false; isMoving = true; isRotating = false;
                        lastMousePosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 }; 
                        showNotification("Move: Domino follows mouse. Left-click to fix. Esc to cancel.");
                        document.body.style.cursor = 'move'; controls.enabled = false; hideContextMenu();
                    };
                    document.getElementById('context-move').onclick(); 
                    document.getElementById('context-move').onclick = null; 
                    break;
                case 'r': 
                     document.getElementById('context-rotate').onclick = () => { 
                        rotationMode = true; translationMode = false; isRotating = true; isMoving = false;
                        lastMousePosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
                        showNotification("Rotate: Drag mouse horizontally. Left-click to fix. Esc to cancel.");
                        document.body.style.cursor = 'ew-resize'; controls.enabled = false;
                        animateRotation(selectedDominoData); hideContextMenu();
                    };
                    document.getElementById('context-rotate').onclick();
                    document.getElementById('context-rotate').onclick = null;
                    break;
            }
        }

        switch (key) {
            case 'g': 
                if (!translationMode && !rotationMode && !isAddingDomino && !isSimulating && !isBotAnimatingPush) { 
                    const cb = document.getElementById('toggle-grid');
                    cb.checked = !cb.checked;
                    grid.visible = cb.checked;
                }
                break;
            case ' ': 
                if (!isSimulating && !translationMode && !rotationMode && !isAddingDomino && !isSelectingSimulationDirection && !isSelectingBotSimulationDirection && !isBotAnimatingPush) {
                    if (dominoData.length > 0) {
                       startSimulation(); // This will use selectedDominoData if available, or prompt
                    } else {
                        showNotification("Add dominoes before starting simulation.", true);
                    }
                    event.preventDefault(); 
                }
                break;
        }
    }

    // --- Animation Loop ---
    const clock = new THREE.Clock();
    const pulseSpeed = 5; 
    const pulseMagnitude = 0.1;
    const fixedTimeStep = 1 / 60; 
    const maxSubSteps = 10;      

    function animate() {
        requestAnimationFrame(animate);
        const deltaTime = Math.min(clock.getDelta(), 0.1); 

        if (isSimulating) {
            world.step(fixedTimeStep, deltaTime, maxSubSteps);
        }

        if (botAnimationMixer && teslaBotModel && teslaBotModel.visible && isBotAnimatingPush) {
            botAnimationMixer.update(deltaTime);
        }


        if (hoveredSimulationArrow && hoveredSimulationArrow.userData.isPulsing) {
            hoveredSimulationArrow.userData.pulseTime += deltaTime * pulseSpeed;
            const scale = 1 + Math.sin(hoveredSimulationArrow.userData.pulseTime) * pulseMagnitude;
            if (hoveredSimulationArrow.cone) hoveredSimulationArrow.cone.scale.set(scale, scale, scale);
        }
        
        dominoData.forEach((data) => {
            const body = data.body;
            const mesh = data.mesh;
            const modelPivotToBottomY_offset = mesh.userData.modelPivotToBottomY || 0;
            
            mesh.quaternion.copy(body.quaternion);

            const localOffsetToVisualBase = new THREE.Vector3(0, (-DOMINO_TALL / 2) - modelPivotToBottomY_offset, 0);
            const worldOffsetToVisualBase = localOffsetToVisualBase.clone().applyQuaternion(mesh.quaternion);
            mesh.position.copy(body.position).add(worldOffsetToVisualBase);
        });

        if(controls.enabled) controls.update();  // Only update controls if enabled
        renderer.render(scene, camera);
    }

    // --- Initialization ---
    window.onload = function () {
        console.log("Initializing Domino Simulator...");
        initEventListeners();
        animate(); 
        console.log("Initialization Complete.");
    }
    </script>
</body>
</html>
