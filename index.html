<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domino Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: #333;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: default;
        }
        #toolbar {
            position: absolute; top: 0; left: 0; width: 200px; height: 100%;
            background-color: rgba(255, 255, 255, 0.85); border-right: 1px solid #ccc;
            padding: 20px; box-sizing: border-box; display: flex; flex-direction: column;
            z-index: 10; box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;
            overflow-y: auto; 
        }
        .toolbar-title { font-size: 18px; font-weight: bold; margin-bottom: 20px; text-align: center; }
        .toolbar-section { margin-bottom: 20px; }
        .toolbar-section-title { font-size: 14px; font-weight: bold; margin-bottom: 10px; color: #555; }
        .toolbar-button { display: flex; align-items: center; padding: 8px 12px; margin-bottom: 8px; background-color: #f5f5f5; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        .toolbar-button:hover { background-color: #e0e0e0; }
        .toolbar-button.active { background-color: #d0d0d0; }
        .toolbar-button.start { background-color: #e6ffe6; }
        .toolbar-button.start:hover { background-color: #d6efd6; }
        .toolbar-button.reset { background-color: #fff0e6; }
        .toolbar-button.reset:hover { background-color: #f5e6d6; }
        .toolbar-button.clear { background-color: #ffe6e6; }
        .toolbar-button.clear:hover { background-color: #f5d6d6; }
        .draggable-domino { width: 40px; height: 80px; background-color: #fff; border: 2px solid #333; margin: 10px auto; border-radius: 4px; cursor: grab; display: flex; align-items: center; justify-content: center; }
        .draggable-domino:active { cursor: grabbing; }
        .checkbox-container { display: flex; align-items: center; margin-bottom: 8px; }
        .checkbox-container input { margin-right: 8px; }
        #corner-panel { position: absolute; top: 20px; right: 20px; background-color: rgba(255, 255, 255, 0.8); border-radius: 4px; padding: 10px; display: flex; flex-direction: column; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); z-index: 10; }
        #corner-panel button { margin-bottom: 8px; padding: 8px 12px; background-color: #f5f5f5; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        #corner-panel button:hover { background-color: #e0e0e0; }
        #help-button { width: 24px; height: 24px; background-color: #f0f0f0; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-top: 10px; align-self: center; }
        #modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 100; }
        #help-modal { background-color: white; padding: 20px; border-radius: 8px; max-width: 500px; width: 80%; max-height: 80%; overflow-y: auto; }
        #help-modal h2 { margin-top: 0; }
        #close-modal { float: right; background: none; border: none; font-size: 18px; cursor: pointer; }
        #notification { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7); color: white; padding: 10px 20px; border-radius: 4px; font-size: 14px; opacity: 0; transition: opacity 0.3s; z-index: 30; }
        #custom-context-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            padding: 5px 0;
            z-index: 1000;
            display: none;
            min-width: 120px;
        }
        #custom-context-menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #custom-context-menu li {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
        }
        #custom-context-menu li:hover {
            background-color: #f0f0f0;
        }
        #custom-context-menu li.separator {
            height: 1px;
            background-color: #eee;
            margin: 5px 0;
            padding: 0;
        }
		#file-input { display: none; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="toolbar">
        <div class="toolbar-title">Domino Simulator</div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Add Domino</div>
            <div class="draggable-domino" id="domino-template">
                <svg width="20" height="40" viewBox="0 0 20 40"><rect x="2" y="2" width="16" height="36" fill="white" stroke="black" stroke-width="1"/><circle cx="10" cy="10" r="2" fill="black"/><circle cx="10" cy="30" r="2" fill="black"/></svg>
            </div>
        </div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Add Batch</div>
            <div class="toolbar-button" id="add-batch-button">
                <div class="toolbar-button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <rect x="4" y="6" width="4" height="12" fill="#333"/>
                        <rect x="10" y="6" width="4" height="12" fill="#333"/>
                        <rect x="16" y="6" width="4" height="12" fill="#333"/>
                    </svg>
                </div>
                <span>Add Batch Line</span>
            </div>
            <div class="toolbar-button" id="add-batch-circle-button"> <div class="toolbar-button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="8" stroke="#333" stroke-width="2" fill="none"/>
                    </svg>
                </div>
                <span>Add Batch Circle</span>
            </div>
            <div class="toolbar-button" id="add-batch-spiral-button">
                <div class="toolbar-button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <path d="M12 2 A2 2 0 0 1 12 6 A6 6 0 0 1 12 18 A10 10 0 0 1 12 22" fill="none" stroke="#333" stroke-width="2"/>
                    </svg>
                </div>
                <span>Add Batch Spiral</span>
            </div>			
        </div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Simulation</div>
            <div class="toolbar-button reset" id="reset-button"><div class="toolbar-button-icon"><svg viewBox="0 0 24 24" width="20" height="20"><path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z" fill="#ff9800"/></svg></div><span>Reset Scene</span></div>
            <div class="toolbar-button clear" id="clear-button"><div class="toolbar-button-icon"><svg viewBox="0 0 24 24" width="20" height="20"><path d="M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19M8,9H16V19H8V9M15.5,4L14.5,3H9.5L8.5,4H5V6H19V4H15.5Z" fill="#f44336"/></svg></div><span>Clear Canvas</span></div>
        </div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">File Operations</div>
            <div class="toolbar-button load" id="load-button"><div class="toolbar-button-icon"><svg viewBox="0 0 24 24" width="20" height="20"><path d="M19 12H15.5L13 9.5L10.5 12H7L10 15L13 18L16 15H19V12ZM5 3H19C20.1 3 21 3.9 21 5V19C21 20.1 20.1 21 19 21H5C3.9 21 3 20.1 3 19V5C3 3.9 3.9 3 5 3Z" fill="#2196f3"/></svg></div><span>Load Scene</span></div>
            <div class="toolbar-button save" id="save-button"><div class="toolbar-button-icon"><svg viewBox="0 0 24 24" width="20" height="20"><path d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM10 16L7 13L10 10H7V8H13V14H10V16ZM17 16H14V14H17V16Z" fill="#9c27b0"/></svg></div><span>Save Scene</span></div>
        </div>
        <div class="toolbar-section">		
            <div class="toolbar-section-title">Display</div>
            <div class="checkbox-container"><input type="checkbox" id="toggle-grid" checked><label for="toggle-grid">Show Grid</label></div>
        </div>
    </div>
    <div id="corner-panel">
        <button id="toggle-orbit">Lock Camera</button> 
        <button id="reset-camera">Reset Camera</button>
        <div id="help-button">?</div>
    </div>
    <div id="custom-context-menu">
        <ul>
            <li id="context-move">Move (T)</li>
            <li id="context-rotate">Rotate (R)</li>
            <li class="separator"></li>
            <li id="context-start-simulation">Start Simulation (Space)</li>
            <li class="separator"></li>
            <li id="context-delete">Delete (Del)</li>
        </ul>
    </div>
    <div id="notification"></div>
    <div id="modal-overlay">
        <div id="help-modal">
            <button id="close-modal">Ã—</button>
            <h2>Domino Simulator Help</h2>
            <h3>Controls</h3>
            <ul>
                <li><strong>Add Domino:</strong> Drag from the toolbar to the canvas (snaps to grid)</li>
                <li><strong>Add Batch Line:</strong> Click "Add Batch Line", enter number (2-20), drag to place</li>
                <li><strong>Add Batch Circle:</strong> Click "Add Batch Circle", enter number (20-40), drag to place center</li>
                <li><strong>Select:</strong> Left-click on a domino</li>
                <li><strong>Hover:</strong> Mouse over a domino to highlight blue</li>
                <li><strong>Move (T):</strong> Right-click domino -> Move, then left-click & drag</li>
                <li><strong>Rotate (R):</strong> Right-click domino -> Rotate, then left-click & drag horizontally</li>
                <li><strong>Delete (Del):</strong> Right-click domino -> Delete, or press Delete/Backspace</li>
                <li><strong>Start Simulation (Space):</strong> Press Spacebar or use context menu arrows</li>
                <li><strong>Reset:</strong> Click the reset button</li>
                <li><strong>Clear:</strong> Remove all dominoes</li>
				<li><strong>Load Scene:</strong> Click "Load Scene" to upload an XML file</li>
                <li><strong>Save Scene:</strong> Click "Save Scene" to download the scene as an XML file</li>
                <li><strong>Toggle Grid (G):</strong> Checkbox or press G</li>
                <li><strong>Context Menu:</strong> Right-click on a domino</li>
            </ul>
            <h3>Camera Controls</h3>
            <ul>
                <li><strong>Rotate View:</strong> Left-click and drag on empty space</li>
                <li><strong>Pan:</strong> Right-click and drag or middle mouse drag</li>
                <li><strong>Zoom:</strong> Scroll with mouse wheel</li>
                <li><strong>Lock Camera:</strong> Toggle button in top-right</li>
                <li><strong>Reset Camera:</strong> Button in top-right</li>
            </ul>
        </div>
    </div>
    <input type="file" id="file-input" accept=".xml" style="display: none;" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // --- Constants ---
        const DOMINO_TALL = 2.01642;
        const DOMINO_WIDE = 1.01067; // Corresponds to local Z-axis of physics body
        const DOMINO_THICK = 0.258223; // Corresponds to local X-axis of physics body
        const PLANE_SIZE = 100;
        const GRID_SIZE = 100;
        const GRID_DIVISIONS = 100;
        const GRID_UNIT_SIZE = 1;
        const MIN_PLACEMENT_DISTANCE = 1; 
        const SELECT_COLOR = 0x555555;
        const HOVER_COLOR = 0x0055ff;
        const COLLISION_COLOR = 0xff0000;
        const IMPULSE_MAGNITUDE = 3.5;
        const ARROW_COLOR_DEFAULT = 0xff0000;
        const ARROW_COLOR_HOVER = 0x0077ff;

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xE0E0E0);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 30);
        camera.lookAt(0, 0, 0);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(20, 35, 25);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096;
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 100;
        directionalLight.shadow.camera.left = -PLANE_SIZE / 2;
        directionalLight.shadow.camera.right = PLANE_SIZE / 2;
        directionalLight.shadow.camera.top = PLANE_SIZE / 2;
        directionalLight.shadow.camera.bottom = -PLANE_SIZE / 2;
        directionalLight.shadow.bias = -0.0005;
        scene.add(directionalLight);

        // --- Physics ---
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.solver.iterations = 30;
        world.solver.tolerance = 0.001;
        world.allowSleep = true;
        world.defaultContactMaterial.restitution = 0.0;
        world.defaultContactMaterial.contactEquationStiffness = 1e6;
        world.defaultContactMaterial.contactEquationRelaxation = 3;

        const groundPhysMaterial = new CANNON.Material("groundMaterial");
        const dominoPhysMaterial = new CANNON.Material("dominoMaterial");

        const groundDominoContactMaterial = new CANNON.ContactMaterial(
            groundPhysMaterial,
            dominoPhysMaterial,
            { friction: 0.01, restitution: 0.0, contactEquationStiffness: 1e5, contactEquationRelaxation: 2.0 }
        );
        world.addContactMaterial(groundDominoContactMaterial);
        const dominoDominoContactMaterial = new CANNON.ContactMaterial(
            dominoPhysMaterial,
            dominoPhysMaterial,
            {
                friction: 0.005,
                restitution: 0.0,
                contactEquationStiffness: 1e6,
                contactEquationRelaxation: 1.5,
                contactSkinSize: 0
            }
        );
        world.addContactMaterial(dominoDominoContactMaterial);

        // --- Ground ---
        const groundGeometry = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0xbbbbbb, roughness: 0.8, metalness: 0.2 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        ground.name = "Ground";
        scene.add(ground);
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, material: groundPhysMaterial });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        groundBody.position.set(0, 0.01, 0); 
        world.addBody(groundBody);

        // --- Grid Helper ---
        const grid = new THREE.GridHelper(GRID_SIZE, GRID_DIVISIONS, 0x666666, 0xaaaaaa);
        grid.position.y = 0.01; 
        grid.material.opacity = 0.6;
        grid.material.transparent = true;
        grid.visible = true;
        scene.add(grid);

        // --- Controls ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 80;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;

        // --- State Variables ---
        let dominoes = []; 
        let dominoData = []; 
        let selectedDominoData = null;
        let hoveredDominoData = null;
        let hoveredSimulationArrow = null;
        let isSimulating = false;
        let isAddingDomino = false; 
        let previewDomino = null; 
        let previewBatchGroup = null; 
        let previewBatchCount = 0;
        let previewCircleGroup = null; 
        let previewCircleCount = 0;
        let previewSpiralGroup = null;
        let previewSpiralCount = 0;
		

        let lastMousePosition = { x: 0, y: 0 };
        let translationMode = false;
        let rotationMode = false;
        let isMoving = false;
        let isRotating = false;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const contextMenu = document.getElementById('custom-context-menu');
        let isSelectingSimulationDirection = false;
        let simulationTargetData = null;
        let dominoModel = null; 
        let rotationArrowSprite = null;

        // --- Load GLB Model ---
        const loader = new THREE.GLTFLoader();
        loader.load(
            'https://vita2048.github.io/DominoSimulator/OneBlockVerticalTransformed.glb',
            (gltf) => {
                dominoModel = gltf.scene;
                dominoModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        child.userData.isDomino = true; 
                        if (child.material) {
                            child.material = new THREE.MeshStandardMaterial({
                                map: child.material.map || null,
                                normalMap: child.material.normalMap || null,
                                roughness: child.material.roughness || 0.7,
                                metalness: child.material.metalness || 0.1,
                                emissive: new THREE.Color(0x000000),
                                emissiveIntensity: 1,
                                color: child.material.color || 0xffffff
                            });
                            if (child.geometry) child.geometry.computeBoundingBox(); 
                        }
                    }
                });
                const box = new THREE.Box3().setFromObject(dominoModel);
                const size = new THREE.Vector3();
                box.getSize(size);
                const scaleFactor = DOMINO_TALL / size.y;
                dominoModel.scale.set(scaleFactor, scaleFactor, scaleFactor);

                const scaledBox = new THREE.Box3().setFromObject(dominoModel);
                dominoModel.userData.pivotToBottomY = scaledBox.min.y; 
                
                console.log("Scaled model size:", scaledBox.getSize(new THREE.Vector3()));
                console.log("Pivot to bottom Y offset (scaledBox.min.y):", dominoModel.userData.pivotToBottomY);
                
                createPreviewDomino(); 
            },
            undefined, 
            (error) => {
                console.error("Error loading GLB model:", error);
                showNotification("Error: Could not load domino model.", true);
            }
        );
		
    // --- Save/Load Functionality ---
function saveSceneToXML() {
        if (dominoData.length === 0) {
            showNotification("No dominoes to save!", true);
            return;
        }

        let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
        xml += '<DominoScene>\n';
        dominoData.forEach((data, index) => {
            const pos = data.initialBasePosition;
            const quat = data.mesh.quaternion; // Get the quaternion directly

            // Log the quaternion components for debugging if needed
            // console.log(`Saving Domino ${index}: Position ${pos.x}, ${pos.y}, ${pos.z}, Quaternion x:${quat.x}, y:${quat.y}, z:${quat.z}, w:${quat.w}`);

            xml += `  <Domino id="${index}">\n`;
            xml += `    <Position x="${pos.x}" y="${pos.y}" z="${pos.z}" />\n`;
            // Save quaternion components instead of Euler Y
            xml += `    <Quaternion x="${quat.x}" y="${quat.y}" z="${quat.z}" w="${quat.w}" />\n`;
            xml += `  </Domino>\n`;
        });
        xml += '</DominoScene>';

        const blob = new Blob([xml], { type: 'text/xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'domino_scene.xml';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showNotification("Scene saved as domino_scene.xml");
    }

function loadSceneFromXML(event) {
        const file = event.target.files[0];
        if (!file) {
            showNotification("No file selected.", true);
            return;
        }

        const reader = new FileReader();
        reader.onload = function(e) {
            const text = e.target.result;
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(text, 'text/xml');
                const errorNode = xmlDoc.querySelector('parsererror');
                if (errorNode) {
                    showNotification("Error parsing XML file.", true);
                    return;
                }

                clearCanvas();

                const dominoNodes = xmlDoc.getElementsByTagName('Domino');
                for (let i = 0; i < dominoNodes.length; i++) {
                    const dominoNode = dominoNodes[i]; // Renamed to avoid conflict
                    const posNode = dominoNode.getElementsByTagName('Position')[0];
                    const quatNode = dominoNode.getElementsByTagName('Quaternion')[0]; // Get Quaternion node

                    const pos = new THREE.Vector3(
                        parseFloat(posNode.getAttribute('x')),
                        parseFloat(posNode.getAttribute('y')),
                        parseFloat(posNode.getAttribute('z'))
                    );

                    // Read quaternion components
                    const qx = parseFloat(quatNode.getAttribute('x'));
                    const qy = parseFloat(quatNode.getAttribute('y'));
                    const qz = parseFloat(quatNode.getAttribute('z'));
                    const qw = parseFloat(quatNode.getAttribute('w'));
                    const loadedQuaternion = new THREE.Quaternion(qx, qy, qz, qw);

                    // Log the loaded quaternion for debugging if needed
                    // console.log(`Loading Domino ${i}: Position ${pos.x}, ${pos.y}, ${pos.z}, Quaternion x:${qx}, y:${qy}, z:${qz}, w:${qw}`);

                    // Create domino with a default rotation (e.g., 0 for rotationY)
                    // The actual rotation will be set from the loaded quaternion.
                    const newDomino = createDomino(pos, 0); 

                    if (newDomino) {
                        // Apply the loaded quaternion directly
                        newDomino.mesh.quaternion.copy(loadedQuaternion);
                        newDomino.body.quaternion.copy(loadedQuaternion);
                        newDomino.body.wakeUp(); 
                        newDomino.initialQuat.copy(loadedQuaternion); // Important: update initialQuat

                        // Optional: Verify applied quaternion by converting to Euler for logging if desired
                        // const appliedEuler = new THREE.Euler().setFromQuaternion(newDomino.mesh.quaternion, 'XYZ');
                        // console.log(`Applied Rotation Y for Domino ${i} (from Quat): ${(appliedEuler.y * 180 / Math.PI).toFixed(2)} degrees`);
                    }
                }

                showNotification(`Loaded ${dominoNodes.length} dominoes.`);
            } catch (err) {
                showNotification("Error loading scene: " + err.message, true);
                console.error("Error loading scene:", err);
            }
        };
        reader.onerror = function() {
            showNotification("Error reading file.", true);
        };
        reader.readAsText(file);

        document.getElementById('file-input').value = '';
    }
	
function createPreviewSpiral(numberOfPieces, spiralGrowthRate = 0.6) {
    if (previewSpiralGroup) {
        scene.remove(previewSpiralGroup);
        previewSpiralGroup.traverse(child => {
            if (child.isMesh) {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                    else child.material.dispose();
                }
            }
        });
    }
    previewSpiralGroup = new THREE.Group();
    const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;
    
    const N = numberOfPieces;
    
    
    // For a spiral of dominos, we need to consider the length (which would be DOMINO_WIDE in this case)
    // since that's what affects the spacing when they're placed in sequence
    const dominoLength = DOMINO_WIDE;
    
    // Constants for the spiral
    const desiredSpacing = dominoLength * 1; // Distance between dominos
    const startingRadius = dominoLength * 2; // Minimum distance from center to avoid crowding
    
    // Array to store the positions and angles
    const positions = [];
    
    // Place the first domino at the starting radius
    let currentRadius = startingRadius;
    let currentAngle = 0;
    positions.push({ radius: currentRadius, angle: currentAngle });
    
    // Calculate positions for each remaining domino
    for (let i = 1; i < N; i++) {
        // Calculate angle increment based on desired spacing and current radius
        // For constant arc length, angle = arcLength / radius
        const angleIncrement = desiredSpacing / currentRadius;
        
        // Update angle
        currentAngle += angleIncrement;
        
        // Calculate radius increment using the growth rate parameter
        // Higher growth rate = faster expanding spiral
        const baseRadiusIncrement = desiredSpacing / (2 * Math.PI);
        const radiusIncrement = baseRadiusIncrement * spiralGrowthRate;
        
        // Update radius
        currentRadius += radiusIncrement;
        
        // Store this position
        positions.push({ radius: currentRadius, angle: currentAngle });
    }
    
    // Now place the dominos at the calculated positions
    for (let i = 0; i < positions.length; i++) {
        const { radius, angle } = positions[i];
        
        // Calculate position
        const posX = radius * Math.cos(angle);
        const posZ = radius * Math.sin(angle);
        
        const singlePreview = dominoModel.clone();
        singlePreview.traverse((child) => {
            if (child.isMesh) {
                child.material = child.material.clone();
                child.material.transparent = true;
                child.material.opacity = 0.6;
                child.userData.isDomino = true;
            }
        });
        singlePreview.position.set(posX, 0 - modelPivotCorrection, posZ);
        
        // Orient domino tangentially to the spiral
        // The tangent is perpendicular to the radius
        const tangentAngle = angle + Math.PI/2;
        singlePreview.rotation.y = -tangentAngle;
        
        previewSpiralGroup.add(singlePreview);
    }
    
    scene.add(previewSpiralGroup);
    previewSpiralCount = numberOfPieces;
}

        function onAddBatchSpiral() {
            if (isSimulating || !dominoModel) return;
            const numDominosStr = prompt("Enter number of pieces for the spiral (20-80):", "40");
            if (numDominosStr === null) return;
            const n = parseInt(numDominosStr);
            if (isNaN(n) || n < 20 || n > 80) {
                showNotification("Invalid number. Please enter a value between 20 and 80.", true);
                return;
            }

            if (previewDomino) { previewDomino.visible = false; }
            previewDomino = null;
            if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewBatchGroup = null; previewBatchCount = 0; }
            if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewCircleGroup = null; previewCircleCount = 0; }
            if (previewSpiralGroup) { scene.remove(previewSpiralGroup); previewSpiralGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewSpiralGroup = null; previewSpiralCount = 0; }

            createPreviewSpiral(n);
            isAddingDomino = true;
            controls.enabled = false;
            document.body.style.cursor = 'grabbing';
            hideContextMenu();
        }

        // --- Domino Creation ---
        function createPreviewDomino() {
            if (!dominoModel) return;
            if (previewDomino) { 
                scene.remove(previewDomino);
                previewDomino.traverse(child => { if (child.isMesh) {if (child.geometry) child.geometry.dispose(); if (child.material) child.material.dispose();} });
            }
            previewDomino = dominoModel.clone();
            previewDomino.traverse((child) => {
                if (child.isMesh) {
                    child.material = child.material.clone(); 
                    child.material.transparent = true;
                    child.material.opacity = 0.6;
                    child.userData.isDomino = true;
                }
            });
            const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;
            previewDomino.position.y = 0 - modelPivotCorrection; 
            previewDomino.rotation.y = 0; 
            previewDomino.visible = false;
            scene.add(previewDomino);
        }

    // --- Domino Creation ---
    function createDomino(basePosition, rotationY = 0) {
        if (!dominoModel) {
            showNotification("Error: Domino model not ready.", true);
            return null;
        }

        const dominoMesh = dominoModel.clone();
        dominoMesh.userData.isDomino = true;
        const modelPivotToBottomY_offset = dominoModel.userData.pivotToBottomY || 0;
        dominoMesh.userData.modelPivotToBottomY = modelPivotToBottomY_offset;
        dominoMesh.position.set(basePosition.x, basePosition.y - modelPivotToBottomY_offset, basePosition.z);

        // Set rotation using Euler to preserve sign
        const euler = new THREE.Euler(0, rotationY, 0, 'XYZ');
        dominoMesh.quaternion.setFromEuler(euler);

        dominoMesh.traverse((child) => {
            if (child.isMesh && child.material) {
                child.material = child.material.clone(); 
                child.userData.isDominoPart = true;
            }
        });
        scene.add(dominoMesh);

        const shape = new CANNON.Box(new CANNON.Vec3(DOMINO_THICK / 2, DOMINO_TALL / 2, DOMINO_WIDE / 2));
        const bodyCoMPosition = new CANNON.Vec3(basePosition.x, basePosition.y + DOMINO_TALL / 2, basePosition.z);
        const dominoBody = new CANNON.Body({
            mass: 1.0,
            position: bodyCoMPosition,
            shape: shape,
            material: dominoPhysMaterial,
            linearDamping: 0.15,
            angularDamping: 0.4,
            collisionResponse: true
        });

        // Apply the same initial rotation to the physics body
        dominoBody.quaternion.copy(dominoMesh.quaternion);

        dominoBody.allowSleep = true;
        dominoBody.sleepSpeedLimit = 0.5;
        dominoBody.sleepTimeLimit = 1.0;

        dominoMesh.userData.body = dominoBody;
        dominoBody.userData = { mesh: dominoMesh }; 

        const data = {
            mesh: dominoMesh,
            body: dominoBody,
            initialBasePosition: basePosition.clone(), 
            initialQuat: new THREE.Quaternion().copy(dominoMesh.quaternion) 
        };

        dominoData.push(data);
        dominoes.push(dominoMesh); 
        world.addBody(dominoBody);
        return data;
    }
        
        // --- Collision & Placement ---
        function snapToGrid(position) {
            const snappedX = Math.round(position.x / GRID_UNIT_SIZE) * GRID_UNIT_SIZE;
            const snappedZ = Math.round(position.z / GRID_UNIT_SIZE) * GRID_UNIT_SIZE;
            return new THREE.Vector3(snappedX, 0, snappedZ); 
        }

        function checkDominoCollision(position, excludeData = null) {
            const snappedPos = snapToGrid(position); 
            for (const data of dominoData) {
                if (data === excludeData) continue; 
                const dx = data.initialBasePosition.x - snappedPos.x;
                const dz = data.initialBasePosition.z - snappedPos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < MIN_PLACEMENT_DISTANCE) return true; 
            }
            return false;
        }

        function mouseToWorld(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(ground); 
            return intersects.length > 0 ? intersects[0].point : null;
        }

        // --- Highlighting ---
        function setEmissive(dominoData, colorHex = 0x000000, intensity = 1) {
            if (!dominoData || !dominoData.mesh) return;
            dominoData.mesh.traverse((child) => {
                if (child.isMesh && child.material && child.material.emissive) {
                    child.material.emissive.setHex(colorHex);
                    child.material.emissiveIntensity = intensity;
                }
            });
        }

        function findDominoDataFromObject(object) {
            let current = object;
            while (current) {
                if (current.userData && current.userData.body) {
                    return dominoData.find(data => data.mesh === current);
                }
                if (current.parent && current.parent.userData && current.parent.userData.body && current.userData.isDominoPart) {
                     return dominoData.find(data => data.mesh === current.parent);
                }
                current = current.parent;
            }
            return null;
        }

        function updateHoverEffect(event) {
            if (isAddingDomino || isSimulating || translationMode || rotationMode || isSelectingSimulationDirection) {
                if (hoveredDominoData && hoveredDominoData !== selectedDominoData) {
                    setEmissive(hoveredDominoData, 0x000000); 
                }
                hoveredDominoData = null;
                return;
            }

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(dominoes, true); 
            let currentlyHoveredData = null;

            if (intersects.length > 0) {
                currentlyHoveredData = findDominoDataFromObject(intersects[0].object);
            }

            if (hoveredDominoData !== currentlyHoveredData) {
                if (hoveredDominoData && hoveredDominoData !== selectedDominoData) {
                    setEmissive(hoveredDominoData, 0x000000); 
                }
                if (currentlyHoveredData && currentlyHoveredData !== selectedDominoData) {
                    setEmissive(currentlyHoveredData, HOVER_COLOR, 1.5); 
                }
                hoveredDominoData = currentlyHoveredData;
            }
        }

        // --- Selection & Manipulation ---
        function selectDomino(dataToSelect) {
            if (selectedDominoData === dataToSelect && dataToSelect !== null) return; 

            if (selectedDominoData) {
                setEmissive(selectedDominoData, 0x000000); 
            }

            if (isSelectingSimulationDirection && selectedDominoData !== dataToSelect) {
                clearSimulationArrows(); 
            }

            selectedDominoData = dataToSelect;

            if (selectedDominoData) {
                setEmissive(selectedDominoData, SELECT_COLOR, 1.5); 
                if (hoveredDominoData === selectedDominoData) {
                    hoveredDominoData = null; 
                }
            } else {
                if (translationMode || rotationMode) { 
                    translationMode = false;
                    rotationMode = false;
                    isMoving = false;
                    isRotating = false;
                    document.body.style.cursor = 'default';
                    controls.enabled = true;
                    if (rotationArrowSprite) scene.remove(rotationArrowSprite);
                }
                if (hoveredDominoData) {
                     setEmissive(hoveredDominoData, HOVER_COLOR, 1.5);
                }
            }
            hideContextMenu();
        }




function createRotationArrows() {
    const canvas = document.createElement('canvas');
    const canvasSize = 128; // Use a variable for size
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    const ctx = canvas.getContext('2d');

    // --- Canvas Drawing Code (exactly as you provided) ---
    // Clear canvas with transparent background
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Style for the arrows
    ctx.strokeStyle = '#ff0000'; // Red color
    ctx.fillStyle = '#ff0000';   // Red color for filled arrowheads
    ctx.lineWidth = 8;         // Line thickness for the arc
    ctx.lineCap = 'round';     // Rounded ends for the arc stroke
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = canvasSize * 0.3125; // e.g., 40 for 128px canvas
    const arrowLength = canvasSize * 0.125; // e.g., 16 for 128px canvas
    const arrowheadAngle = Math.PI / 6; // Angle of the arrowhead wings (30 degrees)
    const startAngle = Math.PI * 0.25; // 45 degrees
    const endAngle = Math.PI * 1.75;   // 315 degrees (or -45 degrees)
    ctx.save();
    ctx.translate(centerX, centerY); // Move origin to center for rotation
    ctx.rotate(-Math.PI / 2);        // Rotate context (affects drawing)
    ctx.translate(-centerX, -centerY); // Move origin back
    ctx.beginPath(); // Draw the partial circle arc
    ctx.arc(centerX, centerY, radius, startAngle, endAngle, false);
    ctx.stroke(); // Draw the arc line
    function drawArrowhead(ctx, x, y, direction, length, angle) { // Helper function
        ctx.save(); ctx.beginPath(); ctx.translate(x, y); ctx.rotate(direction);
        ctx.moveTo(0, 0);
        const wingX = -length; const wingY1 = length * Math.tan(angle / 2); const wingY2 = -length * Math.tan(angle / 2);
        ctx.lineTo(wingX, wingY1); ctx.lineTo(wingX, wingY2); ctx.closePath();
        ctx.fill(); ctx.restore();
    }
    // Calculate points and directions (with your tweaks)
    const startX = centerX + radius * Math.cos(startAngle - 0.2);
    const startY = centerY + radius * Math.sin(startAngle - 0.2);
    const directionStart = startAngle + Math.PI / 2 + Math.PI;
    const endX = centerX + radius * Math.cos(endAngle + 0.2);
    const endY = centerY + radius * Math.sin(endAngle + 0.2);
    const directionEnd = endAngle + Math.PI / 2;
    // Draw the arrowheads
    drawArrowhead(ctx, startX, startY, directionStart, arrowLength, arrowheadAngle * 2);
    drawArrowhead(ctx, endX, endY, directionEnd, arrowLength, arrowheadAngle * 2);
    ctx.restore(); // Restore context state
    // --- End of Canvas Drawing Code ---


    // --- Create THREE.js Texture (same as before) ---
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true; // Good practice after canvas drawing

    // --- *** CHANGE: Create a Mesh instead of a Sprite *** ---

    // 1. Define the size of the plane in your 3D world units.
    //    Adjust this size to match how big you want the arrow circle to be on the ground.
    const planeSize = 3; // Example: 0.5x0.5 units in the world

    // 2. Create the Plane Geometry
    const geometry = new THREE.PlaneGeometry(planeSize, planeSize);

    // 3. Create the Material using the texture
    const material = new THREE.MeshBasicMaterial({ // Use MeshBasicMaterial (unlit)
        map: texture,          // The texture from the canvas
        color: 0xffffff,       // Use texture's color
        transparent: true,     // Allow transparency
        alphaTest: 0.1,        // Optimization for transparent edges
        depthTest: false,      // Optional: Render on top of other objects
        depthWrite: false,     // Optional: Don't hide objects behind it
        side: THREE.DoubleSide // Make visible from both sides (e.g., if camera goes below grid)
        // Note: sizeAttenuation is a SpriteMaterial property, not used here.
    });

    // 4. Create the Mesh object
    const mesh = new THREE.Mesh(geometry, material);

    // 5. *** Rotate the Mesh to be parallel to the ground grid ***
    //    This assumes your ground grid lies on the XZ plane (Y is up).
    //    Rotate it -90 degrees around the X-axis.
    mesh.rotation.x = -Math.PI / 2;

    // 6. Set Position (relative to the domino or world origin)
    //    Position it slightly above the ground (Y=0) to prevent flickering (z-fighting).
    mesh.position.y = 0.01; // Small offset in the 'up' direction
    // You will typically set mesh.position.x and mesh.position.z later
    // to place it next to the domino being rotated.

    // 7. Set other properties as needed
    mesh.visible = false;
    mesh.userData.isRotationArrow = true; // Keep your flag
    mesh.renderOrder = 1;               // Keep render order if needed

    // 8. Return the Mesh
    return mesh;
}

function animateRotation(data) {
    if (!data || !data.mesh || !data.body || !scene || typeof DOMINO_TALL === 'undefined') return;
    if (!rotationArrowSprite) rotationArrowSprite = createRotationArrows();

    const visualYPosition = data.mesh.position.y + (data.mesh.userData.modelPivotToBottomY || 0) + DOMINO_TALL * 0.75;
    rotationArrowSprite.position.set(data.mesh.position.x, visualYPosition + 0.5, data.mesh.position.z);
    rotationArrowSprite.rotation.x = -Math.PI / 2; // Match previous version
    rotationArrowSprite.visible = true;
    scene.add(rotationArrowSprite);

    const initialBodyQuaternion = data.body.quaternion.clone();
    let totalRotationOffset = 0;
    let lastMousePosition = { x: 0, y: 0 }; // Initialize to avoid NaN

    function updateRotation(event) {
        if (!rotationMode || !selectedDominoData || selectedDominoData !== data) {
            document.removeEventListener('mousemove', updateRotation);
            if (rotationArrowSprite) {
                scene.remove(rotationArrowSprite);
                rotationArrowSprite.visible = false;
                // Add disposal if needed
                if (rotationArrowSprite.material.map) rotationArrowSprite.material.map.dispose();
                rotationArrowSprite.material.dispose();
                rotationArrowSprite.geometry.dispose();
            }
            return;
        }
        const deltaX = event.clientX - lastMousePosition.x;
        const rotationSpeed = 0.01;
        totalRotationOffset += deltaX * rotationSpeed;
        const maxAngle = Math.PI / 4; // Add angle constraint
        totalRotationOffset = Math.max(-maxAngle, Math.min(maxAngle, totalRotationOffset));

        const rotationQuaternion = new CANNON.Quaternion();
        rotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), totalRotationOffset);
        data.body.quaternion.copy(initialBodyQuaternion).mult(rotationQuaternion, data.body.quaternion);
        data.body.quaternion.normalize();

        data.mesh.quaternion.copy(data.body.quaternion);

        const currentBaseY = data.mesh.position.y + (data.mesh.userData.modelPivotToBottomY || 0);
        rotationArrowSprite.position.set(data.mesh.position.x, currentBaseY + DOMINO_TALL * 0.75 + 0.5, data.mesh.position.z);

        if (data.userData && data.userData.collisionHelper) {
            data.userData.collisionHelper.quaternion.copy(data.body.quaternion);
        }
        lastMousePosition = { x: event.clientX, y: event.clientY };
    }
    document.addEventListener('mousemove', updateRotation, false);
    rotationMode = true;
}

        function createSimulationArrowHelper(origin, directionVec, color, userDataDirection) {
            const length = 1.0; const headLength = 0.3; const headWidth = 0.2;
            const arrowHelper = new THREE.ArrowHelper(directionVec.clone().normalize(), origin, length, color, headLength, headWidth);
            arrowHelper.userData.isSimulationArrow = true;
            arrowHelper.userData.direction = userDataDirection; 
            arrowHelper.userData.originalColor = color;
            arrowHelper.userData.isPulsing = false;
            arrowHelper.userData.pulseTime = 0;
            arrowHelper.line.userData = { isSimulationArrowPart: true, parentArrow: arrowHelper };
            arrowHelper.cone.userData = { isSimulationArrowPart: true, parentArrow: arrowHelper };
            return arrowHelper;
        }

        function clearSimulationArrows() {
            const arrowsToRemove = scene.children.filter(child => child.userData && child.userData.isSimulationArrow);
            arrowsToRemove.forEach(arrow => {
                if (hoveredSimulationArrow === arrow) {
                    if (arrow.cone) arrow.cone.scale.set(1, 1, 1); 
                    hoveredSimulationArrow = null;
                }
                scene.remove(arrow); 
            });
            if (isSelectingSimulationDirection) {
                isSelectingSimulationDirection = false;
                simulationTargetData = null;
                document.body.style.cursor = 'default';
                controls.enabled = true; 
            }
        }

        // --- Context Menu Logic ---
        function showContextMenu(event, targetData) {
            hideContextMenu(); 
            selectDomino(targetData); 
            contextMenu.style.left = `${event.clientX}px`;
            contextMenu.style.top = `${event.clientY}px`;
            contextMenu.style.display = 'block';

            document.getElementById('context-move').onclick = () => {
                translationMode = true; rotationMode = false; isMoving = true; isRotating = false;
                lastMousePosition = { x: event.clientX, y: event.clientY };
                showNotification("Move: Domino follows mouse. Left-click to fix. Esc to cancel.");
                document.body.style.cursor = 'move'; controls.enabled = false; 
                hideContextMenu();
            };

document.getElementById('context-rotate').onclick = () => {
    console.log("Rotate option clicked");
    rotationMode = true; translationMode = false; isRotating = true; isMoving = false;
    lastMousePosition = { x: event.clientX, y: event.clientY };
    showNotification("Rotate: Drag mouse horizontally. Left-click to fix. Esc to cancel.");
    document.body.style.cursor = 'ew-resize'; controls.enabled = false;
    animateRotation(targetData);
    hideContextMenu();
};

            document.getElementById('context-start-simulation').onclick = () => {
                if (!targetData || !targetData.body) return;
                hideContextMenu();
                clearSimulationArrows(); 

                const bodyPos = targetData.body.position; 
                const bodyQuat = targetData.body.quaternion; 

                const localX = new THREE.Vector3(1, 0, 0); 
                const worldNormalPositiveX = new THREE.Vector3().copy(localX).applyQuaternion(
                    new THREE.Quaternion(bodyQuat.x, bodyQuat.y, bodyQuat.z, bodyQuat.w)
                );
                const worldNormalNegativeX = worldNormalPositiveX.clone().negate();
                const faceOffsetDistance = DOMINO_WIDE / 2 + 0.1; 

                const arrowOriginPositiveX = new THREE.Vector3(bodyPos.x, bodyPos.y, bodyPos.z)
                    .add(worldNormalPositiveX.clone().multiplyScalar(faceOffsetDistance));
                const arrowOriginNegativeX = new THREE.Vector3(bodyPos.x, bodyPos.y, bodyPos.z)
                    .add(worldNormalNegativeX.clone().multiplyScalar(faceOffsetDistance));
                
                const positiveXArrow = createSimulationArrowHelper(arrowOriginPositiveX, worldNormalPositiveX, ARROW_COLOR_DEFAULT, 'positiveX');
                scene.add(positiveXArrow);
                const negativeXArrow = createSimulationArrowHelper(arrowOriginNegativeX, worldNormalNegativeX, ARROW_COLOR_DEFAULT, 'negativeX');
                scene.add(negativeXArrow);

                showNotification("Click a red arrow to apply impulse in that direction.");
                isSelectingSimulationDirection = true;
                simulationTargetData = targetData; 
                controls.enabled = false; 
            };

            document.getElementById('context-delete').onclick = () => {
                deleteSelectedDomino();
                hideContextMenu();
            };
        }

        function deleteSelectedDomino() {
            if (!selectedDominoData) return;
            const dataToDelete = selectedDominoData;
            selectDomino(null); 

            scene.remove(dataToDelete.mesh);
            if (world.bodies.includes(dataToDelete.body)) {
                world.removeBody(dataToDelete.body);
            }

            if (dataToDelete.userData && dataToDelete.userData.collisionHelper) {
                scene.remove(dataToDelete.userData.collisionHelper);
                if (dataToDelete.userData.collisionHelperUpdater) {
                    world.removeEventListener('postStep', dataToDelete.userData.collisionHelperUpdater);
                }
            }

            const meshIndex = dominoes.indexOf(dataToDelete.mesh);
            if (meshIndex > -1) dominoes.splice(meshIndex, 1);
            const dataIndex = dominoData.indexOf(dataToDelete);
            if (dataIndex > -1) dominoData.splice(dataIndex, 1);

            dataToDelete.mesh.traverse((child) => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (child.material.map) child.material.map.dispose();
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
            });
            showNotification('Domino Deleted');
        }

        function hideContextMenu() {
            contextMenu.style.display = 'none';
            document.getElementById('context-move').onclick = null;
            document.getElementById('context-rotate').onclick = null;
            document.getElementById('context-start-simulation').onclick = null;
            document.getElementById('context-delete').onclick = null;
        }

        // --- Simulation Control ---
        function startSimulation(impulseData = null) { 
            if (dominoData.length === 0 && !impulseData) {
                showNotification("Add some dominoes first!");
                return;
            }
            if (isSimulating) return;

            clearSimulationArrows(); 
            isSimulating = true;
            world.allowSleep = false; 

            dominoData.forEach(data => data.body.wakeUp()); 

            if (impulseData && impulseData.targetBody) {
                impulseData.targetBody.wakeUp();
                impulseData.targetBody.applyImpulse(impulseData.worldImpulse, impulseData.worldApplicationPoint);
                showNotification("Simulation started with selected impulse!");
            } else if (selectedDominoData && selectedDominoData.body) {
                selectedDominoData.body.wakeUp();
                const localImpulse = new CANNON.Vec3(IMPULSE_MAGNITUDE, 0, 0); 
                const appPointLocal = new CANNON.Vec3(
                    -DOMINO_WIDE / 2, 
                    DOMINO_TALL * 0.45,  
                    0                   
                ); 
                const worldImpulse = selectedDominoData.body.quaternion.vmult(localImpulse);
                const worldApplicationPoint = selectedDominoData.body.quaternion.vmult(appPointLocal);
                worldApplicationPoint.vadd(selectedDominoData.body.position, worldApplicationPoint); 
                selectedDominoData.body.applyImpulse(worldImpulse, worldApplicationPoint);
                showNotification("Simulation started with default impulse on selected domino!");
            } else if (dominoData.length > 0) {
                showNotification("Select a domino or use context menu to start simulation with impulse.", true);
                isSimulating = false; 
                world.allowSleep = true;
                return;
            }

            translationMode = false; rotationMode = false; isAddingDomino = false;
            isMoving = false; isRotating = false;
            document.body.style.cursor = 'default';
            if (previewDomino) previewDomino.visible = false;
            if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup = null; }
            if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup = null; }
        }

        function resetSimulation() {
            isSimulating = false;
            world.allowSleep = true; 
            clearSimulationArrows();
            hideContextMenu();

            if (translationMode || rotationMode || isAddingDomino) {
                translationMode = false; rotationMode = false; isAddingDomino = false;
                isMoving = false; isRotating = false;
                document.body.style.cursor = 'default';
                if (previewDomino) previewDomino.visible = false;
                if (previewBatchGroup) {
                    scene.remove(previewBatchGroup); previewBatchGroup = null; previewBatchCount = 0;
                }
                if (previewCircleGroup) { 
                    scene.remove(previewCircleGroup); previewCircleGroup = null; previewCircleCount = 0;
                }
                if (rotationArrowSprite) scene.remove(rotationArrowSprite);
            }
            controls.enabled = true; 

            dominoData.forEach(data => {
                const basePos = data.initialBasePosition; 
                const modelPivotOffsetY = data.mesh.userData.modelPivotToBottomY || 0;

                data.body.position.set(basePos.x, basePos.y + DOMINO_TALL / 2, basePos.z); 
                data.body.quaternion.copy(data.initialQuat);
                data.body.velocity.set(0, 0, 0);
                data.body.angularVelocity.set(0, 0, 0);
                data.body.sleep(); 

                data.mesh.position.set(basePos.x, basePos.y - modelPivotOffsetY, basePos.z);
                data.mesh.quaternion.copy(data.initialQuat);
                setEmissive(data, 0x000000); 

                if (data.userData && data.userData.collisionHelper) {
                    data.userData.collisionHelper.position.copy(data.body.position);
                    data.userData.collisionHelper.quaternion.copy(data.body.quaternion);
                }
            });

            selectDomino(null); 
            hoveredDominoData = null; 

            if (hoveredSimulationArrow) {
                setArrowColor(hoveredSimulationArrow, hoveredSimulationArrow.userData.originalColor);
                if (hoveredSimulationArrow.cone) hoveredSimulationArrow.cone.scale.set(1, 1, 1);
                hoveredSimulationArrow.userData.isPulsing = false;
                hoveredSimulationArrow = null;
            }
            showNotification('Simulation Reset');
        }

        function clearCanvas() {
            resetSimulation(); 
            dominoData.forEach(data => {
                scene.remove(data.mesh);
                if (world.bodies.includes(data.body)) world.removeBody(data.body);
                if (data.userData && data.userData.collisionHelper) {
                    scene.remove(data.userData.collisionHelper);
                     if (data.userData.collisionHelperUpdater) { 
                        world.removeEventListener('postStep', data.userData.collisionHelperUpdater);
                    }
                }
                data.mesh.traverse((child) => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                             if (child.material.map) child.material.map.dispose();
                             if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    }
                });
            });
            dominoes = []; 
            dominoData = [];
			selectDomino(null); 
            hoveredDominoData = null; 
            showNotification('Canvas Cleared');
        }

        // --- UI Helpers ---
        function showNotification(message, isError = false) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.backgroundColor = isError ? 'rgba(200, 0, 0, 0.8)' : 'rgba(0, 0, 0, 0.7)';
            notification.style.opacity = '1';
            setTimeout(() => { notification.style.opacity = '0'; }, isError ? 3000 : 2000);
        }

        function toggleOrbitControls() {
            controls.enabled = !controls.enabled;
            document.getElementById('toggle-orbit').textContent = controls.enabled ? 'Lock Camera' : 'Unlock Camera';
            if (controls.enabled && (translationMode || rotationMode || isAddingDomino || isSelectingSimulationDirection)) {
                translationMode = false; rotationMode = false; isAddingDomino = false; isSelectingSimulationDirection = false;
                isMoving = false; isRotating = false;
                document.body.style.cursor = 'default';
                if (previewDomino) previewDomino.visible = false;
                if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup = null; previewBatchCount = 0; }
                if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup = null; previewCircleCount = 0; }
                clearSimulationArrows();
                if (rotationArrowSprite) scene.remove(rotationArrowSprite);
            }
        }

        function onStartDragDominoTemplate(event) {
            if (event.button !== 0) return; 
            if (isSimulating || !dominoModel) return;
            
            if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewBatchGroup = null; previewBatchCount = 0; }
            if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewCircleGroup = null; previewCircleCount = 0; }

            isAddingDomino = true;
            if (!previewDomino) createPreviewDomino(); 
            else previewDomino.visible = true; // Ensure it's visible if already created
            
            if (previewDomino) { // Should always exist now
                previewDomino.rotation.y = 0; 
            }
            controls.enabled = false; 
            document.body.style.cursor = 'grabbing';
            hideContextMenu();
        }

        function onAddBatch() { // For Batch Line
            if (isSimulating || !dominoModel) return;
            const numDominosStr = prompt("Enter number of dominos for the batch line (2-20):", "5");
            if (numDominosStr === null) return; 
            const n = parseInt(numDominosStr);
            if (isNaN(n) || n < 2 || n > 20) {
                showNotification("Invalid number. Please enter a value between 2 and 20.", true);
                return;
            }

            if (previewDomino) { previewDomino.visible = false; }
             previewDomino = null; 
            if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewCircleGroup = null; previewCircleCount = 0; }
            
            createPreviewBatch(n); 
            isAddingDomino = true; 
            controls.enabled = false;
            document.body.style.cursor = 'grabbing';
            hideContextMenu();
        }
        
        function onAddBatchCircle() { 
            if (isSimulating || !dominoModel) return;
            const numDominosStr = prompt("Enter number of pieces for the circle (20-40):", "30");
            if (numDominosStr === null) return; 
            const n = parseInt(numDominosStr);
            if (isNaN(n) || n < 20 || n > 40) {
                showNotification("Invalid number. Please enter a value between 20 and 40.", true);
                return;
            }

            if (previewDomino) { previewDomino.visible = false; }
            previewDomino = null;
            if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewBatchGroup = null; previewBatchCount = 0; }

            createPreviewCircle(n);
            isAddingDomino = true;
            controls.enabled = false;
            document.body.style.cursor = 'grabbing';
            hideContextMenu();
        }

        function createPreviewBatch(n) { // For Line Batch
            if (previewBatchGroup) { 
                scene.remove(previewBatchGroup);
                previewBatchGroup.traverse(child => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) child.material.forEach(m=>m.dispose());
                            else child.material.dispose();
                        }
                    }
                });
            }
            previewBatchGroup = new THREE.Group();
            const spacing = 1.0; 
            const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;

            for (let i = 0; i < n; i++) {
                const singlePreview = dominoModel.clone();
                singlePreview.traverse((child) => {
                    if (child.isMesh) {
                        child.material = child.material.clone();
                        child.material.transparent = true;
                        child.material.opacity = 0.6;
                        child.userData.isDomino = true;
                    }
                });
                const zPos = (i - (n - 1) / 2) * spacing; 
                singlePreview.position.set(0, 0 - modelPivotCorrection, zPos); 
                singlePreview.rotation.y = Math.PI / 2; 
                previewBatchGroup.add(singlePreview);
            }
            scene.add(previewBatchGroup);
            previewBatchCount = n;
        }

function createPreviewCircle(numberOfPieces) { 
    if (previewCircleGroup) {
        scene.remove(previewCircleGroup);
        previewCircleGroup.traverse(child => {
            if (child.isMesh) {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                    else child.material.dispose();
                }
            }
        });
    }
    previewCircleGroup = new THREE.Group();
    const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;
    const N = numberOfPieces;
    
    // Calculate radius based on desired circle size
    // Using the domino width for better spacing around the circle
    const radius = (DOMINO_WIDE * N) / (2 * Math.PI);
    const anglePerSegment = (2 * Math.PI) / N;
    
    for (let i = 0; i < N; i++) {
        const angle = i * anglePerSegment; // Angle of the domino's position on the circle
        const posX = radius * Math.cos(angle); 
        const posZ = radius * Math.sin(angle);
        const singlePreview = dominoModel.clone();
        singlePreview.traverse((child) => {
            if (child.isMesh) {
                child.material = child.material.clone();
                child.material.transparent = true;
                child.material.opacity = 0.6;
                child.userData.isDomino = true;
            }
        });
        
        // Position domino's visual bottom at (posX, 0, posZ) relative to group center
        singlePreview.position.set(posX, 0 - modelPivotCorrection, posZ);
        
        // Rotate domino so its wide face is perpendicular to the radius
        // This makes them look like hour markers on a clock
        //singlePreview.rotation.y = angle; // Point the domino's face toward the center
        singlePreview.rotation.y = (Math.PI/2) - angle;
        previewCircleGroup.add(singlePreview);
    }
    scene.add(previewCircleGroup);
    previewCircleCount = numberOfPieces;
}

        // --- Event Listeners Setup ---
        function initEventListeners() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                hideContextMenu();
            }, false);

            const canvasContainer = document.getElementById('canvas-container');
            canvasContainer.addEventListener('mousedown', onMouseDown, false);
            canvasContainer.addEventListener('mousemove', onMouseMove, false);
            canvasContainer.addEventListener('mouseup', onMouseUp, false);
            canvasContainer.addEventListener('contextmenu', onContextMenu, false); 

            window.addEventListener('keydown', onKeyDown, false);
            window.addEventListener('mousedown', (event) => {
                if (contextMenu.style.display === 'block' && !contextMenu.contains(event.target)) {
                    hideContextMenu();
                }
            }, true); 

            document.getElementById('domino-template').addEventListener('mousedown', onStartDragDominoTemplate);
            document.getElementById('add-batch-button').addEventListener('click', onAddBatch);
            document.getElementById('add-batch-circle-button').addEventListener('click', onAddBatchCircle); 
			document.getElementById('add-batch-spiral-button').addEventListener('click', onAddBatchSpiral);
            document.getElementById('reset-button').addEventListener('click', resetSimulation);
            document.getElementById('clear-button').addEventListener('click', clearCanvas);
			document.getElementById('save-button').addEventListener('click', saveSceneToXML);
        document.getElementById('load-button').addEventListener('click', () => {
            const fileInput = document.getElementById('file-input');
            if (fileInput) {
                showNotification("Triggering file input...");
                fileInput.click(); // Programmatically trigger the file input
            } else {
                showNotification("Error: File input element not found!", true);
            }
        });

        // Ensure the file input change event is properly bound (already in place, but verifying)
        const fileInput = document.getElementById('file-input');
        if (fileInput) {
            fileInput.addEventListener('change', loadSceneFromXML);
        } else {
            console.error("File input element (#file-input) not found in DOM.");
            showNotification("Error: File input not initialized!", true);
        }
            document.getElementById('toggle-grid').addEventListener('change', (event) => { grid.visible = event.target.checked; });
            document.getElementById('toggle-orbit').addEventListener('click', toggleOrbitControls);
            document.getElementById('reset-camera').addEventListener('click', () => {
                controls.reset(); 
                camera.position.set(0, 20, 30); 
                camera.lookAt(0, 0, 0);
                controls.update(); 
                if (!controls.enabled) {
                    controls.enabled = true;
                    document.getElementById('toggle-orbit').textContent = 'Lock Camera';
                }
            });
            document.getElementById('help-button').addEventListener('click', () => { document.getElementById('modal-overlay').style.display = 'flex'; });
            document.getElementById('close-modal').addEventListener('click', () => { document.getElementById('modal-overlay').style.display = 'none'; });
            document.getElementById('modal-overlay').addEventListener('click', (event) => {
                if (event.target === document.getElementById('modal-overlay')) {
                    document.getElementById('modal-overlay').style.display = 'none';
                }
            });
        }

        function setArrowColor(arrow, color) {
            if (arrow && arrow.line && arrow.cone) {
                arrow.line.material.color.setHex(color);
                arrow.cone.material.color.setHex(color);
            }
        }

        function onMouseDown(event) {
            if (event.button !== 0) return; 
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            if (isSelectingSimulationDirection && simulationTargetData) {
                const simulationArrows = scene.children.filter(c => c.userData && c.userData.isSimulationArrow);
                const intersectsArrows = raycaster.intersectObjects(simulationArrows, true); 

                if (intersectsArrows.length > 0) {
                    let clickedArrowPart = intersectsArrows[0].object;
                    let actualArrow = clickedArrowPart.userData.parentArrow || (clickedArrowPart.userData.isSimulationArrow ? clickedArrowPart : null);
                    
                    if (actualArrow && actualArrow.userData.direction) {
                        const direction = actualArrow.userData.direction; 
                        let localImpulse = new CANNON.Vec3();
                        if (direction === 'positiveX') localImpulse.set(IMPULSE_MAGNITUDE, 0, 0); 
                        else localImpulse.set(-IMPULSE_MAGNITUDE, 0, 0); 
                        
                        const appPointLocal = new CANNON.Vec3(
                            direction === 'positiveX' ? -DOMINO_WIDE / 2 : DOMINO_WIDE / 2, 
                            DOMINO_TALL * 0.4, 
                            0
                        );
                        
                        const worldImpulse = simulationTargetData.body.quaternion.vmult(localImpulse);
                        const worldApplicationPoint = simulationTargetData.body.quaternion.vmult(appPointLocal);
                        worldApplicationPoint.vadd(simulationTargetData.body.position, worldApplicationPoint);
                        
                        startSimulation({
                            targetBody: simulationTargetData.body,
                            worldImpulse: worldImpulse,
                            worldApplicationPoint: worldApplicationPoint
                        });
                        return; 
                    }
                } else {
                    clearSimulationArrows();
                    showNotification("Simulation direction selection canceled.");
                }
                return; 
            }

            if (isMoving && translationMode && selectedDominoData) { 
                isMoving = false; translationMode = false;
                document.body.style.cursor = 'default'; controls.enabled = true;
                const modelPivotOffsetY = selectedDominoData.mesh.userData.modelPivotToBottomY || 0;
                const currentBasePosition = snapToGrid(selectedDominoData.mesh.position); 
                currentBasePosition.y = 0; 

                const collision = checkDominoCollision(currentBasePosition, selectedDominoData);
                setEmissive(selectedDominoData, collision ? COLLISION_COLOR : SELECT_COLOR, 1.5);
                if (collision) {
                    showNotification("Warning: Domino placement overlaps! Reverting.", true);
                    const oldBase = selectedDominoData.initialBasePosition;
                    selectedDominoData.mesh.position.set(oldBase.x, oldBase.y - modelPivotOffsetY, oldBase.z);
                    selectedDominoData.body.position.set(oldBase.x, oldBase.y + DOMINO_TALL / 2, oldBase.z);
                } else {
                    showNotification("Position fixed.");
                    selectedDominoData.initialBasePosition.copy(currentBasePosition); 
                    selectedDominoData.body.position.set(currentBasePosition.x, currentBasePosition.y + DOMINO_TALL / 2, currentBasePosition.z);
                }
                if (selectedDominoData.userData && selectedDominoData.userData.collisionHelper) {
                    selectedDominoData.userData.collisionHelper.position.copy(selectedDominoData.body.position);
                }
                return;
            }
            if (isRotating && rotationMode && selectedDominoData) { 
                isRotating = false; rotationMode = false;
                document.body.style.cursor = 'default'; controls.enabled = true;
                selectedDominoData.initialQuat.copy(selectedDominoData.body.quaternion); 
                setEmissive(selectedDominoData, SELECT_COLOR, 1.5);
                showNotification("Rotation fixed.");
                if (rotationArrowSprite) {
                    scene.remove(rotationArrowSprite);
                    rotationArrowSprite.visible = false;
                }
                return;
            }

            const intersectsDominoes = raycaster.intersectObjects(dominoes, true);
            if (intersectsDominoes.length > 0 && !isSimulating) {
                const clickedDominoData = findDominoDataFromObject(intersectsDominoes[0].object);
                if (clickedDominoData) {
                    selectDomino(clickedDominoData);
                } else {
                     if (!isSelectingSimulationDirection) selectDomino(null); 
                }
            } else {
                 if (!isSelectingSimulationDirection) selectDomino(null); 
            }
        }

        function onMouseMove(event) {
            if (!dominoModel) return;

            const currentMouse = new THREE.Vector2(
                ((event.clientX - renderer.domElement.getBoundingClientRect().left) / renderer.domElement.width) * 2 - 1,
                -((event.clientY - renderer.domElement.getBoundingClientRect().top) / renderer.domElement.height) * 2 + 1
            );
            raycaster.setFromCamera(currentMouse, camera);
            const worldPos = mouseToWorld(event);
            const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;

            if (isAddingDomino && worldPos) {
                const snappedBasePos = snapToGrid(worldPos);

                if (previewDomino) {
                    previewDomino.position.set(snappedBasePos.x, snappedBasePos.y - modelPivotCorrection, snappedBasePos.z);
                    const collision = checkDominoCollision(snappedBasePos);
                    previewDomino.traverse((child) => {
                        if (child.isMesh && child.material) {
                            child.material.color.setHex(collision ? 0xff8888 : 0xffffff);
                            child.material.opacity = collision ? 0.4 : 0.6;
                        }
                    });
                } else if (previewBatchGroup) {
                    previewBatchGroup.position.copy(snappedBasePos);
                    let collisionInBatch = false;
                    const tempWorldPosCheck = new THREE.Vector3();
                    for (let i = 0; i < previewBatchCount; i++) {
                        previewBatchGroup.children[i].getWorldPosition(tempWorldPosCheck);
                        const dominoBasePosInWorld = snapToGrid(tempWorldPosCheck);
                        if (checkDominoCollision(dominoBasePosInWorld)) {
                            collisionInBatch = true; break;
                        }
                    }
                    previewBatchGroup.traverse((child) => {
                        if (child.isMesh && child.material && child.userData.isDomino) {
                            child.material.color.setHex(collisionInBatch ? 0xff8888 : 0xffffff);
                            child.material.opacity = collisionInBatch ? 0.4 : 0.6;
                        }
                    });
                } else if (previewCircleGroup) {
                    previewCircleGroup.position.copy(snappedBasePos);
                    let collisionInCircle = false;
                    const tempWorldPosCheck = new THREE.Vector3();
                    for (const childPreview of previewCircleGroup.children) {
                        childPreview.getWorldPosition(tempWorldPosCheck);
                        const childSnappedBasePos = snapToGrid(tempWorldPosCheck);
                        if (checkDominoCollision(childSnappedBasePos)) {
                            collisionInCircle = true; break;
                        }
                    }
                    previewCircleGroup.traverse((child) => {
                        if (child.isMesh && child.material && child.userData.isDomino) {
                            child.material.color.setHex(collisionInCircle ? 0xff8888 : 0xffffff);
                            child.material.opacity = collisionInCircle ? 0.4 : 0.6;
                        }
                    });
                } else if (previewSpiralGroup) {
                    previewSpiralGroup.position.copy(snappedBasePos);
                    let collisionInSpiral = false;
                    const tempWorldPosCheck = new THREE.Vector3();
                    for (const childPreview of previewSpiralGroup.children) {
                        childPreview.getWorldPosition(tempWorldPosCheck);
                        const childSnappedBasePos = snapToGrid(tempWorldPosCheck);
                        if (checkDominoCollision(childSnappedBasePos)) {
                            collisionInSpiral = true; break;
                        }
                    }
                    previewSpiralGroup.traverse((child) => {
                        if (child.isMesh && child.material && child.userData.isDomino) {
                            child.material.color.setHex(collisionInSpiral ? 0xff8888 : 0xffffff);
                            child.material.opacity = collisionInSpiral ? 0.4 : 0.6;
                        }
                    });
                }
            }
            else if (selectedDominoData && isMoving && translationMode && worldPos) {
                const snappedBasePos = snapToGrid(worldPos); 
                selectedDominoData.mesh.position.set(snappedBasePos.x, snappedBasePos.y - modelPivotCorrection, snappedBasePos.z);
                selectedDominoData.body.position.set(snappedBasePos.x, snappedBasePos.y + DOMINO_TALL / 2, snappedBasePos.z);
                selectedDominoData.body.wakeUp(); 

                const collision = checkDominoCollision(snappedBasePos, selectedDominoData);
                setEmissive(selectedDominoData, collision ? COLLISION_COLOR : SELECT_COLOR, 1.5);

                if (selectedDominoData.userData && selectedDominoData.userData.collisionHelper) {
                    selectedDominoData.userData.collisionHelper.position.copy(selectedDominoData.body.position);
                }
            } 
            else if (isSelectingSimulationDirection) {
                const simulationArrows = scene.children.filter(c => c.userData && c.userData.isSimulationArrow);
                let intersectedArrowThisFrame = null;
                if (simulationArrows.length > 0) {
                    const intersects = raycaster.intersectObjects(simulationArrows, true);
                    if (intersects.length > 0) {
                        let obj = intersects[0].object;
                        intersectedArrowThisFrame = obj.userData.parentArrow || (obj.userData.isSimulationArrow ? obj : null);
                    }
                }

                if (hoveredSimulationArrow && hoveredSimulationArrow !== intersectedArrowThisFrame) {
                    setArrowColor(hoveredSimulationArrow, hoveredSimulationArrow.userData.originalColor);
                    hoveredSimulationArrow.userData.isPulsing = false;
                    if (hoveredSimulationArrow.cone) hoveredSimulationArrow.cone.scale.set(1, 1, 1); 
                }
                if (intersectedArrowThisFrame) {
                    setArrowColor(intersectedArrowThisFrame, ARROW_COLOR_HOVER);
                    intersectedArrowThisFrame.userData.isPulsing = true; 
                    document.body.style.cursor = 'pointer';
                } else {
                    document.body.style.cursor = 'default';
                }
                hoveredSimulationArrow = intersectedArrowThisFrame;
            } 
            else if (!isSimulating) {
                updateHoverEffect(event);
            }
            lastMousePosition = { x: event.clientX, y: event.clientY };
        }

		function onMouseUp(event) {
            if (event.button !== 0 || !dominoModel) return;

            if (isAddingDomino) {
                const worldPos = mouseToWorld(event);
                if (worldPos) {
                    const snappedFinalPos = snapToGrid(worldPos);

                    if (previewDomino) {
                        const collision = checkDominoCollision(snappedFinalPos);
                        if (!collision) {
                            createDomino(snappedFinalPos, previewDomino.rotation.y);
                        } else {
                            showNotification("Placement overlaps existing domino!", true);
                        }
                        previewDomino.visible = false;
                    } else if (previewBatchGroup) {
                        let collisionInBatch = false;
                        const finalPositionsAndRotations = [];
                        const tempWorldPosPlace = new THREE.Vector3();

                        for (let i = 0; i < previewBatchCount; i++) {
                            const childPreview = previewBatchGroup.children[i];
                            childPreview.getWorldPosition(tempWorldPosPlace);
                            const childSnappedBasePos = snapToGrid(tempWorldPosPlace);
                            if (checkDominoCollision(childSnappedBasePos)) {
                                collisionInBatch = true; break;
                            }
                            finalPositionsAndRotations.push({
                                position: childSnappedBasePos,
                                rotationY: childPreview.rotation.y
                            });
                        }

                        if (!collisionInBatch) {
                            finalPositionsAndRotations.forEach(pr => createDomino(pr.position, pr.rotationY));
                        } else {
                            showNotification("Batch line placement overlaps existing dominoes!", true);
                        }
                        scene.remove(previewBatchGroup);
                        previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}});
                        previewBatchGroup = null;
                        previewBatchCount = 0;
                    } else if (previewCircleGroup) {
                        const circleCenterPos = snappedFinalPos;
                        let collisionInCircle = false;
                        const finalDominosToCreate = [];

                        for (const childPreview of previewCircleGroup.children) {
                            const targetDominoBasePosition = new THREE.Vector3(
                                circleCenterPos.x + childPreview.position.x,
                                0,
                                circleCenterPos.z + childPreview.position.z
                            );
                            if (checkDominoCollision(targetDominoBasePosition)) {
                                collisionInCircle = true; break;
                            }
                            finalDominosToCreate.push({
                                position: targetDominoBasePosition,
                                rotationY: childPreview.rotation.y
                            });
                        }

                        if (!collisionInCircle) {
                            finalDominosToCreate.forEach(d => createDomino(d.position, d.rotationY));
                        } else {
                            showNotification("Batch circle placement overlaps existing dominoes!", true);
                        }
                        scene.remove(previewCircleGroup);
                        previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}});
                        previewCircleGroup = null;
                        previewCircleCount = 0;
                    } else if (previewSpiralGroup) {
                        const spiralCenterPos = snappedFinalPos;
                        let collisionInSpiral = false;
                        const finalDominosToCreate = [];

                        for (const childPreview of previewSpiralGroup.children) {
                            const targetDominoBasePosition = new THREE.Vector3(
                                spiralCenterPos.x + childPreview.position.x,
                                0,
                                spiralCenterPos.z + childPreview.position.z
                            );
                            if (checkDominoCollision(targetDominoBasePosition)) {
                                collisionInSpiral = true; break;
                            }
                            finalDominosToCreate.push({
                                position: targetDominoBasePosition,
                                rotationY: childPreview.rotation.y
                            });
                        }

                        if (!collisionInSpiral) {
                            finalDominosToCreate.forEach(d => createDomino(d.position, d.rotationY));
                        } else {
                            showNotification("Batch spiral placement overlaps existing dominoes!", true);
                        }
                        scene.remove(previewSpiralGroup);
                        previewSpiralGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}});
                        previewSpiralGroup = null;
                        previewSpiralCount = 0;
                    }
                }
                isAddingDomino = false;
                document.body.style.cursor = 'default';
                controls.enabled = true;
            }
        }

        function onContextMenu(event) {
            event.preventDefault(); 
			console.log("Context menu triggered");
            if (isSimulating || isAddingDomino || isMoving || isRotating) return; 

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(dominoes, true);
            if (intersects.length > 0) {
                const targetData = findDominoDataFromObject(intersects[0].object);
                if (targetData) {
                    showContextMenu(event, targetData); 
                }
            } else {
                hideContextMenu(); 
                selectDomino(null); 
            }
        }

        function onKeyDown(event) {
            const key = event.key.toLowerCase();

            if (key === 'escape') {
                hideContextMenu();
                let modeCancelled = false;
                if (isAddingDomino) {
                    if (previewDomino) previewDomino.visible = false;
                    if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup = null; previewBatchCount = 0; }
                    if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup = null; previewCircleCount = 0; }
                    isAddingDomino = false;
                    modeCancelled = true;
                } else if (translationMode || rotationMode) { 
                    if (selectedDominoData) {
                        const basePos = selectedDominoData.initialBasePosition;
                        const modelPivotOffsetY = selectedDominoData.mesh.userData.modelPivotToBottomY || 0;
                        selectedDominoData.mesh.position.set(basePos.x, basePos.y - modelPivotOffsetY, basePos.z);
                        selectedDominoData.mesh.quaternion.copy(selectedDominoData.initialQuat);
                        selectedDominoData.body.position.set(basePos.x, basePos.y + DOMINO_TALL / 2, basePos.z);
                        selectedDominoData.body.quaternion.copy(selectedDominoData.initialQuat);
                        setEmissive(selectedDominoData, SELECT_COLOR, 1.5); 
                        if (rotationArrowSprite) { scene.remove(rotationArrowSprite); rotationArrowSprite.visible = false; }
                        if (selectedDominoData.userData && selectedDominoData.userData.collisionHelper) {
                            selectedDominoData.userData.collisionHelper.position.copy(selectedDominoData.body.position);
                            selectedDominoData.userData.collisionHelper.quaternion.copy(selectedDominoData.body.quaternion);
                        }
                    }
                    translationMode = false; rotationMode = false;
                    isMoving = false; isRotating = false;
                    modeCancelled = true;
                } else if (isSelectingSimulationDirection) {
                    clearSimulationArrows();
                    showNotification("Simulation direction selection canceled.");
                    return; 
                }

                if (modeCancelled) {
                    document.body.style.cursor = 'default';
                    controls.enabled = true;
                    showNotification("Action canceled.");
                } else if (!isSimulating) { 
                    selectDomino(null);
                }
                return; 
            }

            if (selectedDominoData && !translationMode && !rotationMode && !isSelectingSimulationDirection && !isSimulating) {
                switch (key) {
                    case 'delete': case 'backspace': deleteSelectedDomino(); break;
                    case 't': 
                        document.getElementById('context-move').onclick = () => { 
                            translationMode = true; rotationMode = false; isMoving = true; isRotating = false;
                            lastMousePosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 }; 
                            showNotification("Move: Domino follows mouse. Left-click to fix. Esc to cancel.");
                            document.body.style.cursor = 'move'; controls.enabled = false; hideContextMenu();
                        };
                        document.getElementById('context-move').onclick(); 
                        document.getElementById('context-move').onclick = null; 
                        break;
                    case 'r': 
                         document.getElementById('context-rotate').onclick = () => { 
                            rotationMode = true; translationMode = false; isRotating = true; isMoving = false;
                            lastMousePosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
                            showNotification("Rotate: Drag mouse horizontally. Left-click to fix. Esc to cancel.");
                            document.body.style.cursor = 'ew-resize'; controls.enabled = false;
                            animateRotation(selectedDominoData); hideContextMenu();
                        };
                        document.getElementById('context-rotate').onclick();
                        document.getElementById('context-rotate').onclick = null;
                        break;
                }
            }

            switch (key) {
                case 'g': 
                    if (!translationMode && !rotationMode && !isAddingDomino && !isSimulating) { 
                        const cb = document.getElementById('toggle-grid');
                        cb.checked = !cb.checked;
                        grid.visible = cb.checked;
                    }
                    break;
                case ' ': 
                    if (!isSimulating && !translationMode && !rotationMode && !isAddingDomino && !isSelectingSimulationDirection) {
                        if (dominoData.length > 0) {
                           startSimulation(); 
                        } else {
                            showNotification("Add dominoes before starting simulation.", true);
                        }
                        event.preventDefault(); 
                    }
                    break;
            }
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        const pulseSpeed = 5; 
        const pulseMagnitude = 0.1;
        const fixedTimeStep = 1 / 60; 
        const maxSubSteps = 10;      

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.1); 

            if (isSimulating) {
                world.step(fixedTimeStep, deltaTime, maxSubSteps);
            }

            if (hoveredSimulationArrow && hoveredSimulationArrow.userData.isPulsing) {
                hoveredSimulationArrow.userData.pulseTime += deltaTime * pulseSpeed;
                const scale = 1 + Math.sin(hoveredSimulationArrow.userData.pulseTime) * pulseMagnitude;
                if (hoveredSimulationArrow.cone) hoveredSimulationArrow.cone.scale.set(scale, scale, scale);
            }
            
            dominoData.forEach((data) => {
                const body = data.body;
                const mesh = data.mesh;
                const modelPivotToBottomY_offset = mesh.userData.modelPivotToBottomY || 0;
                mesh.quaternion.copy(body.quaternion);
                const localOffsetToPivot = new THREE.Vector3(0, (-DOMINO_TALL / 2) - modelPivotToBottomY_offset, 0);
                const worldOffsetToPivot = localOffsetToPivot.clone().applyQuaternion(mesh.quaternion); 
                mesh.position.copy(body.position).add(worldOffsetToPivot);
            });

            controls.update(); 
            renderer.render(scene, camera);
        }

        // --- Initialization ---
        console.log("Initializing Domino Simulator...");
        initEventListeners();
        animate(); 
        console.log("Initialization Complete.");
    </script>
</html>
