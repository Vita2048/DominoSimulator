<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domino Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: #333;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: default;
        }
        #toolbar {
            position: absolute; top: 0; left: 0; width: 200px; height: 100%;
            background-color: rgba(255, 255, 255, 0.85); border-right: 1px solid #ccc;
            padding: 20px; box-sizing: border-box; display: flex; flex-direction: column;
            z-index: 10; box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;
        }
        .toolbar-title { font-size: 18px; font-weight: bold; margin-bottom: 20px; text-align: center; }
        .toolbar-section { margin-bottom: 20px; }
        .toolbar-section-title { font-size: 14px; font-weight: bold; margin-bottom: 10px; color: #555; }
        .toolbar-button { display: flex; align-items: center; padding: 8px 12px; margin-bottom: 8px; background-color: #f5f5f5; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        .toolbar-button:hover { background-color: #e0e0e0; }
        .toolbar-button.active { background-color: #d0d0d0; }
        .toolbar-button.start { background-color: #e6ffe6; }
        .toolbar-button.start:hover { background-color: #d6efd6; }
        .toolbar-button.reset { background-color: #fff0e6; }
        .toolbar-button.reset:hover { background-color: #f5e6d6; }
        .toolbar-button.clear { background-color: #ffe6e6; }
        .toolbar-button.clear:hover { background-color: #f5d6d6; }
        .draggable-domino { width: 40px; height: 80px; background-color: #fff; border: 2px solid #333; margin: 10px auto; border-radius: 4px; cursor: grab; display: flex; align-items: center; justify-content: center; }
        .draggable-domino:active { cursor: grabbing; }
        .checkbox-container { display: flex; align-items: center; margin-bottom: 8px; }
        .checkbox-container input { margin-right: 8px; }
        #corner-panel { position: absolute; top: 20px; right: 20px; background-color: rgba(255, 255, 255, 0.8); border-radius: 4px; padding: 10px; display: flex; flex-direction: column; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); z-index: 10; }
        #corner-panel button { margin-bottom: 8px; padding: 8px 12px; background-color: #f5f5f5; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        #corner-panel button:hover { background-color: #e0e0e0; }
        #help-button { width: 24px; height: 24px; background-color: #f0f0f0; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-top: 10px; align-self: center; }
        #modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 100; }
        #help-modal { background-color: white; padding: 20px; border-radius: 8px; max-width: 500px; width: 80%; max-height: 80%; overflow-y: auto; }
        #help-modal h2 { margin-top: 0; }
        #close-modal { float: right; background: none; border: none; font-size: 18px; cursor: pointer; }
        #notification { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7); color: white; padding: 10px 20px; border-radius: 4px; font-size: 14px; opacity: 0; transition: opacity 0.3s; z-index: 30; }
        #custom-context-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            padding: 5px 0;
            z-index: 1000;
            display: none;
            min-width: 120px;
        }
        #custom-context-menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #custom-context-menu li {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
        }
        #custom-context-menu li:hover {
            background-color: #f0f0f0;
        }
        #custom-context-menu li.separator {
            height: 1px;
            background-color: #eee;
            margin: 5px 0;
            padding: 0;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="toolbar">
        <div class="toolbar-title">Domino Simulator</div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Add Domino</div>
            <div class="draggable-domino" id="domino-template">
                <svg width="20" height="40" viewBox="0 0 20 40"><rect x="2" y="2" width="16" height="36" fill="white" stroke="black" stroke-width="1"/><circle cx="10" cy="10" r="2" fill="black"/><circle cx="10" cy="30" r="2" fill="black"/></svg>
            </div>
        </div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Add Batch</div>
            <div class="toolbar-button" id="add-batch-button">
                <div class="toolbar-button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <rect x="4" y="6" width="4" height="12" fill="#333"/>
                        <rect x="10" y="6" width="4" height="12" fill="#333"/>
                        <rect x="16" y="6" width="4" height="12" fill="#333"/>
                    </svg>
                </div>
                <span>Add Batch</span>
            </div>
        </div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Simulation</div>
            <div class="toolbar-button reset" id="reset-button"><div class="toolbar-button-icon"><svg viewBox="0 0 24 24" width="20" height="20"><path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z" fill="#ff9800"/></svg></div><span>Reset Scene</span></div>
            <div class="toolbar-button clear" id="clear-button"><div class="toolbar-button-icon"><svg viewBox="0 0 24 24" width="20" height="20"><path d="M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19M8,9H16V19H8V9M15.5,4L14.5,3H9.5L8.5,4H5V6H19V4H15.5Z" fill="#f44336"/></svg></div><span>Clear Canvas</span></div>
        </div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Display</div>
            <div class="checkbox-container"><input type="checkbox" id="toggle-grid" checked><label for="toggle-grid">Show Grid</label></div>
        </div>
    </div>
    <div id="corner-panel">
        <button id="toggle-orbit">Lock Camera</button> 
        <button id="reset-camera">Reset Camera</button>
        <div id="help-button">?</div>
    </div>
    <div id="custom-context-menu">
        <ul>
            <li id="context-move">Move (T)</li>
            <li id="context-rotate">Rotate (R)</li>
            <li class="separator"></li>
            <li id="context-start-simulation">Start Simulation (Space)</li>
            <li class="separator"></li>
            <li id="context-delete">Delete (Del)</li>
        </ul>
    </div>
    <div id="notification"></div>
    <div id="modal-overlay">
        <div id="help-modal">
            <button id="close-modal">Ã—</button>
            <h2>Domino Simulator Help</h2>
            <h3>Controls</h3>
            <ul>
                <li><strong>Add Domino:</strong> Drag from the toolbar to the canvas (snaps to grid)</li>
                <li><strong>Add Batch:</strong> Click "Add Batch", enter number (2-20), drag to place</li>
                <li><strong>Select:</strong> Left-click on a domino</li>
                <li><strong>Hover:</strong> Mouse over a domino to highlight blue</li>
                <li><strong>Move (T):</strong> Right-click domino -> Move, then left-click & drag</li>
                <li><strong>Rotate (R):</strong> Right-click domino -> Rotate, then left-click & drag horizontally</li>
                <li><strong>Delete (Del):</strong> Right-click domino -> Delete, or press Delete/Backspace</li>
                <li><strong>Start Simulation (Space):</strong> Press Spacebar or use context menu arrows</li>
                <li><strong>Reset:</strong> Click the reset button</li>
                <li><strong>Clear:</strong> Remove all dominoes</li>
                <li><strong>Toggle Grid (G):</strong> Checkbox or press G</li>
                <li><strong>Context Menu:</strong> Right-click on a domino</li>
            </ul>
            <h3>Camera Controls</h3>
            <ul>
                <li><strong>Rotate View:</strong> Left-click and drag on empty space</li>
                <li><strong>Pan:</strong> Right-click and drag or middle mouse drag</li>
                <li><strong>Zoom:</strong> Scroll with mouse wheel</li>
                <li><strong>Lock Camera:</strong> Toggle button in top-right</li>
                <li><strong>Reset Camera:</strong> Button in top-right</li>
            </ul>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // --- Constants ---
        const DOMINO_TALL = 2.01642;
        const DOMINO_WIDE = 1.01067;
        const DOMINO_THICK = 0.258223;
        const PLANE_SIZE = 100;
        const GRID_SIZE = 100;
        const GRID_DIVISIONS = 100;
        const GRID_UNIT_SIZE = 1;
        const MIN_PLACEMENT_DISTANCE = 1;
        const SELECT_COLOR = 0x555555;
        const HOVER_COLOR = 0x0055ff;
        const COLLISION_COLOR = 0xff0000;
        const IMPULSE_MAGNITUDE = 3.5;
        const ARROW_COLOR_DEFAULT = 0xff0000;
        const ARROW_COLOR_HOVER = 0x0077ff;

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xE0E0E0);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 30);
        camera.lookAt(0, 0, 0);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(20, 35, 25);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096;
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 100;
        directionalLight.shadow.camera.left = -PLANE_SIZE / 2;
        directionalLight.shadow.camera.right = PLANE_SIZE / 2;
        directionalLight.shadow.camera.top = PLANE_SIZE / 2;
        directionalLight.shadow.camera.bottom = -PLANE_SIZE / 2;
        directionalLight.shadow.bias = -0.0005;
        scene.add(directionalLight);

        // --- Physics ---
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.solver.iterations = 30;
        world.solver.tolerance = 0.001;
        world.allowSleep = true;
        world.defaultContactMaterial.restitution = 0.0;
        world.defaultContactMaterial.contactEquationStiffness = 1e6;
        world.defaultContactMaterial.contactEquationRelaxation = 3;

        const groundPhysMaterial = new CANNON.Material("groundMaterial");
        const dominoPhysMaterial = new CANNON.Material("dominoMaterial");

        const groundDominoContactMaterial = new CANNON.ContactMaterial(
            groundPhysMaterial,
            dominoPhysMaterial,
            { friction: 0.01, restitution: 0.0, contactEquationStiffness: 1e5, contactEquationRelaxation: 2.0 }
        );
        world.addContactMaterial(groundDominoContactMaterial);
        const dominoDominoContactMaterial = new CANNON.ContactMaterial(
            dominoPhysMaterial,
            dominoPhysMaterial,
            {
                friction: 0.005,
                restitution: 0.0,
                contactEquationStiffness: 1e6,
                contactEquationRelaxation: 1.5,
                contactSkinSize: 0
            }
        );
        world.addContactMaterial(dominoDominoContactMaterial);

        // --- Ground ---
        const groundGeometry = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0xbbbbbb, roughness: 0.8, metalness: 0.2 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        ground.name = "Ground";
        scene.add(ground);
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, material: groundPhysMaterial });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        groundBody.position.set(0, 0.01, 0); // Position ground slightly above y=0 to avoid z-fighting with grid
        world.addBody(groundBody);

        // --- Grid Helper ---
        const grid = new THREE.GridHelper(GRID_SIZE, GRID_DIVISIONS, 0x666666, 0xaaaaaa);
        grid.position.y = 0.01; // Align grid with the physics ground
        grid.material.opacity = 0.6;
        grid.material.transparent = true;
        grid.visible = true;
        scene.add(grid);

        // --- Controls ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 80;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;

        // --- State Variables ---
        let dominoes = []; // Array of THREE.Mesh objects for visual dominoes
        let dominoData = []; // Array of {mesh, body, initialBasePosition, initialQuat}
        let selectedDominoData = null;
        let hoveredDominoData = null;
        let hoveredSimulationArrow = null;
        let isSimulating = false;
        let isAddingDomino = false;
        let previewDomino = null;
        let previewBatchGroup = null;
        let previewBatchCount = 0;
        let lastMousePosition = { x: 0, y: 0 };
        let translationMode = false;
        let rotationMode = false;
        let isMoving = false;
        let isRotating = false;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const contextMenu = document.getElementById('custom-context-menu');
        let isSelectingSimulationDirection = false;
        let simulationTargetData = null;
        let dominoModel = null; // Loaded GLB model template
        let rotationArrowSprite = null;

        // --- Load GLB Model ---
        const loader = new THREE.GLTFLoader();
        loader.load(
            'https://vita2048.github.io/DominoSimulator/OneBlockVerticalTransformed.glb',
            (gltf) => {
                dominoModel = gltf.scene;
                dominoModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        child.userData.isDomino = true; // Mark as part of a domino
                        if (child.material) {
                            // Ensure materials are standard and can have emissive properties
                            child.material = new THREE.MeshStandardMaterial({
                                map: child.material.map || null,
                                normalMap: child.material.normalMap || null,
                                roughness: child.material.roughness || 0.7,
                                metalness: child.material.metalness || 0.1,
                                emissive: new THREE.Color(0x000000),
                                emissiveIntensity: 1,
                                color: child.material.color || 0xffffff
                            });
                            if (child.geometry) child.geometry.computeBoundingBox(); // For accurate bounding box
                        }
                    }
                });
                // Calculate scale factor to match DOMINO_TALL constant
                const box = new THREE.Box3().setFromObject(dominoModel);
                const size = new THREE.Vector3();
                box.getSize(size);
                const scaleFactor = DOMINO_TALL / size.y;
                dominoModel.scale.set(scaleFactor, scaleFactor, scaleFactor);

                // After scaling, calculate the offset from the model's pivot to its visual bottom
                const scaledBox = new THREE.Box3().setFromObject(dominoModel);
                dominoModel.userData.pivotToBottomY = scaledBox.min.y; // This is a negative value if pivot is above bottom, 0 if pivot is at bottom
                
                console.log("Scaled model size:", scaledBox.getSize(new THREE.Vector3()));
                console.log("Pivot to bottom Y offset (scaledBox.min.y):", dominoModel.userData.pivotToBottomY);
                
                createPreviewDomino(); // Create the transparent preview domino
            },
            undefined, // onProgress callback (optional)
            (error) => {
                console.error("Error loading GLB model:", error);
                showNotification("Error: Could not load domino model.", true);
            }
        );

        // --- Domino Creation ---
        function createPreviewDomino() {
            if (!dominoModel) return;
            previewDomino = dominoModel.clone();
            previewDomino.traverse((child) => {
                if (child.isMesh) {
                    child.material = child.material.clone(); // Clone material for transparency
                    child.material.transparent = true;
                    child.material.opacity = 0.6;
                    child.userData.isDomino = true;
                }
            });
            const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;
            // Position preview domino so its visual bottom is at y=0 (before snapping)
            previewDomino.position.y = 0 - modelPivotCorrection; 
            previewDomino.rotation.y = 0; // Ensure preview domino starts with no rotation
            previewDomino.visible = false;
            scene.add(previewDomino);
        }

        function createDomino(basePosition, rotationY = 0) {
            if (!dominoModel) {
                showNotification("Error: Domino model not ready.", true);
                return null;
            }

            // Clone the visual model
            const dominoMesh = dominoModel.clone();
            dominoMesh.userData.isDomino = true;

            // Store the pivot offset for this instance (it's scaledBox.min.y)
            const modelPivotToBottomY_offset = dominoModel.userData.pivotToBottomY || 0;
            dominoMesh.userData.modelPivotToBottomY = modelPivotToBottomY_offset;

            // Position the visual model's pivot such that its visual bottom is at basePosition.y
            // basePosition.y is typically 0 (on the grid)
            dominoMesh.position.set(basePosition.x, basePosition.y - modelPivotToBottomY_offset, basePosition.z);
            dominoMesh.rotation.y = rotationY;

            dominoMesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material = child.material.clone(); // Each domino gets its own material instance
                    child.userData.isDominoPart = true;
                }
            });
            scene.add(dominoMesh);

            // Physics body setup
            // The CANNON.Box shape is centered at its local origin.
            // Dimensions are full width, height, depth. Half-extents are used for constructor.
            const shape = new CANNON.Box(new CANNON.Vec3(DOMINO_THICK / 2, DOMINO_TALL / 2, DOMINO_WIDE / 2));

            // Position the physics body's Center of Mass (CoM).
            // If basePosition.y is the desired bottom of the domino, CoM is DOMINO_TALL / 2 above that.
            const bodyCoMPosition = new CANNON.Vec3(basePosition.x, basePosition.y + DOMINO_TALL / 2, basePosition.z);

            const dominoBody = new CANNON.Body({
                mass: 1.0,
                position: bodyCoMPosition,
                shape: shape,
                material: dominoPhysMaterial,
                linearDamping: 0.15,
                angularDamping: 0.4,
                collisionResponse: true
            });

            // Apply the initial rotation to the physics body
            dominoBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotationY);
            dominoBody.allowSleep = true;
            dominoBody.sleepSpeedLimit = 0.5;
            dominoBody.sleepTimeLimit = 1.0;

            // Link the physics body to the visual model and vice-versa
            dominoMesh.userData.body = dominoBody;
            dominoBody.userData = { mesh: dominoMesh }; // Store reference to mesh in body's userData

            const data = {
                mesh: dominoMesh,
                body: dominoBody,
                initialBasePosition: basePosition.clone(), // Store initial snapped base position
                initialQuat: dominoBody.quaternion.clone() // Store initial orientation
            };

            dominoData.push(data);
            dominoes.push(dominoMesh); // Keep a flat list of meshes for raycasting
            world.addBody(dominoBody);

            // Debugging: Add a visual helper for the collision box
            //addCollisionBoxHelper(dominoBody, data);

            return data;
        }
        
        function addCollisionBoxHelper(body, data) {
            const shape = body.shapes[0]; // Assuming first shape is the box
            const geometry = new THREE.BoxGeometry(
                shape.halfExtents.x * 2,
                shape.halfExtents.y * 2,
                shape.halfExtents.z * 2
            );
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, transparent: true, opacity: 0.5 });
            const helperMesh = new THREE.Mesh(geometry, material);
            
            // The helper mesh's origin is its center, just like the Cannon.Box.
            // So, its position and quaternion can directly copy the body's.
            helperMesh.position.copy(body.position);
            helperMesh.quaternion.copy(body.quaternion);
            helperMesh.userData.isCollisionHelper = true; // Mark for easy identification/removal
            scene.add(helperMesh);
            
            data.userData = data.userData || {}; // Ensure userData exists on the domino data object
            data.userData.collisionHelper = helperMesh; // Store reference to helper

            // Update the helper's position and rotation during the simulation
            // This needs to be an event listener on the world or called in animate loop
            // For simplicity, adding to world's postStep event
            const updateHelperVisuals = () => {
                if (data.userData && data.userData.collisionHelper && data.body) { // Check if body and helper still exist
                     data.userData.collisionHelper.position.copy(data.body.position);
                     data.userData.collisionHelper.quaternion.copy(data.body.quaternion);
                } else {
                    // If body or helper is gone (e.g., domino deleted), remove this listener
                    world.removeEventListener('postStep', updateHelperVisuals);
                }
            };
            world.addEventListener('postStep', updateHelperVisuals);
            // Store the listener function so it can be removed if the domino is deleted
            data.userData.collisionHelperUpdater = updateHelperVisuals;
        }


        // --- Collision & Placement ---
        function snapToGrid(position) {
            const snappedX = Math.round(position.x / GRID_UNIT_SIZE) * GRID_UNIT_SIZE;
            const snappedZ = Math.round(position.z / GRID_UNIT_SIZE) * GRID_UNIT_SIZE;
            // Y position is the base of the domino, typically on the grid surface
            return new THREE.Vector3(snappedX, 0, snappedZ); 
        }

        function checkDominoCollision(position, excludeData = null) {
            const snappedPos = snapToGrid(position); // We care about collision at grid cells
            for (const data of dominoData) {
                if (data === excludeData) continue; // Don't check against self during move
                // Using initialBasePosition as dominoes are placed on grid cells
                const dx = data.initialBasePosition.x - snappedPos.x;
                const dz = data.initialBasePosition.z - snappedPos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < MIN_PLACEMENT_DISTANCE) return true; // Collision if too close
            }
            return false;
        }

        function mouseToWorld(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            // Intersect with the visual ground plane
            const intersects = raycaster.intersectObject(ground); 
            return intersects.length > 0 ? intersects[0].point : null;
        }

        // --- Highlighting ---
        function setEmissive(dominoData, colorHex = 0x000000, intensity = 1) {
            if (!dominoData || !dominoData.mesh) return;
            dominoData.mesh.traverse((child) => {
                if (child.isMesh && child.material && child.material.emissive) {
                    child.material.emissive.setHex(colorHex);
                    child.material.emissiveIntensity = intensity;
                }
            });
        }

        function findDominoDataFromObject(object) {
            let current = object;
            while (current) {
                // Check if current object itself is the main mesh linked to a body
                if (current.userData && current.userData.body) {
                    return dominoData.find(data => data.mesh === current);
                }
                // Check if current object is a part of a domino (e.g. child mesh)
                // and its parent is the main mesh linked to a body
                if (current.parent && current.parent.userData && current.parent.userData.body && current.userData.isDominoPart) {
                     return dominoData.find(data => data.mesh === current.parent);
                }
                current = current.parent;
            }
            return null;
        }


        function updateHoverEffect(event) {
            if (isAddingDomino || isSimulating || translationMode || rotationMode || isSelectingSimulationDirection) {
                if (hoveredDominoData && hoveredDominoData !== selectedDominoData) {
                    setEmissive(hoveredDominoData, 0x000000); // Clear previous hover
                }
                hoveredDominoData = null;
                return;
            }

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(dominoes, true); // Intersect all domino meshes (and their children)
            let currentlyHoveredData = null;

            if (intersects.length > 0) {
                currentlyHoveredData = findDominoDataFromObject(intersects[0].object);
            }

            // If hover changed
            if (hoveredDominoData !== currentlyHoveredData) {
                if (hoveredDominoData && hoveredDominoData !== selectedDominoData) {
                    setEmissive(hoveredDominoData, 0x000000); // Clear old hover if not selected
                }
                if (currentlyHoveredData && currentlyHoveredData !== selectedDominoData) {
                    setEmissive(currentlyHoveredData, HOVER_COLOR, 1.5); // Apply new hover if not selected
                }
                hoveredDominoData = currentlyHoveredData;
            }
        }

        // --- Selection & Manipulation ---
        function selectDomino(dataToSelect) {
            if (selectedDominoData === dataToSelect && dataToSelect !== null) return; // Already selected

            if (selectedDominoData) {
                setEmissive(selectedDominoData, 0x000000); // Clear previous selection
            }

            if (isSelectingSimulationDirection && selectedDominoData !== dataToSelect) {
                clearSimulationArrows(); // Clear arrows if selection changes during direction picking
            }

            selectedDominoData = dataToSelect;

            if (selectedDominoData) {
                setEmissive(selectedDominoData, SELECT_COLOR, 1.5); // Highlight new selection
                if (hoveredDominoData === selectedDominoData) {
                    // If the selected was also hovered, clear hover visual as selection takes precedence
                    hoveredDominoData = null; 
                }
            } else {
                // Deselected
                if (translationMode || rotationMode) { // Cancel ongoing transformations
                    translationMode = false;
                    rotationMode = false;
                    isMoving = false;
                    isRotating = false;
                    document.body.style.cursor = 'default';
                    controls.enabled = true;
                    if (rotationArrowSprite) scene.remove(rotationArrowSprite);
                }
                // If there was a hovered item that is not the (now null) selected one, re-apply hover
                if (hoveredDominoData) {
                     setEmissive(hoveredDominoData, HOVER_COLOR, 1.5);
                }
            }
            hideContextMenu();
        }


        function createRotationArrows() {
            // Creates a sprite with a circular arrow texture for rotation indication
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.strokeStyle = '#ff0000'; // Red color for arrows
            ctx.lineWidth = 8; // Thicker lines
            ctx.lineCap = 'round';
            
            // Draw two semi-circular arrows
            ctx.beginPath();
            ctx.arc(64, 64, 45, Math.PI * 0.70, Math.PI * 1.80, false); // Adjusted angles for better look
            ctx.moveTo(64 + 45 * Math.cos(Math.PI * 1.80) - 5 * Math.sin(Math.PI * 1.80) , 64 + 45 * Math.sin(Math.PI * 1.80) + 5 * Math.cos(Math.PI * 1.80));
            ctx.lineTo(64 + 45 * Math.cos(Math.PI * 1.80) + 10 * Math.sin(Math.PI * 1.80), 64 + 45 * Math.sin(Math.PI * 1.80) - 10 * Math.cos(Math.PI * 1.80));
            ctx.lineTo(64 + 45 * Math.cos(Math.PI * 1.80) - 5 * Math.cos(Math.PI * 1.80) , 64 + 45 * Math.sin(Math.PI * 1.80) - 5 * Math.sin(Math.PI * 1.80));


            ctx.stroke();

            ctx.beginPath();
            ctx.arc(64, 64, 45, Math.PI * -0.30, Math.PI * 0.80, false); // Second arrow, opposite direction
            ctx.moveTo(64 + 45 * Math.cos(Math.PI * 0.80) - 5 * Math.sin(Math.PI * 0.80) , 64 + 45 * Math.sin(Math.PI * 0.80) + 5 * Math.cos(Math.PI * 0.80));
            ctx.lineTo(64 + 45 * Math.cos(Math.PI * 0.80) + 10 * Math.sin(Math.PI * 0.80), 64 + 45 * Math.sin(Math.PI * 0.80) - 10 * Math.cos(Math.PI * 0.80));
            ctx.lineTo(64 + 45 * Math.cos(Math.PI * 0.80) - 5 * Math.cos(Math.PI * 0.80) , 64 + 45 * Math.sin(Math.PI * 0.80) - 5 * Math.sin(Math.PI * 0.80));
            ctx.stroke();

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, color: 0xffffff, transparent: true, depthTest: false, depthWrite: false, sizeAttenuation: false });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.1, 0.1, 0.1); // Adjust scale for better on-screen size
            sprite.position.z = 0.1; // Slightly in front
            sprite.visible = false;
            sprite.userData.isRotationArrow = true;
            sprite.renderOrder = 1; // Render on top
            return sprite;
        }

        function animateRotation(data) {
            if (!data || !data.mesh || !data.body) return;
            if (!rotationArrowSprite) rotationArrowSprite = createRotationArrows();
            
            // Position arrow above the domino
            const visualYPosition = data.mesh.position.y + (data.mesh.userData.modelPivotToBottomY || 0) + DOMINO_TALL * 0.75;
            rotationArrowSprite.position.set(data.mesh.position.x, visualYPosition + 0.5, data.mesh.position.z); // Lift arrow a bit more
            rotationArrowSprite.visible = true;
            scene.add(rotationArrowSprite);

            const initialBodyQuaternion = data.body.quaternion.clone();
            let totalRotationOffset = 0; // Accumulates rotation from mouse drag

            function updateRotation(event) {
                if (!rotationMode || !selectedDominoData || selectedDominoData !== data) {
                    document.removeEventListener('mousemove', updateRotation);
                    if (rotationArrowSprite) {
                        scene.remove(rotationArrowSprite); // Clean up sprite
                        rotationArrowSprite.visible = false;
                    }
                    return;
                }
                const deltaX = event.clientX - lastMousePosition.x;
                const rotationSpeed = 0.01; // Sensitivity of rotation
                totalRotationOffset += deltaX * rotationSpeed;

                // Create a quaternion for the new rotation around the Y-axis
                const rotationQuaternion = new CANNON.Quaternion();
                rotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), totalRotationOffset);
                
                // Apply this rotation relative to the initial orientation
                data.body.quaternion.copy(initialBodyQuaternion).mult(rotationQuaternion, data.body.quaternion);
                data.body.quaternion.normalize(); // Normalize to prevent issues

                // Update mesh quaternion immediately for visual feedback
                data.mesh.quaternion.copy(data.body.quaternion); 
                
                // Update arrow position (domino itself doesn't move, only rotates here)
                const currentBaseY = data.mesh.position.y + (data.mesh.userData.modelPivotToBottomY || 0);
                rotationArrowSprite.position.set(data.mesh.position.x, currentBaseY + DOMINO_TALL * 0.75 + 0.5, data.mesh.position.z);

                // Update collision helper if it exists
                if (data.userData && data.userData.collisionHelper) {
                    data.userData.collisionHelper.quaternion.copy(data.body.quaternion);
                }
                lastMousePosition = { x: event.clientX, y: event.clientY };
            }
            document.addEventListener('mousemove', updateRotation, false);
        }


        function createSimulationArrowHelper(origin, directionVec, color, userDataDirection) {
            const length = 1.0;
            const headLength = 0.3;
            const headWidth = 0.2;
            const arrowHelper = new THREE.ArrowHelper(directionVec.clone().normalize(), origin, length, color, headLength, headWidth);
            arrowHelper.userData.isSimulationArrow = true;
            arrowHelper.userData.direction = userDataDirection; // e.g., 'positiveX' or 'negativeX'
            arrowHelper.userData.originalColor = color;
            arrowHelper.userData.isPulsing = false;
            arrowHelper.userData.pulseTime = 0;
            // Make parts of arrow identifiable for raycasting
            arrowHelper.line.userData = { isSimulationArrowPart: true, parentArrow: arrowHelper };
            arrowHelper.cone.userData = { isSimulationArrowPart: true, parentArrow: arrowHelper };
            return arrowHelper;
        }

        function clearSimulationArrows() {
            const arrowsToRemove = scene.children.filter(child => child.userData && child.userData.isSimulationArrow);
            arrowsToRemove.forEach(arrow => {
                if (hoveredSimulationArrow === arrow) {
                    if (arrow.cone) arrow.cone.scale.set(1, 1, 1); // Reset pulse effect
                    hoveredSimulationArrow = null;
                }
                scene.remove(arrow); // Remove from scene
                // Dispose geometry/material if necessary, though ArrowHelper might handle some
            });
            if (isSelectingSimulationDirection) {
                isSelectingSimulationDirection = false;
                simulationTargetData = null;
                document.body.style.cursor = 'default';
                controls.enabled = true; // Re-enable orbit controls
            }
        }

        // --- Context Menu Logic ---
        function showContextMenu(event, targetData) {
            hideContextMenu(); // Hide any existing menu
            selectDomino(targetData); // Select the domino that was right-clicked
            contextMenu.style.left = `${event.clientX}px`;
            contextMenu.style.top = `${event.clientY}px`;
            contextMenu.style.display = 'block';

            document.getElementById('context-move').onclick = () => {
                translationMode = true;
                rotationMode = false;
                isMoving = true; // Flag to indicate domino is being moved by mouse
                isRotating = false;
                lastMousePosition = { x: event.clientX, y: event.clientY };
                showNotification("Move: Domino follows mouse. Left-click to fix. Esc to cancel.");
                document.body.style.cursor = 'move';
                controls.enabled = false; // Disable orbit controls during move
                hideContextMenu();
            };

            document.getElementById('context-rotate').onclick = () => {
                rotationMode = true;
                translationMode = false;
                isRotating = true; // Flag to indicate domino is being rotated
                isMoving = false;
                lastMousePosition = { x: event.clientX, y: event.clientY };
                showNotification("Rotate: Drag mouse horizontally. Left-click to fix. Esc to cancel.");
                document.body.style.cursor = 'ew-resize';
                controls.enabled = false; // Disable orbit controls during rotation
                animateRotation(targetData); // Start rotation logic
                hideContextMenu();
            };

            document.getElementById('context-start-simulation').onclick = () => {
                if (!targetData || !targetData.body) return;
                hideContextMenu();
                clearSimulationArrows(); // Clear any previous arrows

                const bodyPos = targetData.body.position; // Cannon.Vec3
                const bodyQuat = targetData.body.quaternion; // Cannon.Quaternion

                // Local X-axis vector (representing the "face" of the domino)
                const localX = new THREE.Vector3(1, 0, 0); 
                
                // Transform local X to world space using domino's orientation
                const worldNormalPositiveX = new THREE.Vector3().copy(localX).applyQuaternion(
                    new THREE.Quaternion(bodyQuat.x, bodyQuat.y, bodyQuat.z, bodyQuat.w)
                );
                const worldNormalNegativeX = worldNormalPositiveX.clone().negate();

                // Offset for arrow placement (on the wider faces of the domino)
                const faceOffsetDistance = DOMINO_WIDE / 2 + 0.1; // Slightly off the surface

                const arrowOriginPositiveX = new THREE.Vector3(bodyPos.x, bodyPos.y, bodyPos.z)
                    .add(worldNormalPositiveX.clone().multiplyScalar(faceOffsetDistance));
                const arrowOriginNegativeX = new THREE.Vector3(bodyPos.x, bodyPos.y, bodyPos.z)
                    .add(worldNormalNegativeX.clone().multiplyScalar(faceOffsetDistance));
                
                // Create arrows pointing along the domino's wider faces
                const positiveXArrow = createSimulationArrowHelper(arrowOriginPositiveX, worldNormalPositiveX, ARROW_COLOR_DEFAULT, 'positiveX');
                scene.add(positiveXArrow);
                const negativeXArrow = createSimulationArrowHelper(arrowOriginNegativeX, worldNormalNegativeX, ARROW_COLOR_DEFAULT, 'negativeX');
                scene.add(negativeXArrow);

                showNotification("Click a red arrow to apply impulse in that direction.");
                isSelectingSimulationDirection = true;
                simulationTargetData = targetData; // Store the domino to apply impulse to
                controls.enabled = false; // Disable orbit while choosing direction
            };

            document.getElementById('context-delete').onclick = () => {
                deleteSelectedDomino();
                hideContextMenu();
            };
        }

        function deleteSelectedDomino() {
            if (!selectedDominoData) return;
            const dataToDelete = selectedDominoData;
            selectDomino(null); // Deselect

            // Remove visual mesh from scene
            scene.remove(dataToDelete.mesh);

            // Remove physics body from world
            if (world.bodies.includes(dataToDelete.body)) {
                world.removeBody(dataToDelete.body);
            }

            // Remove collision helper and its updater
            if (dataToDelete.userData && dataToDelete.userData.collisionHelper) {
                scene.remove(dataToDelete.userData.collisionHelper);
                if (dataToDelete.userData.collisionHelperUpdater) {
                    world.removeEventListener('postStep', dataToDelete.userData.collisionHelperUpdater);
                }
            }

            // Clean up from internal arrays
            const meshIndex = dominoes.indexOf(dataToDelete.mesh);
            if (meshIndex > -1) dominoes.splice(meshIndex, 1);
            const dataIndex = dominoData.indexOf(dataToDelete);
            if (dataIndex > -1) dominoData.splice(dataIndex, 1);

            // Dispose Three.js resources
            dataToDelete.mesh.traverse((child) => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (child.material.map) child.material.map.dispose();
                        // If material is an array
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
            });
            showNotification('Domino Deleted');
        }


        function hideContextMenu() {
            contextMenu.style.display = 'none';
            // Detach event listeners to prevent memory leaks or multiple triggers
            document.getElementById('context-move').onclick = null;
            document.getElementById('context-rotate').onclick = null;
            document.getElementById('context-start-simulation').onclick = null;
            document.getElementById('context-delete').onclick = null;
        }

        // --- Simulation Control ---
        function startSimulation(impulseData = null) { // impulseData: {targetBody, worldImpulse, worldApplicationPoint}
            if (dominoData.length === 0 && !impulseData) {
                showNotification("Add some dominoes first!");
                return;
            }
            if (isSimulating) return;

            clearSimulationArrows(); // Clear any direction selection arrows
            isSimulating = true;
            world.allowSleep = false; // Wake up all bodies

            dominoData.forEach(data => data.body.wakeUp()); // Ensure all bodies are awake

            if (impulseData && impulseData.targetBody) {
                impulseData.targetBody.wakeUp();
                impulseData.targetBody.applyImpulse(impulseData.worldImpulse, impulseData.worldApplicationPoint);
                showNotification("Simulation started with selected impulse!");
            } else if (selectedDominoData && selectedDominoData.body) {
                // Default impulse if no specific one is given (e.g., spacebar start)
                // Apply impulse to the "face" of the selected domino
                selectedDominoData.body.wakeUp();
                const localImpulse = new CANNON.Vec3(IMPULSE_MAGNITUDE, 0, 0); // Impulse along local X
                // Point of application on the "top-back" edge of the wider face
                const appPointLocal = new CANNON.Vec3(
                    -DOMINO_WIDE / 2, // Apply to the -X face (local coordinates)
                    DOMINO_TALL * 0.45,  // Apply somewhat high on the domino (0.5 is CoM height)
                    0                   // Centered on the thickness axis
                ); 
                
                const worldImpulse = selectedDominoData.body.quaternion.vmult(localImpulse);
                const worldApplicationPoint = selectedDominoData.body.quaternion.vmult(appPointLocal);
                // Add body position to get world space application point from CoM
                worldApplicationPoint.vadd(selectedDominoData.body.position, worldApplicationPoint); 

                selectedDominoData.body.applyImpulse(worldImpulse, worldApplicationPoint);
                showNotification("Simulation started with default impulse on selected domino!");
            } else if (dominoData.length > 0) {
                // If no domino selected, but we have dominoes, maybe nudge the first one?
                // Or require selection. For now, let's require selection or specific impulse.
                showNotification("Select a domino or use context menu to start simulation with impulse.", true);
                isSimulating = false; // Revert simulation state
                world.allowSleep = true;
                return;
            }


            // Disable interaction modes
            translationMode = false; rotationMode = false; isAddingDomino = false;
            isMoving = false; isRotating = false;
            document.body.style.cursor = 'default';
            if (previewDomino) previewDomino.visible = false;
            if (previewBatchGroup) scene.remove(previewBatchGroup); previewBatchGroup = null;
        }

        function resetSimulation() {
            isSimulating = false;
            world.allowSleep = true; // Allow bodies to sleep again
            clearSimulationArrows();
            hideContextMenu();

            // Cancel any ongoing interaction modes
            if (translationMode || rotationMode || isAddingDomino) {
                translationMode = false;
                rotationMode = false;
                isAddingDomino = false;
                isMoving = false;
                isRotating = false;
                document.body.style.cursor = 'default';
                if (previewDomino) previewDomino.visible = false;
                if (previewBatchGroup) {
                    scene.remove(previewBatchGroup);
                    previewBatchGroup = null;
                    previewBatchCount = 0;
                }
                if (rotationArrowSprite) scene.remove(rotationArrowSprite);
            }
            controls.enabled = true; // Re-enable orbit controls

            // Reset each domino to its initial state
            dominoData.forEach(data => {
                const basePos = data.initialBasePosition; // This is the snapped grid position for the bottom
                const modelPivotOffsetY = data.mesh.userData.modelPivotToBottomY || 0;

                // Reset physics body
                data.body.position.set(basePos.x, basePos.y + DOMINO_TALL / 2, basePos.z); // CoM position
                data.body.quaternion.copy(data.initialQuat);
                data.body.velocity.set(0, 0, 0);
                data.body.angularVelocity.set(0, 0, 0);
                data.body.sleep(); // Put the body to sleep

                // Reset visual mesh
                // This needs to use the corrected logic if the animate loop is fixed
                // For now, let's assume initial upright orientation for reset simplicity
                // The animate loop will correct it on the next frame if the fix is applied there
                data.mesh.position.set(basePos.x, basePos.y - modelPivotOffsetY, basePos.z);
                data.mesh.quaternion.copy(data.initialQuat);

                setEmissive(data, 0x000000); // Clear any emissive color

                // Reset collision helper
                if (data.userData && data.userData.collisionHelper) {
                    data.userData.collisionHelper.position.copy(data.body.position);
                    data.userData.collisionHelper.quaternion.copy(data.body.quaternion);
                }
            });

            selectDomino(null); // Deselect any domino
            hoveredDominoData = null; // Clear hover

            // Reset simulation arrow hover state
            if (hoveredSimulationArrow) {
                setArrowColor(hoveredSimulationArrow, hoveredSimulationArrow.userData.originalColor);
                if (hoveredSimulationArrow.cone) hoveredSimulationArrow.cone.scale.set(1, 1, 1);
                hoveredSimulationArrow.userData.isPulsing = false;
                hoveredSimulationArrow = null;
            }
            showNotification('Simulation Reset');
        }


        function clearCanvas() {
            resetSimulation(); // Stop simulation and reset states
            // Remove all dominoes
            dominoData.forEach(data => {
                scene.remove(data.mesh);
                if (world.bodies.includes(data.body)) world.removeBody(data.body);
                if (data.userData && data.userData.collisionHelper) {
                    scene.remove(data.userData.collisionHelper);
                     if (data.userData.collisionHelperUpdater) { // Remove specific event listener
                        world.removeEventListener('postStep', data.userData.collisionHelperUpdater);
                    }
                }
                // Dispose Three.js resources
                data.mesh.traverse((child) => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                             if (child.material.map) child.material.map.dispose();
                             if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    }
                });
            });
            dominoes = []; // Clear arrays
            dominoData = [];
            // Fallback: remove any remaining collision helpers not tied to dominoData (shouldn't happen ideally)
            // scene.children = scene.children.filter(child => !child.userData || !child.userData.isCollisionHelper);
            showNotification('Canvas Cleared');
        }

        // --- UI Helpers ---
        function showNotification(message, isError = false) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.backgroundColor = isError ? 'rgba(200, 0, 0, 0.8)' : 'rgba(0, 0, 0, 0.7)';
            notification.style.opacity = '1';
            setTimeout(() => { notification.style.opacity = '0'; }, isError ? 3000 : 2000);
        }

        function toggleOrbitControls() {
            controls.enabled = !controls.enabled;
            document.getElementById('toggle-orbit').textContent = controls.enabled ? 'Lock Camera' : 'Unlock Camera';
            // If controls are re-enabled while in an interaction mode, cancel that mode
            if (controls.enabled && (translationMode || rotationMode || isAddingDomino || isSelectingSimulationDirection)) {
                translationMode = false;
                rotationMode = false;
                isAddingDomino = false;
                isSelectingSimulationDirection = false;
                isMoving = false;
                isRotating = false;
                document.body.style.cursor = 'default';
                if (previewDomino) previewDomino.visible = false;
                if (previewBatchGroup) {
                    scene.remove(previewBatchGroup);
                    previewBatchGroup = null;
                    previewBatchCount = 0;
                }
                clearSimulationArrows();
                if (rotationArrowSprite) scene.remove(rotationArrowSprite);
            }
        }

        function onStartDragDominoTemplate(event) {
            if (event.button !== 0) return; // Only left click
            if (isSimulating || !dominoModel) return;
            isAddingDomino = true;
            previewBatchGroup = null; // Ensure not in batch mode
            if (!previewDomino) createPreviewDomino(); // Create if doesn't exist
            if (previewDomino) {
                previewDomino.visible = true;
                previewDomino.rotation.y = 0; // Reset rotation for single domino placement
            }
            controls.enabled = false; // Disable orbit controls
            document.body.style.cursor = 'grabbing';
            hideContextMenu();
        }

        function onAddBatch() {
            if (isSimulating || !dominoModel) return;
            const numDominosStr = prompt("Enter number of dominos for the batch (2-20):", "5");
            if (numDominosStr === null) return; // User cancelled
            const n = parseInt(numDominosStr);
            if (isNaN(n) || n < 2 || n > 20) {
                showNotification("Invalid number. Please enter a value between 2 and 20.", true);
                return;
            }
            createPreviewBatch(n); // Create the visual batch preview
            isAddingDomino = true; // Set flag
            previewDomino = null; // Ensure not in single domino mode
            controls.enabled = false;
            document.body.style.cursor = 'grabbing';
            hideContextMenu();
        }

        function createPreviewBatch(n) {
            if (previewBatchGroup) { // Clear previous batch preview
                scene.remove(previewBatchGroup);
                previewBatchGroup.traverse(child => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) child.material.forEach(m=>m.dispose());
                            else child.material.dispose();
                        }
                    }
                });
                previewBatchGroup = null;
            }
            previewBatchGroup = new THREE.Group();
            const spacing = 1.0; // Spacing between dominos in the batch
            const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;

            for (let i = 0; i < n; i++) {
                const singlePreview = dominoModel.clone();
                singlePreview.traverse((child) => {
                    if (child.isMesh) {
                        child.material = child.material.clone();
                        child.material.transparent = true;
                        child.material.opacity = 0.6;
                        child.userData.isDomino = true;
                    }
                });
                // Arrange in a line along Z-axis relative to the group's origin
                const zPos = (i - (n - 1) / 2) * spacing; 
                singlePreview.position.set(0, 0 - modelPivotCorrection, zPos); // Position bottom at group's y=0
                singlePreview.rotation.y = Math.PI / 2; // Orient them sideways for a typical batch setup
                previewBatchGroup.add(singlePreview);
            }
            // The group itself will be positioned by mouse, its y will be 0 (grid surface)
            // The individual previews are already corrected for pivot inside the group.
            scene.add(previewBatchGroup);
            previewBatchCount = n;
        }


        // --- Event Listeners Setup ---
        function initEventListeners() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                hideContextMenu();
            }, false);

            const canvasContainer = document.getElementById('canvas-container');
            canvasContainer.addEventListener('mousedown', onMouseDown, false);
            canvasContainer.addEventListener('mousemove', onMouseMove, false);
            canvasContainer.addEventListener('mouseup', onMouseUp, false);
            canvasContainer.addEventListener('contextmenu', onContextMenu, false); // For right-click

            window.addEventListener('keydown', onKeyDown, false);
            // Global mousedown to hide context menu if clicked outside
            window.addEventListener('mousedown', (event) => {
                if (contextMenu.style.display === 'block' && !contextMenu.contains(event.target)) {
                    hideContextMenu();
                }
            }, true); // Use capture phase to catch it early

            document.getElementById('domino-template').addEventListener('mousedown', onStartDragDominoTemplate);
            document.getElementById('add-batch-button').addEventListener('click', onAddBatch);
            document.getElementById('reset-button').addEventListener('click', resetSimulation);
            document.getElementById('clear-button').addEventListener('click', clearCanvas);
            document.getElementById('toggle-grid').addEventListener('change', (event) => { grid.visible = event.target.checked; });
            document.getElementById('toggle-orbit').addEventListener('click', toggleOrbitControls);
            document.getElementById('reset-camera').addEventListener('click', () => {
                controls.reset(); // Resets to initial position/target
                camera.position.set(0, 20, 30); // Explicitly set desired reset
                camera.lookAt(0, 0, 0);
                controls.update(); // Important after manual camera changes
                // Ensure controls are enabled if they were locked
                if (!controls.enabled) {
                    controls.enabled = true;
                    document.getElementById('toggle-orbit').textContent = 'Lock Camera';
                }
            });
            document.getElementById('help-button').addEventListener('click', () => { document.getElementById('modal-overlay').style.display = 'flex'; });
            document.getElementById('close-modal').addEventListener('click', () => { document.getElementById('modal-overlay').style.display = 'none'; });
            // Close modal if clicking on the overlay itself
            document.getElementById('modal-overlay').addEventListener('click', (event) => {
                if (event.target === document.getElementById('modal-overlay')) {
                    document.getElementById('modal-overlay').style.display = 'none';
                }
            });
        }

        function setArrowColor(arrow, color) {
            if (arrow && arrow.line && arrow.cone) {
                arrow.line.material.color.setHex(color);
                arrow.cone.material.color.setHex(color);
            }
        }

        function onMouseDown(event) {
            if (event.button !== 0) return; // Only handle left-clicks here, right-click is for context menu
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // --- Handle Simulation Arrow Click ---
            if (isSelectingSimulationDirection && simulationTargetData) {
                const simulationArrows = scene.children.filter(c => c.userData && c.userData.isSimulationArrow);
                const intersectsArrows = raycaster.intersectObjects(simulationArrows, true); // true for recursive

                if (intersectsArrows.length > 0) {
                    let clickedArrowPart = intersectsArrows[0].object;
                    let actualArrow = clickedArrowPart.userData.parentArrow || (clickedArrowPart.userData.isSimulationArrow ? clickedArrowPart : null);
                    
                    if (actualArrow && actualArrow.userData.direction) {
                        const direction = actualArrow.userData.direction; // 'positiveX' or 'negativeX'
                        
                        let localImpulse = new CANNON.Vec3();
                        // Impulse direction is based on the arrow's defined direction (local to domino)
                        if (direction === 'positiveX') localImpulse.set(IMPULSE_MAGNITUDE, 0, 0); 
                        else localImpulse.set(-IMPULSE_MAGNITUDE, 0, 0); 
                        
                        // Application point on the face the arrow is pointing from
                        const appPointLocal = new CANNON.Vec3(
                            direction === 'positiveX' ? -DOMINO_WIDE / 2 : DOMINO_WIDE / 2, // Opposite face for push
                            DOMINO_TALL * 0.4, // Apply high
                            0
                        );
                        
                        const worldImpulse = simulationTargetData.body.quaternion.vmult(localImpulse);
                        const worldApplicationPoint = simulationTargetData.body.quaternion.vmult(appPointLocal);
                        worldApplicationPoint.vadd(simulationTargetData.body.position, worldApplicationPoint);
                        
                        // Start simulation with this specific impulse
                        startSimulation({
                            targetBody: simulationTargetData.body,
                            worldImpulse: worldImpulse,
                            worldApplicationPoint: worldApplicationPoint
                        });
                        // clearSimulationArrows(); // startSimulation will call this
                        return; // Action handled
                    }
                } else {
                    // Clicked outside any arrow, cancel selection mode
                    clearSimulationArrows();
                    showNotification("Simulation direction selection canceled.");
                }
                return; // Either handled or selection cancelled
            }

            // --- Handle Fixing Domino after Move/Rotate ---
            if (isMoving && translationMode && selectedDominoData) { // Finalize move
                isMoving = false;
                translationMode = false;
                document.body.style.cursor = 'default';
                controls.enabled = true;
                const modelPivotOffsetY = selectedDominoData.mesh.userData.modelPivotToBottomY || 0;
                // The mesh pivot is at selectedDominoData.mesh.position.
                // Its visual bottom is at selectedDominoData.mesh.position.y + modelPivotOffsetY
                // We want this visual bottom to be at the snapped grid y (which is 0)
                const currentBasePosition = snapToGrid(selectedDominoData.mesh.position); // Snap current mesh pivot's XZ
                currentBasePosition.y = 0; // Ensure base is on grid

                const collision = checkDominoCollision(currentBasePosition, selectedDominoData);
                setEmissive(selectedDominoData, collision ? COLLISION_COLOR : SELECT_COLOR, 1.5);
                if (collision) {
                    showNotification("Warning: Domino placement overlaps! Reverting to last valid.", true);
                    // Revert to initial position before move started (more robust needed if move was multi-step)
                    const oldBase = selectedDominoData.initialBasePosition;
                    selectedDominoData.mesh.position.set(oldBase.x, oldBase.y - modelPivotOffsetY, oldBase.z);
                    selectedDominoData.body.position.set(oldBase.x, oldBase.y + DOMINO_TALL / 2, oldBase.z);
                } else {
                    showNotification("Position fixed.");
                    selectedDominoData.initialBasePosition.copy(currentBasePosition); // Update stored initial pos
                    // Body CoM needs to be updated based on new base position
                    selectedDominoData.body.position.set(currentBasePosition.x, currentBasePosition.y + DOMINO_TALL / 2, currentBasePosition.z);
                }
                 // Ensure collision helper is also updated
                if (selectedDominoData.userData && selectedDominoData.userData.collisionHelper) {
                    selectedDominoData.userData.collisionHelper.position.copy(selectedDominoData.body.position);
                }
                return;
            }
            if (isRotating && rotationMode && selectedDominoData) { // Finalize rotate
                isRotating = false;
                rotationMode = false;
                document.body.style.cursor = 'default';
                controls.enabled = true;
                selectedDominoData.initialQuat.copy(selectedDominoData.body.quaternion); // Store new orientation
                setEmissive(selectedDominoData, SELECT_COLOR, 1.5);
                showNotification("Rotation fixed.");
                if (rotationArrowSprite) {
                    scene.remove(rotationArrowSprite);
                    rotationArrowSprite.visible = false;
                }
                return;
            }

            // --- Handle Domino Selection ---
            const intersectsDominoes = raycaster.intersectObjects(dominoes, true);
            if (intersectsDominoes.length > 0 && !isSimulating) {
                const clickedDominoData = findDominoDataFromObject(intersectsDominoes[0].object);
                if (clickedDominoData) {
                    selectDomino(clickedDominoData);
                } else {
                     if (!isSelectingSimulationDirection) selectDomino(null); // Clicked on non-domino part of scene
                }
            } else {
                 if (!isSelectingSimulationDirection) selectDomino(null); // Clicked on empty space
            }
        }


        function onMouseMove(event) {
            if (!dominoModel) return; // Model not loaded yet

            const currentMouse = new THREE.Vector2(
                ((event.clientX - renderer.domElement.getBoundingClientRect().left) / renderer.domElement.width) * 2 - 1,
                -((event.clientY - renderer.domElement.getBoundingClientRect().top) / renderer.domElement.height) * 2 + 1
            );
            raycaster.setFromCamera(currentMouse, camera);
            const worldPos = mouseToWorld(event); // Gets intersection point with ground plane
            const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;

            // --- Handle Adding Single Domino or Batch ---
            if (isAddingDomino && worldPos) {
                const snappedBasePos = snapToGrid(worldPos); // Snapped X, Z, with Y=0 (base on grid)
                
                if (previewDomino && !previewBatchGroup) { // Adding single domino
                    // Position preview's pivot so its visual bottom is at snappedBasePos.y
                    previewDomino.position.set(snappedBasePos.x, snappedBasePos.y - modelPivotCorrection, snappedBasePos.z);
                    const collision = checkDominoCollision(snappedBasePos);
                    previewDomino.traverse((child) => {
                        if (child.isMesh && child.material) {
                            child.material.color.setHex(collision ? 0xff8888 : 0xffffff); // Reddish if collision
                            child.material.opacity = collision ? 0.4 : 0.6;
                        }
                    });
                } else if (previewBatchGroup) { // Adding batch
                    // Position the group's origin at the snapped position
                    // Individual dominos in the group are already offset relative to group's origin
                    previewBatchGroup.position.copy(snappedBasePos); 
                    // Note: individual previews in batch already have Y pivot correction
                    // The group's Y is effectively the base Y for all of them.

                    let collisionInBatch = false;
                    for (let i = 0; i < previewBatchCount; i++) {
                        // Get world position of each domino in the preview batch
                        const tempWorldPos = new THREE.Vector3();
                        previewBatchGroup.children[i].getWorldPosition(tempWorldPos);
                        const dominoBasePosInWorld = snapToGrid(tempWorldPos); // Snap its world pos
                        if (checkDominoCollision(dominoBasePosInWorld)) {
                            collisionInBatch = true;
                            break;
                        }
                    }
                    previewBatchGroup.traverse((child) => { // Visual feedback for whole batch
                        if (child.isMesh && child.material && child.userData.isDomino) { // Check isDomino to avoid affecting group itself if it had material
                            child.material.color.setHex(collisionInBatch ? 0xff8888 : 0xffffff);
                            child.material.opacity = collisionInBatch ? 0.4 : 0.6;
                        }
                    });
                }
            } 
            // --- Handle Moving Selected Domino ---
            else if (selectedDominoData && isMoving && translationMode && worldPos) {
                const snappedBasePos = snapToGrid(worldPos); // Target base position for the domino
                
                // Position mesh pivot so its visual bottom is at snappedBasePos.y
                selectedDominoData.mesh.position.set(snappedBasePos.x, snappedBasePos.y - modelPivotCorrection, snappedBasePos.z);
                
                // Update physics body's CoM based on the new base position
                selectedDominoData.body.position.set(snappedBasePos.x, snappedBasePos.y + DOMINO_TALL / 2, snappedBasePos.z);
                selectedDominoData.body.wakeUp(); // Keep body awake during move

                const collision = checkDominoCollision(snappedBasePos, selectedDominoData);
                setEmissive(selectedDominoData, collision ? COLLISION_COLOR : SELECT_COLOR, 1.5);

                // Update collision helper position during manual movement
                if (selectedDominoData.userData && selectedDominoData.userData.collisionHelper) {
                    selectedDominoData.userData.collisionHelper.position.copy(selectedDominoData.body.position);
                    // Quaternion doesn't change during translation mode
                }
            } 
            // --- Handle Hovering Simulation Arrows ---
            else if (isSelectingSimulationDirection) {
                const simulationArrows = scene.children.filter(c => c.userData && c.userData.isSimulationArrow);
                let intersectedArrowThisFrame = null;
                if (simulationArrows.length > 0) {
                    const intersects = raycaster.intersectObjects(simulationArrows, true);
                    if (intersects.length > 0) {
                        let obj = intersects[0].object;
                        intersectedArrowThisFrame = obj.userData.parentArrow || (obj.userData.isSimulationArrow ? obj : null);
                    }
                }

                if (hoveredSimulationArrow && hoveredSimulationArrow !== intersectedArrowThisFrame) {
                    setArrowColor(hoveredSimulationArrow, hoveredSimulationArrow.userData.originalColor);
                    hoveredSimulationArrow.userData.isPulsing = false;
                    if (hoveredSimulationArrow.cone) hoveredSimulationArrow.cone.scale.set(1, 1, 1); // Reset pulse
                }
                if (intersectedArrowThisFrame) {
                    setArrowColor(intersectedArrowThisFrame, ARROW_COLOR_HOVER);
                    intersectedArrowThisFrame.userData.isPulsing = true; // For visual feedback in animate loop
                    document.body.style.cursor = 'pointer';
                } else {
                    document.body.style.cursor = 'default';
                }
                hoveredSimulationArrow = intersectedArrowThisFrame;
            } 
            // --- Handle General Hover Effect ---
            else if (!isSimulating) {
                updateHoverEffect(event);
            }
            lastMousePosition = { x: event.clientX, y: event.clientY };
        }


        function onMouseUp(event) {
            if (event.button !== 0 || !dominoModel) return; // Only left-click, ensure model is loaded

            if (isAddingDomino) {
                const worldPos = mouseToWorld(event);
                if (worldPos) {
                    const snappedBasePos = snapToGrid(worldPos); // Snapped X, Z, Y=0 for base

                    if (previewDomino && !previewBatchGroup) { // Finalize adding single domino
                        const collision = checkDominoCollision(snappedBasePos);
                        if (!collision) {
                            createDomino(snappedBasePos, previewDomino.rotation.y); // Use preview's current rotation
                        } else {
                            showNotification("Placement overlaps existing domino!", true);
                        }
                        previewDomino.visible = false;
                    } else if (previewBatchGroup) { // Finalize adding batch
                        // The group's position is already snappedBasePos from mousemove
                        let collisionInBatch = false;
                        const finalPositionsAndRotations = [];

                        for (let i = 0; i < previewBatchCount; i++) {
                            const childPreview = previewBatchGroup.children[i];
                            const tempWorldPos = new THREE.Vector3();
                            childPreview.getWorldPosition(tempWorldPos); // Get world pos of this child
                            const childSnappedBasePos = snapToGrid(tempWorldPos); // Snap its base

                            if (checkDominoCollision(childSnappedBasePos)) {
                                collisionInBatch = true;
                                break;
                            }
                            finalPositionsAndRotations.push({
                                position: childSnappedBasePos,
                                rotationY: childPreview.rotation.y // Use preview's rotation
                            });
                        }

                        if (!collisionInBatch) {
                            finalPositionsAndRotations.forEach(pr => createDomino(pr.position, pr.rotationY));
                        } else {
                            showNotification("Batch placement overlaps existing dominoes!", true);
                        }
                        scene.remove(previewBatchGroup); // Clean up preview
                        previewBatchGroup.traverse(child => { /* dispose geometry/material */ });
                        previewBatchGroup = null;
                        previewBatchCount = 0;
                    }
                }
                // Reset adding mode
                isAddingDomino = false;
                document.body.style.cursor = 'default';
                controls.enabled = true;
            }
            // Note: Fixing domino after move/rotate is handled in onMouseDown
        }


        function onContextMenu(event) {
            event.preventDefault(); // Prevent default browser context menu
            if (isSimulating || isAddingDomino || isMoving || isRotating) return; // No context menu during these actions

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(dominoes, true);
            if (intersects.length > 0) {
                const targetData = findDominoDataFromObject(intersects[0].object);
                if (targetData) {
                    showContextMenu(event, targetData); // Show custom context menu for this domino
                }
            } else {
                hideContextMenu(); // Clicked on empty space, hide menu
                selectDomino(null); // Deselect any domino
            }
        }

        function onKeyDown(event) {
            const key = event.key.toLowerCase();

            // Handle Escape key for cancelling actions
            if (key === 'escape') {
                hideContextMenu();
                let modeCancelled = false;
                if (isAddingDomino) {
                    if (previewDomino) previewDomino.visible = false;
                    if (previewBatchGroup) {
                        scene.remove(previewBatchGroup);
                        previewBatchGroup = null;
                        previewBatchCount = 0;
                    }
                    isAddingDomino = false;
                    modeCancelled = true;
                } else if (translationMode || rotationMode) { // Cancel move or rotate
                    // Revert to original state before transformation started
                    if (selectedDominoData) {
                        const basePos = selectedDominoData.initialBasePosition;
                        const modelPivotOffsetY = selectedDominoData.mesh.userData.modelPivotToBottomY || 0;
                        
                        selectedDominoData.mesh.position.set(basePos.x, basePos.y - modelPivotOffsetY, basePos.z);
                        selectedDominoData.mesh.quaternion.copy(selectedDominoData.initialQuat);
                        
                        selectedDominoData.body.position.set(basePos.x, basePos.y + DOMINO_TALL / 2, basePos.z);
                        selectedDominoData.body.quaternion.copy(selectedDominoData.initialQuat);
                        
                        setEmissive(selectedDominoData, SELECT_COLOR, 1.5); // Re-select
                        if (rotationArrowSprite) {
                            scene.remove(rotationArrowSprite);
                            rotationArrowSprite.visible = false;
                        }
                        if (selectedDominoData.userData && selectedDominoData.userData.collisionHelper) {
                            selectedDominoData.userData.collisionHelper.position.copy(selectedDominoData.body.position);
                            selectedDominoData.userData.collisionHelper.quaternion.copy(selectedDominoData.body.quaternion);
                        }
                    }
                    translationMode = false; rotationMode = false;
                    isMoving = false; isRotating = false;
                    modeCancelled = true;
                } else if (isSelectingSimulationDirection) {
                    clearSimulationArrows();
                    showNotification("Simulation direction selection canceled.");
                    // No need to set modeCancelled, clearSimulationArrows handles UI reset
                    return; // Exit early
                }

                if (modeCancelled) {
                    document.body.style.cursor = 'default';
                    controls.enabled = true;
                    showNotification("Action canceled.");
                } else if (!isSimulating) { // If nothing else to cancel, deselect
                    selectDomino(null);
                }
                return; // Escape handled
            }

            // Shortcuts for selected domino (if not in other modes)
            if (selectedDominoData && !translationMode && !rotationMode && !isSelectingSimulationDirection && !isSimulating) {
                switch (key) {
                    case 'delete':
                    case 'backspace':
                        deleteSelectedDomino();
                        break;
                    case 't': // Translate
                        document.getElementById('context-move').onclick = () => { // Simulate context menu click
                            translationMode = true; rotationMode = false; isMoving = true; isRotating = false;
                            lastMousePosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 }; // Center mouse for start
                            showNotification("Move: Domino follows mouse. Left-click to fix. Esc to cancel.");
                            document.body.style.cursor = 'move'; controls.enabled = false; hideContextMenu();
                        };
                        document.getElementById('context-move').onclick(); // Trigger it
                        document.getElementById('context-move').onclick = null; // Clean up
                        break;
                    case 'r': // Rotate
                         document.getElementById('context-rotate').onclick = () => { // Simulate context menu click
                            rotationMode = true; translationMode = false; isRotating = true; isMoving = false;
                            lastMousePosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
                            showNotification("Rotate: Drag mouse horizontally. Left-click to fix. Esc to cancel.");
                            document.body.style.cursor = 'ew-resize'; controls.enabled = false;
                            animateRotation(selectedDominoData); hideContextMenu();
                        };
                        document.getElementById('context-rotate').onclick();
                        document.getElementById('context-rotate').onclick = null;
                        break;
                }
            }

            // Global shortcuts
            switch (key) {
                case 'g': // Toggle Grid
                    if (!translationMode && !rotationMode && !isAddingDomino && !isSimulating) { // Prevent toggle during interactions
                        const cb = document.getElementById('toggle-grid');
                        cb.checked = !cb.checked;
                        grid.visible = cb.checked;
                    }
                    break;
                case ' ': // Spacebar to start simulation
                    if (!isSimulating && !translationMode && !rotationMode && !isAddingDomino && !isSelectingSimulationDirection) {
                        if (dominoData.length > 0) {
                           startSimulation(); // Will use selected domino or prompt if none
                        } else {
                            showNotification("Add dominoes before starting simulation.", true);
                        }
                        event.preventDefault(); // Prevent spacebar from scrolling page
                    }
                    break;
            }
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        const pulseSpeed = 5; // For pulsing simulation arrows
        const pulseMagnitude = 0.1;
        const fixedTimeStep = 1 / 60; // Increased physics simulation frequency
        const maxSubSteps = 10;      // Max physics substeps per frame

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.1); // Cap delta time

            if (isSimulating) {
                world.step(fixedTimeStep, deltaTime, maxSubSteps);
            }

            // Pulse hovered simulation arrow
            if (hoveredSimulationArrow && hoveredSimulationArrow.userData.isPulsing) {
                hoveredSimulationArrow.userData.pulseTime += deltaTime * pulseSpeed;
                const scale = 1 + Math.sin(hoveredSimulationArrow.userData.pulseTime) * pulseMagnitude;
                if (hoveredSimulationArrow.cone) hoveredSimulationArrow.cone.scale.set(scale, scale, scale);
            }
            
            // Update visual dominoes from physics bodies
            dominoData.forEach((data) => {
                const body = data.body;
                const mesh = data.mesh;
                const modelPivotToBottomY_offset = mesh.userData.modelPivotToBottomY || 0;

                // Sync quaternion
                mesh.quaternion.copy(body.quaternion);

                // ***** CORRECTED POSITIONING LOGIC *****
                // The goal is to position the mesh's pivot point such that its visual bottom
                // aligns with the physics body's conceptual bottom, considering orientation.

                // 1. Vector from physics body's CoM to its conceptual bottom in its local space:
                //    (0, -DOMINO_TALL / 2, 0)
                // 2. Vector from mesh's pivot to its visual bottom in its local space:
                //    (0, modelPivotToBottomY_offset, 0)
                //    (modelPivotToBottomY_offset is scaledBox.min.y, e.g., -H/2 if pivot at center, 0 if pivot at bottom)

                // We want: mesh_pivot_world + R * v_mesh_bottom_local = body_CoM_world + R * v_body_bottom_local
                // So: mesh_pivot_world = body_CoM_world + R * (v_body_bottom_local - v_mesh_bottom_local)
                
                // Calculate (v_body_bottom_local - v_mesh_bottom_local)
                const localOffsetToPivot = new THREE.Vector3(
                    0,
                    (-DOMINO_TALL / 2) - modelPivotToBottomY_offset,
                    0
                );

                // Rotate this local offset by the current orientation
                const worldOffsetToPivot = localOffsetToPivot.clone().applyQuaternion(mesh.quaternion); // or body.quaternion

                // Set mesh pivot position: body's CoM + rotated offset
                mesh.position.copy(body.position).add(worldOffsetToPivot);
            });

            controls.update(); // If damping enabled
            renderer.render(scene, camera);
        }

        // --- Initialization ---
        console.log("Initializing Domino Simulator...");
        initEventListeners();
        animate(); // Start the animation loop
        console.log("Initialization Complete.");
    </script>
</body>
</html>
