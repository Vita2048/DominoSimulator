<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domino Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: #333;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: default;
        }
        #toolbar {
            position: absolute; top: 0; left: 0; width: 200px; height: 100%;
            background-color: rgba(255, 255, 255, 0.85); border-right: 1px solid #ccc;
            padding: 20px; box-sizing: border-box; display: flex; flex-direction: column;
            z-index: 10; box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;
        }
        .toolbar-title { font-size: 18px; font-weight: bold; margin-bottom: 20px; text-align: center; }
        .toolbar-section { margin-bottom: 20px; }
        .toolbar-section-title { font-size: 14px; font-weight: bold; margin-bottom: 10px; color: #555; }
        .toolbar-button { display: flex; align-items: center; padding: 8px 12px; margin-bottom: 8px; background-color: #f5f5f5; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        .toolbar-button:hover { background-color: #e0e0e0; }
        .toolbar-button.active { background-color: #d0d0d0; }
        .toolbar-button-icon { width: 24px; height: 24px; margin-right: 8px; display: flex; align-items: center; justify-content: center; }
        .toolbar-button.start { background-color: #e6ffe6; }
        .toolbar-button.start:hover { background-color: #d6efd6; }
        .toolbar-button.reset { background-color: #fff0e6; }
        .toolbar-button.reset:hover { background-color: #f5e6d6; }
        .toolbar-button.clear { background-color: #ffe6e6; }
        .toolbar-button.clear:hover { background-color: #f5d6d6; }
        .draggable-domino { width: 40px; height: 80px; background-color: #fff; border: 2px solid #333; margin: 10px auto; border-radius: 4px; cursor: grab; display: flex; align-items: center; justify-content: center; }
        .draggable-domino:active { cursor: grabbing; }
        .checkbox-container { display: flex; align-items: center; margin-bottom: 8px; }
        .checkbox-container input { margin-right: 8px; }
        #corner-panel { position: absolute; top: 20px; right: 20px; background-color: rgba(255, 255, 255, 0.8); border-radius: 4px; padding: 10px; display: flex; flex-direction: column; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); z-index: 10; }
        #corner-panel button { margin-bottom: 8px; padding: 8px 12px; background-color: #f5f5f5; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        #corner-panel button:hover { background-color: #e0e0e0; }
        #help-button { width: 24px; height: 24px; background-color: #f0f0f0; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-top: 10px; align-self: center; }
        #modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 100; }
        #help-modal { background-color: white; padding: 20px; border-radius: 8px; max-width: 500px; width: 80%; max-height: 80%; overflow-y: auto; }
        #help-modal h2 { margin-top: 0; }
        #close-modal { float: right; background: none; border: none; font-size: 18px; cursor: pointer; }
        #notification { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7); color: white; padding: 10px 20px; border-radius: 4px; font-size: 14px; opacity: 0; transition: opacity 0.3s; z-index: 30; }
        #custom-context-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            padding: 5px 0;
            z-index: 1000;
            display: none;
            min-width: 120px;
        }
        #custom-context-menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #custom-context-menu li {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
        }
        #custom-context-menu li:hover {
            background-color: #f0f0f0;
        }
        #custom-context-menu li.separator {
            height: 1px;
            background-color: #eee;
            margin: 5px 0;
            padding: 0;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="toolbar">
        <div class="toolbar-title">Domino Simulator</div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Add Domino</div>
            <div class="draggable-domino" id="domino-template">
                <svg width="20" height="40" viewBox="0 0 20 40"><rect x="2" y="2" width="16" height="36" fill="white" stroke="black" stroke-width="1"/><circle cx="10" cy="10" r="2" fill="black"/><circle cx="10" cy="30" r="2" fill="black"/></svg>
            </div>
        </div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Simulation</div>
            <div class="toolbar-button start" id="start-button"><div class="toolbar-button-icon"><svg viewBox="0 0 24 24" width="20" height="20"><polygon points="5,3 19,12 5,21" fill="green"/></svg></div><span>Start Simulation</span></div>
            <div class="toolbar-button reset" id="reset-button"><div class="toolbar-button-icon"><svg viewBox="0 0 24 24" width="20" height="20"><path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z" fill="#ff9800"/></svg></div><span>Reset Scene</span></div>
            <div class="toolbar-button clear" id="clear-button"><div class="toolbar-button-icon"><svg viewBox="0 0 24 24" width="20" height="20"><path d="M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19M8,9H16V19H8V9M15.5,4L14.5,3H9.5L8.5,4H5V6H19V4H15.5Z" fill="#f44336"/></svg></div><span>Clear Canvas</span></div>
        </div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Display</div>
            <div class="checkbox-container"><input type="checkbox" id="toggle-grid" checked><label for="toggle-grid">Show Grid</label></div>
        </div>
    </div>
    <div id="corner-panel">
        <button id="toggle-orbit">Lock Camera</button>
        <button id="reset-camera">Reset Camera</button>
        <div id="help-button">?</div>
    </div>
    <div id="custom-context-menu">
        <ul>
            <li id="context-move">Move (T)</li>
            <li id="context-rotate">Rotate (R)</li>
            <li class="separator"></li>
            <li id="context-start-simulation">Start Simulation (Space)</li>
            <li class="separator"></li>
            <li id="context-delete">Delete (Del)</li>
        </ul>
    </div>
    <div id="notification"></div>
    <div id="modal-overlay">
        <div id="help-modal">
            <button id="close-modal">Ã—</button>
            <h2>Domino Simulator Help</h2>
            <h3>Controls</h3>
            <ul>
                <li><strong>Add Domino:</strong> Drag from the toolbar to the canvas (snaps to grid)</li>
                <li><strong>Select:</strong> Left-click on a domino</li>
                <li><strong>Hover:</strong> Mouse over a domino to highlight blue</li>
                <li><strong>Move (T):</strong> Right-click domino -> Move, then left-click & drag</li>
                <li><strong>Rotate (R):</strong> Right-click domino -> Rotate, then left-click & drag horizontally</li>
                <li><strong>Delete (Del):</strong> Right-click domino -> Delete, or select domino and press Delete/Backspace key</li>
                <li><strong>Start Simulation (Space):</strong> Click the green play button or press Spacebar</li>
                <li><strong>Reset:</strong> Click the reset button</li>
                <li><strong>Clear:</strong> Remove all dominoes</li>
                <li><strong>Toggle Grid (G):</strong> Checkbox in the toolbar or press G</li>
                <li><strong>Context Menu:</strong> Right-click on a domino for options</li>
            </ul>
            <h3>Camera Controls</h3>
            <ul>
                <li><strong>Rotate View:</strong> Left-click and drag on empty space</li>
                <li><strong>Pan:</strong> Right-click and drag or Middle mouse button drag on empty space</li>
                <li><strong>Zoom:</strong> Scroll with mouse wheel</li>
                <li><strong>Lock Camera:</strong> Toggle button in top-right</li>
                <li><strong>Reset Camera:</strong> Button in top-right</li>
            </ul>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // --- Constants ---
        const DOMINO_TALL = 4;
        const DOMINO_WIDE = 2;
        const DOMINO_THICK = 0.5;
        const PLANE_SIZE = 100;
        const GRID_SIZE = 100;
        const GRID_DIVISIONS = 100;
        const GRID_UNIT_SIZE = 1;
        const MIN_PLACEMENT_DISTANCE = 1;
        const SELECT_COLOR = 0x555555;
        const HOVER_COLOR = 0x0055ff;
        const COLLISION_COLOR = 0xff0000;

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xE0E0E0);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 30);
        camera.lookAt(0, 0, 0);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(20, 35, 25);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096;
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 100;
        directionalLight.shadow.camera.left = -PLANE_SIZE / 2;
        directionalLight.shadow.camera.right = PLANE_SIZE / 2;
        directionalLight.shadow.camera.top = PLANE_SIZE / 2;
        directionalLight.shadow.camera.bottom = -PLANE_SIZE / 2;
        directionalLight.shadow.bias = -0.0005;
        scene.add(directionalLight);

        // --- Physics ---
        const world = new CANNON.World();
        world.gravity.set(0, -9.82 * 1.5, 0);
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.solver.iterations = 15;
        world.allowSleep = true;
        const groundPhysMaterial = new CANNON.Material("groundMaterial");
        const dominoPhysMaterial = new CANNON.Material("dominoMaterial");
        const groundDominoContactMaterial = new CANNON.ContactMaterial(groundPhysMaterial, dominoPhysMaterial, { friction: 0.4, restitution: 0.1 });
        world.addContactMaterial(groundDominoContactMaterial);
        const dominoDominoContactMaterial = new CANNON.ContactMaterial(dominoPhysMaterial, dominoPhysMaterial, { friction: 0.2, restitution: 0.2 });
        world.addContactMaterial(dominoDominoContactMaterial);

        // --- Ground ---
        const groundGeometry = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0xbbbbbb, roughness: 0.8, metalness: 0.2 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        ground.name = "Ground";
        scene.add(ground);
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, material: groundPhysMaterial });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(groundBody);

        // --- Grid Helper ---
        const grid = new THREE.GridHelper(GRID_SIZE, GRID_DIVISIONS, 0x666666, 0xaaaaaa);
        grid.position.y = 0.01;
        grid.material.opacity = 0.6;
        grid.material.transparent = true;
        grid.visible = true;
        scene.add(grid);

        // --- Controls ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 80;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;

        // --- State Variables ---
        let dominoes = [];
        let dominoData = [];
        let selectedDominoData = null;
        let hoveredDominoData = null;
        let isDraggingDomino = false;
        let isSimulating = false;
        let isAddingDomino = false;
        let previewDomino = null;
        let lastMousePosition = { x: 0, y: 0 };
        let translationMode = false;
        let rotationMode = false;
        let isMoving = false;
        let isRotating = false;
        let initialRotationY = 0;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const contextMenu = document.getElementById('custom-context-menu');
        let isSelectingSimulationDirection = false;
        let simulationTargetData = null;

        // --- Domino Creation ---
        function createPreviewDomino() {
            const geometry = new THREE.BoxGeometry(DOMINO_WIDE, DOMINO_TALL, DOMINO_THICK);
            const material = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.6, roughness: 0.8 });
            previewDomino = new THREE.Mesh(geometry, material);
            previewDomino.castShadow = true;
            previewDomino.visible = false;
            scene.add(previewDomino);
        }

        function createDomino(position, rotationY = 0) {
            const geometry = new THREE.BoxGeometry(DOMINO_WIDE, DOMINO_TALL, DOMINO_THICK);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7, metalness: 0.1 });
            const dominoMesh = new THREE.Mesh(geometry, baseMaterial);
            dominoMesh.position.copy(position);
            dominoMesh.rotation.y = rotationY;
            dominoMesh.castShadow = true;
            dominoMesh.receiveShadow = true;
            dominoMesh.userData.isDomino = true;
            scene.add(dominoMesh);
            addDominoFaces(dominoMesh);

            const shape = new CANNON.Box(new CANNON.Vec3(DOMINO_WIDE / 2, DOMINO_TALL / 2, DOMINO_THICK / 2));
            const dominoBody = new CANNON.Body({
                mass: 0.15, position: new CANNON.Vec3().copy(position), shape: shape,
                material: dominoPhysMaterial, linearDamping: 0.05, angularDamping: 0.05
            });
            dominoBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotationY);
            dominoBody.allowSleep = true;
            dominoBody.sleepSpeedLimit = 0.1;
            dominoBody.sleepTimeLimit = 0.8;
            dominoMesh.userData.body = dominoBody;
            dominoBody.userData = { mesh: dominoMesh };

            const data = { mesh: dominoMesh, body: dominoBody, initialPos: position.clone(), initialQuat: dominoBody.quaternion.clone() };
            dominoData.push(data);
            dominoes.push(dominoMesh);
            world.addBody(dominoBody);
            return data;
        }

        function addDominoFaces(dominoMesh) {
            if (Array.isArray(dominoMesh.material)) return;
            const canvas = document.createElement('canvas');
            const size = 128; canvas.width = size; canvas.height = size * (DOMINO_TALL / DOMINO_WIDE);
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#cccccc'; ctx.lineWidth = 2; ctx.strokeRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#aaaaaa'; ctx.fillRect(0, canvas.height / 2 - 1, canvas.width, 2);
            ctx.fillStyle = 'black'; const dotRadius = canvas.width * 0.1;
            ctx.beginPath(); ctx.arc(canvas.width * 0.5, canvas.height * 0.25, dotRadius, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(canvas.width * 0.25, canvas.height * 0.75, dotRadius, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(canvas.width * 0.75, canvas.height * 0.75, dotRadius, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(canvas.width * 0.5, canvas.height * 0.75, dotRadius, 0, Math.PI * 2); ctx.fill();
            const texture = new THREE.CanvasTexture(canvas); texture.needsUpdate = true;
            const faceMaterial = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.7, metalness: 0.1, color: 0xffffff });
            const existingMaterial = dominoMesh.material;
            dominoMesh.material = [
                existingMaterial.clone(), existingMaterial.clone(), existingMaterial.clone(), existingMaterial.clone(),
                faceMaterial, faceMaterial.clone()
            ];
            dominoMesh.material.needsUpdate = true;
        }

        // --- Collision & Placement ---
        function snapToGrid(position) {
            const snappedX = Math.round(position.x / GRID_UNIT_SIZE) * GRID_UNIT_SIZE;
            const snappedZ = Math.round(position.z / GRID_UNIT_SIZE) * GRID_UNIT_SIZE;
            return new THREE.Vector3(snappedX, position.y, snappedZ);
        }

        function checkDominoCollision(position, excludeData = null) {
            const snappedPos = snapToGrid(position);
            for (const data of dominoData) {
                if (data === excludeData) continue;
                const dx = data.mesh.position.x - snappedPos.x;
                const dz = data.mesh.position.z - snappedPos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance <= MIN_PLACEMENT_DISTANCE) {
                    return true;
                }
            }
            return false;
        }

        function mouseToWorld(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(ground);
            return intersects.length > 0 ? intersects[0].point : null;
        }

        // --- Highlighting ---
        function setEmissive(dominoData, color = 0x000000) {
            if (!dominoData || !dominoData.mesh) return;
            const mesh = dominoData.mesh;
            if (Array.isArray(mesh.material)) {
                mesh.material.forEach(m => { if (m.emissive) m.emissive.setHex(color); });
            } else if (mesh.material.emissive) {
                mesh.material.emissive.setHex(color);
            }
        }

        function updateHoverEffect(event) {
            if (isDraggingDomino || isAddingDomino || isSimulating) {
                if (hoveredDominoData) {
                    if (hoveredDominoData !== selectedDominoData) {
                        setEmissive(hoveredDominoData, 0x000000);
                    }
                    hoveredDominoData = null;
                }
                return;
            }
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(dominoes);
            let currentlyHovered = null;
            if (intersects.length > 0 && intersects[0].object.userData.isDomino) {
                currentlyHovered = dominoData.find(data => data.mesh === intersects[0].object);
            }
            if (currentlyHovered !== hoveredDominoData) {
                if (hoveredDominoData && hoveredDominoData !== selectedDominoData) {
                    setEmissive(hoveredDominoData, 0x000000);
                }
                if (currentlyHovered && currentlyHovered !== selectedDominoData) {
                    setEmissive(currentlyHovered, HOVER_COLOR);
                }
                hoveredDominoData = currentlyHovered;
            }
        }

        // --- Selection & Manipulation ---
        function selectDomino(dataToSelect) {
            if (selectedDominoData) {
                setEmissive(selectedDominoData, 0x000000);
            }
            if (hoveredDominoData === dataToSelect) {
                setEmissive(hoveredDominoData, 0x000000);
                hoveredDominoData = null;
            }
            selectedDominoData = dataToSelect;
            if (!dataToSelect) {
                scene.children.filter(child => child.isSimulationArrow || child.isGlowSprite).forEach(child => {
                    scene.remove(child);
                    if (child.material.map) child.material.map.dispose();
                    child.material.dispose();
                    child.geometry.dispose();
                });
                isSelectingSimulationDirection = false;
                simulationTargetData = null;
            }
            if (selectedDominoData) {
                setEmissive(selectedDominoData, SELECT_COLOR);
            } else {
                translationMode = false;
                rotationMode = false;
                isMoving = false;
                isRotating = false;
                document.body.style.cursor = 'default';
                if (hoveredDominoData) {
                    setEmissive(hoveredDominoData, HOVER_COLOR);
                }
            }
            hideContextMenu();
        }

        function createRotationArrows() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 6;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(64, 64, 40, Math.PI * 0.75, Math.PI * 1.75, false);
            ctx.stroke();
            drawArrowhead(ctx, 64, 64, 40, Math.PI * 1.75, false);
            ctx.beginPath();
            ctx.arc(64, 64, 40, Math.PI * 1.25, Math.PI * 0.25, true);
            ctx.stroke();
            drawArrowhead(ctx, 64, 64, 40, Math.PI * 0.25, true);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            const material = new THREE.SpriteMaterial({ map: texture, color: 0xffffff, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(2, 2, 1);
            sprite.visible = false;
            sprite.isRotationArrow = true;
            return sprite;
        }

        function drawArrowhead(ctx, cx, cy, radius, theta, isCounterclockwise) {
            const tangentX = isCounterclockwise ? Math.sin(theta) : -Math.sin(theta);
            const tangentY = isCounterclockwise ? -Math.cos(theta) : Math.cos(theta);
            const arrowSize = 10;
            const endPointX = cx + radius * Math.cos(theta);
            const endPointY = cy + radius * Math.sin(theta);
            const tipX = endPointX + arrowSize * tangentX;
            const tipY = endPointY + arrowSize * tangentY;
            const base1X = endPointX - arrowSize * 0.5 * tangentX + arrowSize * 0.866 * (isCounterclockwise ? -tangentY : tangentY);
            const base1Y = endPointY - arrowSize * 0.5 * tangentY + arrowSize * 0.866 * (isCounterclockwise ? tangentX : -tangentX);
            const base2X = endPointX - arrowSize * 0.5 * tangentX - arrowSize * 0.866 * (isCounterclockwise ? -tangentY : tangentY);
            const base2Y = endPointY - arrowSize * 0.5 * tangentY - arrowSize * 0.866 * (isCounterclockwise ? tangentX : -tangentX);
            ctx.beginPath();
            ctx.moveTo(tipX, tipY);
            ctx.lineTo(base1X, base1Y);
            ctx.lineTo(base2X, base2Y);
            ctx.closePath();
            ctx.fillStyle = '#ff0000';
            ctx.fill();
        }

        function animateRotation(data) {
            if (!data) return;
            const mesh = data.mesh;
            const body = data.body;
            const q = data.initialQuat;
            const siny_cosp = 2 * (q.w * q.y + q.x * q.z);
            const cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
            const originalRotationY = Math.atan2(siny_cosp, cosy_cosp);
            const maxAngle = Math.PI / 4;
            let totalRotationOffset = 0;
            const arrowSprite = createRotationArrows();
            arrowSprite.position.set(mesh.position.x, mesh.position.y + DOMINO_TALL / 2 + 1, mesh.position.z);
            arrowSprite.rotation.x = -Math.PI / 2;
            arrowSprite.visible = true;
            scene.add(arrowSprite);
            function updateRotation(event) {
                if (!rotationMode || !data.mesh || data !== selectedDominoData) {
                    document.removeEventListener('mousemove', updateRotation);
                    scene.remove(arrowSprite);
                    if (arrowSprite.material.map) arrowSprite.material.map.dispose();
                    arrowSprite.material.dispose();
                    arrowSprite.geometry.dispose();
                    return;
                }
                const deltaX = event.clientX - lastMousePosition.x;
                const rotationSpeed = 0.05;
                totalRotationOffset += deltaX * rotationSpeed;
                totalRotationOffset = Math.max(-maxAngle, Math.min(maxAngle, totalRotationOffset));
                const newRotationY = originalRotationY + totalRotationOffset;
                mesh.rotation.y = newRotationY;
                body.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), newRotationY);
                arrowSprite.position.set(mesh.position.x, mesh.position.y + DOMINO_TALL / 2 + 1, mesh.position.z);
                lastMousePosition = { x: event.clientX, y: event.clientY };
            }
            document.addEventListener('mousemove', updateRotation);
        }

        function createArrowSprite(direction) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ff0000';
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 6;
            if (direction === 'left') {
                ctx.beginPath();
                ctx.moveTo(60, 16);
                ctx.lineTo(20, 4);
                ctx.lineTo(20, 12);
                ctx.lineTo(4, 12);
                ctx.lineTo(4, 20);
                ctx.lineTo(20, 20);
                ctx.lineTo(20, 28);
                ctx.closePath();
            } else {
                ctx.beginPath();
                ctx.moveTo(4, 16);
                ctx.lineTo(44, 4);
                ctx.lineTo(44, 12);
                ctx.lineTo(60, 12);
                ctx.lineTo(60, 20);
                ctx.lineTo(44, 20);
                ctx.lineTo(44, 28);
                ctx.closePath();
            }
            ctx.fill();
            ctx.stroke();
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            const material = new THREE.SpriteMaterial({ map: texture, color: 0xffffff, transparent: true });
            const arrowSprite = new THREE.Sprite(material);
            arrowSprite.scale.set(1, 0.5, 1);
            arrowSprite.visible = false;
            arrowSprite.userData = { direction: direction === 'left' ? 'front' : 'back' };
            arrowSprite.isSimulationArrow = true;
            arrowSprite.renderOrder = 0;
            const glowCanvas = document.createElement('canvas');
            glowCanvas.width = 64;
            glowCanvas.height = 32;
            const glowCtx = glowCanvas.getContext('2d');
            glowCtx.fillStyle = 'rgba(0, 0, 255, 0.3)';
            glowCtx.fillRect(0, 0, 64, 32);
            const glowTexture = new THREE.CanvasTexture(glowCanvas);
            glowTexture.needsUpdate = true;
            const glowMaterial = new THREE.SpriteMaterial({ map: glowTexture, color: 0xffffff, transparent: true });
            const glowSprite = new THREE.Sprite(glowMaterial);
            glowSprite.scale.set(1.2, 0.6, 1);
            glowSprite.visible = false;
            glowSprite.isGlowSprite = true;
            glowSprite.renderOrder = 1;
            return { arrow: arrowSprite, glow: glowSprite };
        }

        // --- Context Menu Logic ---
        function showContextMenu(event, targetData) {
            hideContextMenu();
            selectDomino(targetData);
            contextMenu.style.left = `${event.clientX}px`;
            contextMenu.style.top = `${event.clientY}px`;
            contextMenu.style.display = 'block';

            document.getElementById('context-move').onclick = () => {
                translationMode = true;
                rotationMode = false;
                isRotating = false;
                isMoving = true;
                lastMousePosition = { x: event.clientX, y: event.clientY };
                showNotification("Move: Domino follows mouse. Click to fix position.");
                hideContextMenu();
                document.body.style.cursor = 'move';
                controls.enabled = false;
            };

            document.getElementById('context-rotate').onclick = () => {
                rotationMode = true;
                translationMode = false;
                isMoving = false;
                isRotating = true;
                lastMousePosition = { x: event.clientX, y: event.clientY };
                showNotification("Rotate: Move mouse horizontally to rotate (Â±45Â°). Click to fix rotation.");
                hideContextMenu();
                document.body.style.cursor = 'ew-resize';
                controls.enabled = false;
                animateRotation(targetData);
            };

            document.getElementById('context-start-simulation').onclick = () => {
                if (!targetData) return;
                hideContextMenu();
                scene.children.filter(child => child.isSimulationArrow || child.isGlowSprite).forEach(child => {
                    scene.remove(child);
                    if (child.material.map) child.material.map.dispose();
                    child.material.dispose();
                    child.geometry.dispose();
                });
                const frontArrowObj = createArrowSprite('left'); // Using 'left' texture for front
                const backArrowObj = createArrowSprite('right'); // Using 'right' texture for back
                const frontArrow = frontArrowObj.arrow;
                const backArrow = backArrowObj.arrow;
                const frontGlow = frontArrowObj.glow;
                const backGlow = backArrowObj.glow;
                const dominoPos = targetData.mesh.position;
                const dominoQuat = targetData.mesh.quaternion;
                const gap = 0.2;
                const arrowWidth = 1;
                const arrowOffset = DOMINO_THICK / 2 + gap + arrowWidth / 2; // 0.25 + 0.2 + 0.5 = 0.95
                const localFront = new THREE.Vector3(0, 0, arrowOffset);
                const localBack = new THREE.Vector3(0, 0, -arrowOffset);
                const worldFront = localFront.clone().applyQuaternion(dominoQuat).add(dominoPos);
                const worldBack = localBack.clone().applyQuaternion(dominoQuat).add(dominoPos);
                frontArrow.position.copy(worldFront);
                backArrow.position.copy(worldBack);
                frontGlow.position.copy(worldFront);
                backGlow.position.copy(worldBack);
                scene.add(frontArrow);
                scene.add(backArrow);
                scene.add(frontGlow);
                scene.add(backGlow);
                frontArrow.visible = true;
                backArrow.visible = true;
                frontArrow.userData.glowSprite = frontGlow;
                backArrow.userData.glowSprite = backGlow;
                showNotification("Click an arrow to start simulation (front/back).");
                isSelectingSimulationDirection = true;
                simulationTargetData = targetData;
                controls.enabled = false;
            };

            document.getElementById('context-delete').onclick = () => {
                deleteSelectedDomino();
                hideContextMenu();
            };
        }

        function deleteSelectedDomino() {
            if (!selectedDominoData) return;
            const dataToDelete = selectedDominoData; selectDomino(null);
            scene.remove(dataToDelete.mesh); if (world.bodies.includes(dataToDelete.body)) world.removeBody(dataToDelete.body);
            const meshIndex = dominoes.indexOf(dataToDelete.mesh); if (meshIndex > -1) dominoes.splice(meshIndex, 1);
            const dataIndex = dominoData.indexOf(dataToDelete); if (dataIndex > -1) dominoData.splice(dataIndex, 1);
            if (dataToDelete.mesh.geometry) dataToDelete.mesh.geometry.dispose();
            if (dataToDelete.mesh.material) { if (Array.isArray(dataToDelete.mesh.material)) { dataToDelete.mesh.material.forEach(m => { if (m.map) m.map.dispose(); m.dispose(); }); } else { if (dataToDelete.mesh.material.map) dataToDelete.mesh.material.map.dispose(); dataToDelete.mesh.material.dispose(); } }
            showNotification('Domino Deleted');
        }

        function hideContextMenu() {
            contextMenu.style.display = 'none';
            document.getElementById('context-move').onclick = null;
            document.getElementById('context-rotate').onclick = null;
            document.getElementById('context-delete').onclick = null;
            if (!translationMode && !rotationMode && !isMoving && !isRotating) {
                document.body.style.cursor = 'default';
            }
        }

        // --- Simulation Control ---
        function startSimulation() {
            if (dominoData.length === 0) return;
            isSimulating = true;
            const firstDomino = dominoData[0];
            const forceMagnitude = 0.5;
            const forcePoint = new CANNON.Vec3(firstDomino.body.position.x, firstDomino.body.position.y + DOMINO_TALL / 2, firstDomino.body.position.z);
            const force = new CANNON.Vec3(forceMagnitude, 0, 0);
            firstDomino.body.applyImpulse(force, forcePoint);
            showNotification("Simulation started!");
        }

        function resetSimulation() {
            isSimulating = false;
            controls.enabled = true;
            world.allowSleep = true;
            hideContextMenu();

            // Remove all domino physics bodies from the world
            dominoData.forEach(data => {
                if (world.bodies.includes(data.body)) {
                    world.removeBody(data.body);
                }
            });

            // Recreate domino physics bodies with initial positions and quaternions
            dominoData.forEach(data => {
                const shape = new CANNON.Box(new CANNON.Vec3(DOMINO_WIDE / 2, DOMINO_TALL / 2, DOMINO_THICK / 2));
                const dominoBody = new CANNON.Body({
                    mass: 0.15,
                    position: data.initialPos.clone(),
                    shape: shape,
                    material: dominoPhysMaterial,
                    linearDamping: 0.05,
                    angularDamping: 0.05
                });
                dominoBody.quaternion.copy(data.initialQuat);
                dominoBody.allowSleep = true;
                dominoBody.sleepSpeedLimit = 0.1;
                dominoBody.sleepTimeLimit = 0.8;
                dominoBody.velocity.set(0, 0, 0);
                dominoBody.angularVelocity.set(0, 0, 0);
                data.body = dominoBody;
                data.mesh.userData.body = dominoBody; // Update mesh reference
                dominoBody.userData = { mesh: data.mesh }; // Update body reference
                world.addBody(dominoBody);
            });

            // Reset mesh positions and quaternions
            dominoData.forEach(data => {
                data.mesh.position.copy(data.initialPos);
                data.mesh.quaternion.copy(data.initialQuat);
                setEmissive(data, 0x000000);
            });

            selectDomino(null);
            hoveredDominoData = null;
            showNotification('Simulation Reset');
        }

        function clearCanvas() {
            resetSimulation();
            dominoData.forEach(data => {
                scene.remove(data.mesh); if (world.bodies.includes(data.body)) world.removeBody(data.body);
                if (data.mesh.geometry) data.mesh.geometry.dispose();
                if (data.mesh.material) { if (Array.isArray(data.mesh.material)) { data.mesh.material.forEach(m => { if (m.map) m.map.dispose(); m.dispose(); }); } else { if (data.mesh.material.map) data.mesh.material.map.dispose(); data.mesh.material.dispose(); } }
            });
            dominoes = []; dominoData = []; selectedDominoData = null; hoveredDominoData = null;
            showNotification('Canvas Cleared');
        }

        // --- UI Helpers ---
        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.opacity = '1';
            setTimeout(() => { notification.style.opacity = '0'; }, 2000);
        }

        function toggleOrbitControls() {
            controls.enabled = !controls.enabled;
            document.getElementById('toggle-orbit').textContent = controls.enabled ? 'Lock Camera' : 'Unlock Camera';
        }

        // --- Event Listeners Setup ---
        function initEventListeners() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                hideContextMenu();
            });
            const canvasContainer = document.getElementById('canvas-container');
            canvasContainer.addEventListener('mousedown', onMouseDown, false);
            canvasContainer.addEventListener('mousemove', onMouseMove, false);
            canvasContainer.addEventListener('mouseup', onMouseUp, false);
            canvasContainer.addEventListener('contextmenu', onContextMenu, false);
            window.addEventListener('keydown', onKeyDown, false);
            window.addEventListener('mousedown', (event) => {
                if (contextMenu.style.display === 'block' && !contextMenu.contains(event.target)) {
                    hideContextMenu();
                }
            }, true);
            document.getElementById('domino-template').addEventListener('mousedown', onStartDragDominoTemplate);
            document.getElementById('start-button').addEventListener('click', startSimulation);
            document.getElementById('reset-button').addEventListener('click', resetSimulation);
            document.getElementById('clear-button').addEventListener('click', clearCanvas);
            document.getElementById('toggle-grid').addEventListener('change', (event) => { grid.visible = event.target.checked; });
            document.getElementById('toggle-orbit').addEventListener('click', toggleOrbitControls);
            document.getElementById('reset-camera').addEventListener('click', () => { controls.reset(); camera.position.set(0, 20, 30); camera.lookAt(0, 0, 0); controls.update(); });
            document.getElementById('help-button').addEventListener('click', () => { document.getElementById('modal-overlay').style.display = 'flex'; });
            document.getElementById('close-modal').addEventListener('click', () => { document.getElementById('modal-overlay').style.display = 'none'; });
            document.getElementById('modal-overlay').addEventListener('click', (event) => { if (event.target === document.getElementById('modal-overlay')) document.getElementById('modal-overlay').style.display = 'none'; });
        }

        // --- Mouse Interaction Logic ---
        function onStartDragDominoTemplate(event) {
            if (isSimulating) return;
            isAddingDomino = true; if (!previewDomino) createPreviewDomino();
            previewDomino.visible = true; controls.enabled = false; document.body.style.cursor = 'grabbing';
            hideContextMenu(); updateHoverEffect(event);
            const worldPos = mouseToWorld(event);
            if (worldPos) {
                const snappedPos = snapToGrid(worldPos); previewDomino.position.set(snappedPos.x, DOMINO_TALL / 2, snappedPos.z);
                const collision = checkDominoCollision(previewDomino.position);
                previewDomino.material.color.set(collision ? 0xff6666 : 0xffffff); previewDomino.material.opacity = collision ? 0.4 : 0.6;
            }
        }

        function onMouseDown(event) {
            if (event.button !== 0) return;
            if (isSimulating || isAddingDomino) return;
            hideContextMenu();
            const worldPos = mouseToWorld(event);
            if (!worldPos) return;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([...dominoes, ...scene.children.filter(child => child.isSimulationArrow)]);
            if (isSelectingSimulationDirection && intersects.length > 0) {
                const clickedObject = intersects[0].object;
                if (clickedObject.isSimulationArrow) {
                    const direction = clickedObject.userData.direction;
                    scene.children.filter(child => child.isSimulationArrow || child.isGlowSprite).forEach(child => {
                        scene.remove(child);
                        if (child.material.map) child.material.map.dispose();
                        child.material.dispose();
                        child.geometry.dispose();
                    });
                    if (simulationTargetData) {
                        const forceMagnitude = 0.5;
                        let localForce;
                        if (direction === 'front') {
                            localForce = new CANNON.Vec3(0, 0, forceMagnitude);
                        } else if (direction === 'back') {
                            localForce = new CANNON.Vec3(0, 0, -forceMagnitude);
                        }
                        const worldForce = simulationTargetData.body.quaternion.vmult(localForce);
                        const forcePoint = new CANNON.Vec3(
                            simulationTargetData.body.position.x,
                            simulationTargetData.body.position.y + DOMINO_TALL / 2,
                            simulationTargetData.body.position.z
                        );
                        simulationTargetData.body.applyImpulse(worldForce, forcePoint);
                        startSimulation();
                        showNotification(`Simulation started: domino falling ${direction}.`);
                    }
                    isSelectingSimulationDirection = false;
                    simulationTargetData = null;
                    document.body.style.cursor = 'default';
                    controls.enabled = true;
                    return;
                }
            }
            if (isMoving && translationMode) {
                isMoving = false;
                translationMode = false;
                document.body.style.cursor = 'default';
                controls.enabled = true;
                if (selectedDominoData) {
                    const collision = checkDominoCollision(selectedDominoData.mesh.position, selectedDominoData);
                    setEmissive(selectedDominoData, collision ? COLLISION_COLOR : SELECT_COLOR);
                    if (collision) {
                        showNotification("Warning: Domino overlaps another!");
                    } else {
                        showNotification("Position fixed.");
                    }
                }
                updateHoverEffect(event);
                return;
            }
            if (isRotating && rotationMode) {
                isRotating = false;
                rotationMode = false;
                document.body.style.cursor = 'default';
                controls.enabled = true;
                if (selectedDominoData) {
                    selectedDominoData.initialQuat.copy(selectedDominoData.body.quaternion);
                    setEmissive(selectedDominoData, SELECT_COLOR);
                    const arrowSprite = scene.getObjectByProperty('isRotationArrow', true);
                    if (arrowSprite) {
                        scene.remove(arrowSprite);
                        if (arrowSprite.material.map) arrowSprite.material.map.dispose();
                        arrowSprite.material.dispose();
                        arrowSprite.geometry.dispose();
                    }
                    showNotification("Rotation fixed.");
                }
                updateHoverEffect(event);
                return;
            }
            if (intersects.length > 0 && intersects[0].object.userData.isDomino) {
                const clickedData = dominoData.find(data => data.mesh === intersects[0].object);
                if (clickedData) {
                    selectDomino(clickedData);
                }
            } else {
                selectDomino(null);
            }
        }

        function animateGlow(glowSprite) {
            let scale = 1;
            const maxScale = 1.2;
            const minScale = 1.0;
            let speed = 0.02;
            function pulse() {
                if (!glowSprite.visible) return;
                scale += speed;
                if (scale > maxScale || scale < minScale) {
                    speed = -speed;
                }
                glowSprite.scale.set(1.2 * scale, 0.6 * scale, 1);
                requestAnimationFrame(pulse);
            }
            pulse();
        }

        function onMouseMove(event) {
            if (isSimulating) return;
            updateHoverEffect(event);
            const worldPos = mouseToWorld(event);
            if (!worldPos) return;
            const snappedPos = snapToGrid(worldPos);
            if (isAddingDomino && previewDomino) {
                previewDomino.position.set(snappedPos.x, DOMINO_TALL / 2, snappedPos.z);
                const collision = checkDominoCollision(previewDomino.position);
                previewDomino.material.color.set(collision ? 0xff6666 : 0xffffff);
                previewDomino.material.opacity = collision ? 0.4 : 0.6;
            }
            if (selectedDominoData && isMoving && translationMode) {
                const potentialPos = new THREE.Vector3(snappedPos.x, DOMINO_TALL / 2, snappedPos.z);
                const collision = checkDominoCollision(potentialPos, selectedDominoData);
                selectedDominoData.mesh.position.copy(potentialPos);
                selectedDominoData.body.position.copy(potentialPos);
                selectedDominoData.initialPos.copy(potentialPos);
                setEmissive(selectedDominoData, collision ? COLLISION_COLOR : SELECT_COLOR);
            }
            if (isSelectingSimulationDirection) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children.filter(child => child.isSimulationArrow));
                if (intersects.length > 0) {
                    document.body.style.cursor = 'pointer';
                    const arrow = intersects[0].object;
                    if (arrow.userData.glowSprite) {
                        arrow.userData.glowSprite.visible = true;
                        if (!arrow.userData.isPulsating) {
                            arrow.userData.isPulsating = true;
                            animateGlow(arrow.userData.glowSprite);
                        }
                    }
                } else {
                    document.body.style.cursor = 'default';
                    scene.children.filter(child => child.isSimulationArrow).forEach(arrow => {
                        if (arrow.userData.glowSprite) {
                            arrow.userData.glowSprite.visible = false;
                            arrow.userData.isPulsating = false;
                        }
                    });
                }
            }
        }

        function onMouseUp(event) {
            if (event.button !== 0) return;
            if (isAddingDomino && previewDomino) {
                const worldPos = mouseToWorld(event);
                if (worldPos) {
                    const snappedPos = snapToGrid(worldPos);
                    const finalPos = new THREE.Vector3(snappedPos.x, DOMINO_TALL / 2, snappedPos.z);
                    const collision = checkDominoCollision(finalPos);
                    if (!collision) {
                        createDomino(finalPos, previewDomino.rotation.y);
                    } else {
                        showNotification("Placement overlaps existing domino!");
                    }
                }
                previewDomino.visible = false;
                isAddingDomino = false;
                isDraggingDomino = false;
                document.body.style.cursor = 'default';
                controls.enabled = true;
                updateHoverEffect(event);
            }
        }

        function onContextMenu(event) {
            event.preventDefault();
            if (isSimulating || isAddingDomino || isMoving || isRotating) return;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(dominoes);
            if (intersects.length > 0 && intersects[0].object.userData.isDomino) {
                const targetData = dominoData.find(data => data.mesh === intersects[0].object);
                if (targetData) {
                    showContextMenu(event, targetData);
                }
            } else {
                hideContextMenu();
                selectDomino(null);
            }
        }

        // --- Keyboard Interaction Logic ---
        function onKeyDown(event) {
            if (isSimulating) return;
            hideContextMenu();
            if (selectedDominoData) {
                switch (event.key.toLowerCase()) {
                    case 'delete':
                    case 'backspace':
                        deleteSelectedDomino();
                        break;
                    case 't':
                        translationMode = true;
                        rotationMode = false;
                        isRotating = false;
                        isMoving = true;
                        lastMousePosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
                        showNotification("Move: Domino follows mouse. Click to fix position.");
                        document.body.style.cursor = 'move';
                        controls.enabled = false;
                        break;
                    case 'r':
                        rotationMode = true;
                        translationMode = false;
                        isMoving = false;
                        isRotating = true;
                        lastMousePosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
                        showNotification("Rotate: Move mouse horizontally to rotate (Â±45Â°). Click to fix rotation.");
                        document.body.style.cursor = 'ew-resize';
                        controls.enabled = false;
                        animateRotation(selectedDominoData);
                        break;
                    case 'escape':
                        if (isSelectingSimulationDirection) {
                            scene.children.filter(child => child.isSimulationArrow || child.isGlowSprite).forEach(child => {
                                scene.remove(child);
                                if (child.material.map) child.material.map.dispose();
                                child.material.dispose();
                                child.geometry.dispose();
                            });
                            isSelectingSimulationDirection = false;
                            simulationTargetData = null;
                            document.body.style.cursor = 'default';
                            controls.enabled = true;
                            showNotification("Simulation direction selection canceled.");
                        }
                        selectDomino(null);
                        translationMode = false;
                        rotationMode = false;
                        isMoving = false;
                        isRotating = false;
                        document.body.style.cursor = 'default';
                        controls.enabled = true;
                        break;
                }
            }
            switch (event.key.toLowerCase()) {
                case 'g':
                    const cb = document.getElementById('toggle-grid');
                    cb.checked = !cb.checked;
                    grid.visible = cb.checked;
                    break;
                case ' ':
                    if (!isSimulating && !isSelectingSimulationDirection) {
                        startSimulation();
                    }
                    event.preventDefault();
                    break;
                case 'escape':
                    hideContextMenu();
                    break;
            }
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        const fixedTimeStep = 1 / 60;
        const maxSubSteps = 5;
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.1);
            if (controls.enabled) controls.update(deltaTime);
            if (isSimulating) {
                world.step(fixedTimeStep, deltaTime, maxSubSteps);
                dominoData.forEach(data => {
                    data.mesh.position.copy(data.body.position);
                    data.mesh.quaternion.copy(data.body.quaternion);
                });
            }
            renderer.render(scene, camera);
        }

        // --- Initialization ---
        console.log("Initializing Domino Simulator...");
        createPreviewDomino();
        initEventListeners();
        animate();
        console.log("Initialization Complete.");
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'93ae8caeaf867bae',t:'MTc0NjQzMDQwNC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script><script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'93aea64a2d184546',t:'MTc0NjQzMTQ1My4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
