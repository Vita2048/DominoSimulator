<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domino Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: #333;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: default;
        }
        #toolbar {
            position: absolute; top: 0; left: 0; width: 200px; height: 100%;
            background-color: rgba(255, 255, 255, 0.85); border-right: 1px solid #ccc;
            padding: 20px; box-sizing: border-box; display: flex; flex-direction: column;
            z-index: 10; box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1); transition: transform 0.3s ease;
            overflow-y: auto; 
        }
        .toolbar-title { font-size: 18px; font-weight: bold; margin-bottom: 20px; text-align: center; }
        .toolbar-section { margin-bottom: 20px; }
        .toolbar-section-title { font-size: 14px; font-weight: bold; margin-bottom: 10px; color: #555; }
        .toolbar-button { display: flex; align-items: center; padding: 8px 12px; margin-bottom: 8px; background-color: #f5f5f5; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        .toolbar-button:hover { background-color: #e0e0e0; }
        .toolbar-button.active { background-color: #d0d0d0; }
        .toolbar-button.start { background-color: #e6ffe6; }
        .toolbar-button.start:hover { background-color: #d6efd6; }
        .toolbar-button.reset { background-color: #fff0e6; }
        .toolbar-button.reset:hover { background-color: #f5e6d6; }
        .toolbar-button.clear { background-color: #ffe6e6; }
        .toolbar-button.clear:hover { background-color: #f5d6d6; }
        .draggable-domino { width: 40px; height: 80px; background-color: #fff; border: 2px solid #333; margin: 10px auto; border-radius: 4px; cursor: grab; display: flex; align-items: center; justify-content: center; }
        .draggable-domino:active { cursor: grabbing; }
        .checkbox-container { display: flex; align-items: center; margin-bottom: 8px; }
        .checkbox-container input { margin-right: 8px; }
        #corner-panel { position: absolute; top: 20px; right: 20px; background-color: rgba(255, 255, 255, 0.8); border-radius: 4px; padding: 10px; display: flex; flex-direction: column; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); z-index: 10; }
        #corner-panel button { margin-bottom: 8px; padding: 8px 12px; background-color: #f5f5f5; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }
        #corner-panel button:hover { background-color: #e0e0e0; }
        #help-button { width: 24px; height: 24px; background-color: #f0f0f0; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-top: 10px; align-self: center; }
        #modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 100; }
        #help-modal { background-color: white; padding: 20px; border-radius: 8px; max-width: 500px; width: 80%; max-height: 80%; overflow-y: auto; }
        #help-modal h2 { margin-top: 0; }
        #close-modal { float: right; background: none; border: none; font-size: 18px; cursor: pointer; }
        #notification { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7); color: white; padding: 10px 20px; border-radius: 4px; font-size: 14px; opacity: 0; transition: opacity 0.3s; z-index: 30; }
        #custom-context-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            padding: 5px 0;
            z-index: 1000;
            display: none;
            min-width: 120px;
        }
        #custom-context-menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #custom-context-menu li {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
        }
        #custom-context-menu li:hover {
            background-color: #f0f0f0;
        }
        #custom-context-menu li.separator {
            height: 1px;
            background-color: #eee;
            margin: 5px 0;
            padding: 0;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="toolbar">
        <div class="toolbar-title">Domino Simulator</div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Add Domino</div>
            <div class="draggable-domino" id="domino-template">
                <svg width="20" height="40" viewBox="0 0 20 40"><rect x="2" y="2" width="16" height="36" fill="white" stroke="black" stroke-width="1"/><circle cx="10" cy="10" r="2" fill="black"/><circle cx="10" cy="30" r="2" fill="black"/></svg>
            </div>
        </div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Add Batch</div>
            <div class="toolbar-button" id="add-batch-button">
                <div class="toolbar-button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <rect x="4" y="6" width="4" height="12" fill="#333"/>
                        <rect x="10" y="6" width="4" height="12" fill="#333"/>
                        <rect x="16" y="6" width="4" height="12" fill="#333"/>
                    </svg>
                </div>
                <span>Add Batch Line</span>
            </div>
            <div class="toolbar-button" id="add-batch-circle-button"> <div class="toolbar-button-icon">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="8" stroke="#333" stroke-width="2" fill="none"/>
                    </svg>
                </div>
                <span>Add Batch Circle</span>
            </div>
        </div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Simulation</div>
            <div class="toolbar-button reset" id="reset-button"><div class="toolbar-button-icon"><svg viewBox="0 0 24 24" width="20" height="20"><path d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z" fill="#ff9800"/></svg></div><span>Reset Scene</span></div>
            <div class="toolbar-button clear" id="clear-button"><div class="toolbar-button-icon"><svg viewBox="0 0 24 24" width="20" height="20"><path d="M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19M8,9H16V19H8V9M15.5,4L14.5,3H9.5L8.5,4H5V6H19V4H15.5Z" fill="#f44336"/></svg></div><span>Clear Canvas</span></div>
        </div>
        <div class="toolbar-section">
            <div class="toolbar-section-title">Display</div>
            <div class="checkbox-container"><input type="checkbox" id="toggle-grid" checked><label for="toggle-grid">Show Grid</label></div>
        </div>
    </div>
    <div id="corner-panel">
        <button id="toggle-orbit">Lock Camera</button> 
        <button id="reset-camera">Reset Camera</button>
        <div id="help-button">?</div>
    </div>
    <div id="custom-context-menu">
        <ul>
            <li id="context-move">Move (T)</li>
            <li id="context-rotate">Rotate (R)</li>
            <li class="separator"></li>
            <li id="context-start-simulation">Start Simulation (Space)</li>
            <li class="separator"></li>
            <li id="context-delete">Delete (Del)</li>
        </ul>
    </div>
    <div id="notification"></div>
    <div id="modal-overlay">
        <div id="help-modal">
            <button id="close-modal">Ã—</button>
            <h2>Domino Simulator Help</h2>
            <h3>Controls</h3>
            <ul>
                <li><strong>Add Domino:</strong> Drag from the toolbar to the canvas (snaps to grid)</li>
                <li><strong>Add Batch Line:</strong> Click "Add Batch Line", enter number (2-20), drag to place</li>
                <li><strong>Add Batch Circle:</strong> Click "Add Batch Circle", enter number (20-40), drag to place center</li>
                <li><strong>Select:</strong> Left-click on a domino</li>
                <li><strong>Hover:</strong> Mouse over a domino to highlight blue</li>
                <li><strong>Move (T):</strong> Right-click domino -> Move, then left-click & drag</li>
                <li><strong>Rotate (R):</strong> Right-click domino -> Rotate, then left-click & drag horizontally</li>
                <li><strong>Delete (Del):</strong> Right-click domino -> Delete, or press Delete/Backspace</li>
                <li><strong>Start Simulation (Space):</strong> Press Spacebar or use context menu arrows</li>
                <li><strong>Reset:</strong> Click the reset button</li>
                <li><strong>Clear:</strong> Remove all dominoes</li>
                <li><strong>Toggle Grid (G):</strong> Checkbox or press G</li>
                <li><strong>Context Menu:</strong> Right-click on a domino</li>
            </ul>
            <h3>Camera Controls</h3>
            <ul>
                <li><strong>Rotate View:</strong> Left-click and drag on empty space</li>
                <li><strong>Pan:</strong> Right-click and drag or middle mouse drag</li>
                <li><strong>Zoom:</strong> Scroll with mouse wheel</li>
                <li><strong>Lock Camera:</strong> Toggle button in top-right</li>
                <li><strong>Reset Camera:</strong> Button in top-right</li>
            </ul>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script>
        // --- Constants ---
        const DOMINO_TALL = 2.01642;
        const DOMINO_WIDE = 1.01067; // Corresponds to local Z-axis of physics body
        const DOMINO_THICK = 0.258223; // Corresponds to local X-axis of physics body
        const PLANE_SIZE = 100;
        const GRID_SIZE = 100;
        const GRID_DIVISIONS = 100;
        const GRID_UNIT_SIZE = 1;
        const MIN_PLACEMENT_DISTANCE = 1; 
        const SELECT_COLOR = 0x555555;
        const HOVER_COLOR = 0x0055ff;
        const COLLISION_COLOR = 0xff0000;
        const IMPULSE_MAGNITUDE = 3.5;
        const ARROW_COLOR_DEFAULT = 0xff0000;
        const ARROW_COLOR_HOVER = 0x0077ff;

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xE0E0E0);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 30);
        camera.lookAt(0, 0, 0);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
        directionalLight.position.set(20, 35, 25);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096;
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.near = 1;
        directionalLight.shadow.camera.far = 100;
        directionalLight.shadow.camera.left = -PLANE_SIZE / 2;
        directionalLight.shadow.camera.right = PLANE_SIZE / 2;
        directionalLight.shadow.camera.top = PLANE_SIZE / 2;
        directionalLight.shadow.camera.bottom = -PLANE_SIZE / 2;
        directionalLight.shadow.bias = -0.0005;
        scene.add(directionalLight);

        // --- Physics ---
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.SAPBroadphase(world);
        world.solver.iterations = 30;
        world.solver.tolerance = 0.001;
        world.allowSleep = true;
        world.defaultContactMaterial.restitution = 0.0;
        world.defaultContactMaterial.contactEquationStiffness = 1e6;
        world.defaultContactMaterial.contactEquationRelaxation = 3;

        const groundPhysMaterial = new CANNON.Material("groundMaterial");
        const dominoPhysMaterial = new CANNON.Material("dominoMaterial");

        const groundDominoContactMaterial = new CANNON.ContactMaterial(
            groundPhysMaterial,
            dominoPhysMaterial,
            { friction: 0.01, restitution: 0.0, contactEquationStiffness: 1e5, contactEquationRelaxation: 2.0 }
        );
        world.addContactMaterial(groundDominoContactMaterial);
        const dominoDominoContactMaterial = new CANNON.ContactMaterial(
            dominoPhysMaterial,
            dominoPhysMaterial,
            {
                friction: 0.005,
                restitution: 0.0,
                contactEquationStiffness: 1e6,
                contactEquationRelaxation: 1.5,
                contactSkinSize: 0
            }
        );
        world.addContactMaterial(dominoDominoContactMaterial);

        // --- Ground ---
        const groundGeometry = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0xbbbbbb, roughness: 0.8, metalness: 0.2 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        ground.name = "Ground";
        scene.add(ground);
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, material: groundPhysMaterial });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        groundBody.position.set(0, 0.01, 0); 
        world.addBody(groundBody);

        // --- Grid Helper ---
        const grid = new THREE.GridHelper(GRID_SIZE, GRID_DIVISIONS, 0x666666, 0xaaaaaa);
        grid.position.y = 0.01; 
        grid.material.opacity = 0.6;
        grid.material.transparent = true;
        grid.visible = true;
        scene.add(grid);

        // --- Controls ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 80;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;

        // --- State Variables ---
        let dominoes = []; 
        let dominoData = []; 
        let selectedDominoData = null;
        let hoveredDominoData = null;
        let hoveredSimulationArrow = null;
        let isSimulating = false;
        let isAddingDomino = false; 
        let previewDomino = null; 
        let previewBatchGroup = null; 
        let previewBatchCount = 0;
        let previewCircleGroup = null; 
        let previewCircleCount = 0;

        let lastMousePosition = { x: 0, y: 0 };
        let translationMode = false;
        let rotationMode = false;
        let isMoving = false;
        let isRotating = false;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const contextMenu = document.getElementById('custom-context-menu');
        let isSelectingSimulationDirection = false;
        let simulationTargetData = null;
        let dominoModel = null; 
        let rotationArrowSprite = null;

        // --- Load GLB Model ---
        const loader = new THREE.GLTFLoader();
        loader.load(
            'https://vita2048.github.io/DominoSimulator/OneBlockVerticalTransformed.glb',
            (gltf) => {
                dominoModel = gltf.scene;
                dominoModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        child.userData.isDomino = true; 
                        if (child.material) {
                            child.material = new THREE.MeshStandardMaterial({
                                map: child.material.map || null,
                                normalMap: child.material.normalMap || null,
                                roughness: child.material.roughness || 0.7,
                                metalness: child.material.metalness || 0.1,
                                emissive: new THREE.Color(0x000000),
                                emissiveIntensity: 1,
                                color: child.material.color || 0xffffff
                            });
                            if (child.geometry) child.geometry.computeBoundingBox(); 
                        }
                    }
                });
                const box = new THREE.Box3().setFromObject(dominoModel);
                const size = new THREE.Vector3();
                box.getSize(size);
                const scaleFactor = DOMINO_TALL / size.y;
                dominoModel.scale.set(scaleFactor, scaleFactor, scaleFactor);

                const scaledBox = new THREE.Box3().setFromObject(dominoModel);
                dominoModel.userData.pivotToBottomY = scaledBox.min.y; 
                
                console.log("Scaled model size:", scaledBox.getSize(new THREE.Vector3()));
                console.log("Pivot to bottom Y offset (scaledBox.min.y):", dominoModel.userData.pivotToBottomY);
                
                createPreviewDomino(); 
            },
            undefined, 
            (error) => {
                console.error("Error loading GLB model:", error);
                showNotification("Error: Could not load domino model.", true);
            }
        );

        // --- Domino Creation ---
        function createPreviewDomino() {
            if (!dominoModel) return;
            if (previewDomino) { 
                scene.remove(previewDomino);
                previewDomino.traverse(child => { if (child.isMesh) {if (child.geometry) child.geometry.dispose(); if (child.material) child.material.dispose();} });
            }
            previewDomino = dominoModel.clone();
            previewDomino.traverse((child) => {
                if (child.isMesh) {
                    child.material = child.material.clone(); 
                    child.material.transparent = true;
                    child.material.opacity = 0.6;
                    child.userData.isDomino = true;
                }
            });
            const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;
            previewDomino.position.y = 0 - modelPivotCorrection; 
            previewDomino.rotation.y = 0; 
            previewDomino.visible = false;
            scene.add(previewDomino);
        }

        function createDomino(basePosition, rotationY = 0) {
            if (!dominoModel) {
                showNotification("Error: Domino model not ready.", true);
                return null;
            }

            const dominoMesh = dominoModel.clone();
            dominoMesh.userData.isDomino = true;
            const modelPivotToBottomY_offset = dominoModel.userData.pivotToBottomY || 0;
            dominoMesh.userData.modelPivotToBottomY = modelPivotToBottomY_offset;
            dominoMesh.position.set(basePosition.x, basePosition.y - modelPivotToBottomY_offset, basePosition.z);
            dominoMesh.rotation.y = rotationY;

            dominoMesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material = child.material.clone(); 
                    child.userData.isDominoPart = true;
                }
            });
            scene.add(dominoMesh);

            const shape = new CANNON.Box(new CANNON.Vec3(DOMINO_THICK / 2, DOMINO_TALL / 2, DOMINO_WIDE / 2));
            const bodyCoMPosition = new CANNON.Vec3(basePosition.x, basePosition.y + DOMINO_TALL / 2, basePosition.z);
            const dominoBody = new CANNON.Body({
                mass: 1.0,
                position: bodyCoMPosition,
                shape: shape,
                material: dominoPhysMaterial,
                linearDamping: 0.15,
                angularDamping: 0.4,
                collisionResponse: true
            });

            dominoBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), rotationY);
            dominoBody.allowSleep = true;
            dominoBody.sleepSpeedLimit = 0.5;
            dominoBody.sleepTimeLimit = 1.0;

            dominoMesh.userData.body = dominoBody;
            dominoBody.userData = { mesh: dominoMesh }; 

            const data = {
                mesh: dominoMesh,
                body: dominoBody,
                initialBasePosition: basePosition.clone(), 
                initialQuat: dominoBody.quaternion.clone() 
            };

            dominoData.push(data);
            dominoes.push(dominoMesh); 
            world.addBody(dominoBody);
            return data;
        }
        
        // --- Collision & Placement ---
        function snapToGrid(position) {
            const snappedX = Math.round(position.x / GRID_UNIT_SIZE) * GRID_UNIT_SIZE;
            const snappedZ = Math.round(position.z / GRID_UNIT_SIZE) * GRID_UNIT_SIZE;
            return new THREE.Vector3(snappedX, 0, snappedZ); 
        }

        function checkDominoCollision(position, excludeData = null) {
            const snappedPos = snapToGrid(position); 
            for (const data of dominoData) {
                if (data === excludeData) continue; 
                const dx = data.initialBasePosition.x - snappedPos.x;
                const dz = data.initialBasePosition.z - snappedPos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < MIN_PLACEMENT_DISTANCE) return true; 
            }
            return false;
        }

        function mouseToWorld(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(ground); 
            return intersects.length > 0 ? intersects[0].point : null;
        }

        // --- Highlighting ---
        function setEmissive(dominoData, colorHex = 0x000000, intensity = 1) {
            if (!dominoData || !dominoData.mesh) return;
            dominoData.mesh.traverse((child) => {
                if (child.isMesh && child.material && child.material.emissive) {
                    child.material.emissive.setHex(colorHex);
                    child.material.emissiveIntensity = intensity;
                }
            });
        }

        function findDominoDataFromObject(object) {
            let current = object;
            while (current) {
                if (current.userData && current.userData.body) {
                    return dominoData.find(data => data.mesh === current);
                }
                if (current.parent && current.parent.userData && current.parent.userData.body && current.userData.isDominoPart) {
                     return dominoData.find(data => data.mesh === current.parent);
                }
                current = current.parent;
            }
            return null;
        }

        function updateHoverEffect(event) {
            if (isAddingDomino || isSimulating || translationMode || rotationMode || isSelectingSimulationDirection) {
                if (hoveredDominoData && hoveredDominoData !== selectedDominoData) {
                    setEmissive(hoveredDominoData, 0x000000); 
                }
                hoveredDominoData = null;
                return;
            }

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(dominoes, true); 
            let currentlyHoveredData = null;

            if (intersects.length > 0) {
                currentlyHoveredData = findDominoDataFromObject(intersects[0].object);
            }

            if (hoveredDominoData !== currentlyHoveredData) {
                if (hoveredDominoData && hoveredDominoData !== selectedDominoData) {
                    setEmissive(hoveredDominoData, 0x000000); 
                }
                if (currentlyHoveredData && currentlyHoveredData !== selectedDominoData) {
                    setEmissive(currentlyHoveredData, HOVER_COLOR, 1.5); 
                }
                hoveredDominoData = currentlyHoveredData;
            }
        }

        // --- Selection & Manipulation ---
        function selectDomino(dataToSelect) {
            if (selectedDominoData === dataToSelect && dataToSelect !== null) return; 

            if (selectedDominoData) {
                setEmissive(selectedDominoData, 0x000000); 
            }

            if (isSelectingSimulationDirection && selectedDominoData !== dataToSelect) {
                clearSimulationArrows(); 
            }

            selectedDominoData = dataToSelect;

            if (selectedDominoData) {
                setEmissive(selectedDominoData, SELECT_COLOR, 1.5); 
                if (hoveredDominoData === selectedDominoData) {
                    hoveredDominoData = null; 
                }
            } else {
                if (translationMode || rotationMode) { 
                    translationMode = false;
                    rotationMode = false;
                    isMoving = false;
                    isRotating = false;
                    document.body.style.cursor = 'default';
                    controls.enabled = true;
                    if (rotationArrowSprite) scene.remove(rotationArrowSprite);
                }
                if (hoveredDominoData) {
                     setEmissive(hoveredDominoData, HOVER_COLOR, 1.5);
                }
            }
            hideContextMenu();
        }

        function createRotationArrows() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 8; ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(64, 64, 45, Math.PI * 0.70, Math.PI * 1.80, false); 
            ctx.moveTo(64 + 45 * Math.cos(Math.PI * 1.80) - 5 * Math.sin(Math.PI * 1.80) , 64 + 45 * Math.sin(Math.PI * 1.80) + 5 * Math.cos(Math.PI * 1.80));
            ctx.lineTo(64 + 45 * Math.cos(Math.PI * 1.80) + 10 * Math.sin(Math.PI * 1.80), 64 + 45 * Math.sin(Math.PI * 1.80) - 10 * Math.cos(Math.PI * 1.80));
            ctx.lineTo(64 + 45 * Math.cos(Math.PI * 1.80) - 5 * Math.cos(Math.PI * 1.80) , 64 + 45 * Math.sin(Math.PI * 1.80) - 5 * Math.sin(Math.PI * 1.80));
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(64, 64, 45, Math.PI * -0.30, Math.PI * 0.80, false); 
            ctx.moveTo(64 + 45 * Math.cos(Math.PI * 0.80) - 5 * Math.sin(Math.PI * 0.80) , 64 + 45 * Math.sin(Math.PI * 0.80) + 5 * Math.cos(Math.PI * 0.80));
            ctx.lineTo(64 + 45 * Math.cos(Math.PI * 0.80) + 10 * Math.sin(Math.PI * 0.80), 64 + 45 * Math.sin(Math.PI * 0.80) - 10 * Math.cos(Math.PI * 0.80));
            ctx.lineTo(64 + 45 * Math.cos(Math.PI * 0.80) - 5 * Math.cos(Math.PI * 0.80) , 64 + 45 * Math.sin(Math.PI * 0.80) - 5 * Math.sin(Math.PI * 0.80));
            ctx.stroke();
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, color: 0xffffff, transparent: true, depthTest: false, depthWrite: false, sizeAttenuation: false });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(0.1, 0.1, 0.1); sprite.position.z = 0.1; sprite.visible = false;
            sprite.userData.isRotationArrow = true; sprite.renderOrder = 1; 
            return sprite;
        }

        function animateRotation(data) {
            if (!data || !data.mesh || !data.body) return;
            if (!rotationArrowSprite) rotationArrowSprite = createRotationArrows();
            
            const visualYPosition = data.mesh.position.y + (data.mesh.userData.modelPivotToBottomY || 0) + DOMINO_TALL * 0.75;
            rotationArrowSprite.position.set(data.mesh.position.x, visualYPosition + 0.5, data.mesh.position.z); 
            rotationArrowSprite.visible = true;
            scene.add(rotationArrowSprite);

            const initialBodyQuaternion = data.body.quaternion.clone();
            let totalRotationOffset = 0; 

            function updateRotation(event) {
                if (!rotationMode || !selectedDominoData || selectedDominoData !== data) {
                    document.removeEventListener('mousemove', updateRotation);
                    if (rotationArrowSprite) {
                        scene.remove(rotationArrowSprite); 
                        rotationArrowSprite.visible = false;
                    }
                    return;
                }
                const deltaX = event.clientX - lastMousePosition.x;
                const rotationSpeed = 0.01; 
                totalRotationOffset += deltaX * rotationSpeed;

                const rotationQuaternion = new CANNON.Quaternion();
                rotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), totalRotationOffset);
                
                data.body.quaternion.copy(initialBodyQuaternion).mult(rotationQuaternion, data.body.quaternion);
                data.body.quaternion.normalize(); 

                data.mesh.quaternion.copy(data.body.quaternion); 
                
                const currentBaseY = data.mesh.position.y + (data.mesh.userData.modelPivotToBottomY || 0);
                rotationArrowSprite.position.set(data.mesh.position.x, currentBaseY + DOMINO_TALL * 0.75 + 0.5, data.mesh.position.z);

                if (data.userData && data.userData.collisionHelper) {
                    data.userData.collisionHelper.quaternion.copy(data.body.quaternion);
                }
                lastMousePosition = { x: event.clientX, y: event.clientY };
            }
            document.addEventListener('mousemove', updateRotation, false);
        }

        function createSimulationArrowHelper(origin, directionVec, color, userDataDirection) {
            const length = 1.0; const headLength = 0.3; const headWidth = 0.2;
            const arrowHelper = new THREE.ArrowHelper(directionVec.clone().normalize(), origin, length, color, headLength, headWidth);
            arrowHelper.userData.isSimulationArrow = true;
            arrowHelper.userData.direction = userDataDirection; 
            arrowHelper.userData.originalColor = color;
            arrowHelper.userData.isPulsing = false;
            arrowHelper.userData.pulseTime = 0;
            arrowHelper.line.userData = { isSimulationArrowPart: true, parentArrow: arrowHelper };
            arrowHelper.cone.userData = { isSimulationArrowPart: true, parentArrow: arrowHelper };
            return arrowHelper;
        }

        function clearSimulationArrows() {
            const arrowsToRemove = scene.children.filter(child => child.userData && child.userData.isSimulationArrow);
            arrowsToRemove.forEach(arrow => {
                if (hoveredSimulationArrow === arrow) {
                    if (arrow.cone) arrow.cone.scale.set(1, 1, 1); 
                    hoveredSimulationArrow = null;
                }
                scene.remove(arrow); 
            });
            if (isSelectingSimulationDirection) {
                isSelectingSimulationDirection = false;
                simulationTargetData = null;
                document.body.style.cursor = 'default';
                controls.enabled = true; 
            }
        }

        // --- Context Menu Logic ---
        function showContextMenu(event, targetData) {
            hideContextMenu(); 
            selectDomino(targetData); 
            contextMenu.style.left = `${event.clientX}px`;
            contextMenu.style.top = `${event.clientY}px`;
            contextMenu.style.display = 'block';

            document.getElementById('context-move').onclick = () => {
                translationMode = true; rotationMode = false; isMoving = true; isRotating = false;
                lastMousePosition = { x: event.clientX, y: event.clientY };
                showNotification("Move: Domino follows mouse. Left-click to fix. Esc to cancel.");
                document.body.style.cursor = 'move'; controls.enabled = false; 
                hideContextMenu();
            };

            document.getElementById('context-rotate').onclick = () => {
                rotationMode = true; translationMode = false; isRotating = true; isMoving = false;
                lastMousePosition = { x: event.clientX, y: event.clientY };
                showNotification("Rotate: Drag mouse horizontally. Left-click to fix. Esc to cancel.");
                document.body.style.cursor = 'ew-resize'; controls.enabled = false; 
                animateRotation(targetData); 
                hideContextMenu();
            };

            document.getElementById('context-start-simulation').onclick = () => {
                if (!targetData || !targetData.body) return;
                hideContextMenu();
                clearSimulationArrows(); 

                const bodyPos = targetData.body.position; 
                const bodyQuat = targetData.body.quaternion; 

                const localX = new THREE.Vector3(1, 0, 0); 
                const worldNormalPositiveX = new THREE.Vector3().copy(localX).applyQuaternion(
                    new THREE.Quaternion(bodyQuat.x, bodyQuat.y, bodyQuat.z, bodyQuat.w)
                );
                const worldNormalNegativeX = worldNormalPositiveX.clone().negate();
                const faceOffsetDistance = DOMINO_WIDE / 2 + 0.1; 

                const arrowOriginPositiveX = new THREE.Vector3(bodyPos.x, bodyPos.y, bodyPos.z)
                    .add(worldNormalPositiveX.clone().multiplyScalar(faceOffsetDistance));
                const arrowOriginNegativeX = new THREE.Vector3(bodyPos.x, bodyPos.y, bodyPos.z)
                    .add(worldNormalNegativeX.clone().multiplyScalar(faceOffsetDistance));
                
                const positiveXArrow = createSimulationArrowHelper(arrowOriginPositiveX, worldNormalPositiveX, ARROW_COLOR_DEFAULT, 'positiveX');
                scene.add(positiveXArrow);
                const negativeXArrow = createSimulationArrowHelper(arrowOriginNegativeX, worldNormalNegativeX, ARROW_COLOR_DEFAULT, 'negativeX');
                scene.add(negativeXArrow);

                showNotification("Click a red arrow to apply impulse in that direction.");
                isSelectingSimulationDirection = true;
                simulationTargetData = targetData; 
                controls.enabled = false; 
            };

            document.getElementById('context-delete').onclick = () => {
                deleteSelectedDomino();
                hideContextMenu();
            };
        }

        function deleteSelectedDomino() {
            if (!selectedDominoData) return;
            const dataToDelete = selectedDominoData;
            selectDomino(null); 

            scene.remove(dataToDelete.mesh);
            if (world.bodies.includes(dataToDelete.body)) {
                world.removeBody(dataToDelete.body);
            }

            if (dataToDelete.userData && dataToDelete.userData.collisionHelper) {
                scene.remove(dataToDelete.userData.collisionHelper);
                if (dataToDelete.userData.collisionHelperUpdater) {
                    world.removeEventListener('postStep', dataToDelete.userData.collisionHelperUpdater);
                }
            }

            const meshIndex = dominoes.indexOf(dataToDelete.mesh);
            if (meshIndex > -1) dominoes.splice(meshIndex, 1);
            const dataIndex = dominoData.indexOf(dataToDelete);
            if (dataIndex > -1) dominoData.splice(dataIndex, 1);

            dataToDelete.mesh.traverse((child) => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (child.material.map) child.material.map.dispose();
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
            });
            showNotification('Domino Deleted');
        }

        function hideContextMenu() {
            contextMenu.style.display = 'none';
            document.getElementById('context-move').onclick = null;
            document.getElementById('context-rotate').onclick = null;
            document.getElementById('context-start-simulation').onclick = null;
            document.getElementById('context-delete').onclick = null;
        }

        // --- Simulation Control ---
        function startSimulation(impulseData = null) { 
            if (dominoData.length === 0 && !impulseData) {
                showNotification("Add some dominoes first!");
                return;
            }
            if (isSimulating) return;

            clearSimulationArrows(); 
            isSimulating = true;
            world.allowSleep = false; 

            dominoData.forEach(data => data.body.wakeUp()); 

            if (impulseData && impulseData.targetBody) {
                impulseData.targetBody.wakeUp();
                impulseData.targetBody.applyImpulse(impulseData.worldImpulse, impulseData.worldApplicationPoint);
                showNotification("Simulation started with selected impulse!");
            } else if (selectedDominoData && selectedDominoData.body) {
                selectedDominoData.body.wakeUp();
                const localImpulse = new CANNON.Vec3(IMPULSE_MAGNITUDE, 0, 0); 
                const appPointLocal = new CANNON.Vec3(
                    -DOMINO_WIDE / 2, 
                    DOMINO_TALL * 0.45,  
                    0                   
                ); 
                const worldImpulse = selectedDominoData.body.quaternion.vmult(localImpulse);
                const worldApplicationPoint = selectedDominoData.body.quaternion.vmult(appPointLocal);
                worldApplicationPoint.vadd(selectedDominoData.body.position, worldApplicationPoint); 
                selectedDominoData.body.applyImpulse(worldImpulse, worldApplicationPoint);
                showNotification("Simulation started with default impulse on selected domino!");
            } else if (dominoData.length > 0) {
                showNotification("Select a domino or use context menu to start simulation with impulse.", true);
                isSimulating = false; 
                world.allowSleep = true;
                return;
            }

            translationMode = false; rotationMode = false; isAddingDomino = false;
            isMoving = false; isRotating = false;
            document.body.style.cursor = 'default';
            if (previewDomino) previewDomino.visible = false;
            if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup = null; }
            if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup = null; }
        }

        function resetSimulation() {
            isSimulating = false;
            world.allowSleep = true; 
            clearSimulationArrows();
            hideContextMenu();

            if (translationMode || rotationMode || isAddingDomino) {
                translationMode = false; rotationMode = false; isAddingDomino = false;
                isMoving = false; isRotating = false;
                document.body.style.cursor = 'default';
                if (previewDomino) previewDomino.visible = false;
                if (previewBatchGroup) {
                    scene.remove(previewBatchGroup); previewBatchGroup = null; previewBatchCount = 0;
                }
                if (previewCircleGroup) { 
                    scene.remove(previewCircleGroup); previewCircleGroup = null; previewCircleCount = 0;
                }
                if (rotationArrowSprite) scene.remove(rotationArrowSprite);
            }
            controls.enabled = true; 

            dominoData.forEach(data => {
                const basePos = data.initialBasePosition; 
                const modelPivotOffsetY = data.mesh.userData.modelPivotToBottomY || 0;

                data.body.position.set(basePos.x, basePos.y + DOMINO_TALL / 2, basePos.z); 
                data.body.quaternion.copy(data.initialQuat);
                data.body.velocity.set(0, 0, 0);
                data.body.angularVelocity.set(0, 0, 0);
                data.body.sleep(); 

                data.mesh.position.set(basePos.x, basePos.y - modelPivotOffsetY, basePos.z);
                data.mesh.quaternion.copy(data.initialQuat);
                setEmissive(data, 0x000000); 

                if (data.userData && data.userData.collisionHelper) {
                    data.userData.collisionHelper.position.copy(data.body.position);
                    data.userData.collisionHelper.quaternion.copy(data.body.quaternion);
                }
            });

            selectDomino(null); 
            hoveredDominoData = null; 

            if (hoveredSimulationArrow) {
                setArrowColor(hoveredSimulationArrow, hoveredSimulationArrow.userData.originalColor);
                if (hoveredSimulationArrow.cone) hoveredSimulationArrow.cone.scale.set(1, 1, 1);
                hoveredSimulationArrow.userData.isPulsing = false;
                hoveredSimulationArrow = null;
            }
            showNotification('Simulation Reset');
        }

        function clearCanvas() {
            resetSimulation(); 
            dominoData.forEach(data => {
                scene.remove(data.mesh);
                if (world.bodies.includes(data.body)) world.removeBody(data.body);
                if (data.userData && data.userData.collisionHelper) {
                    scene.remove(data.userData.collisionHelper);
                     if (data.userData.collisionHelperUpdater) { 
                        world.removeEventListener('postStep', data.userData.collisionHelperUpdater);
                    }
                }
                data.mesh.traverse((child) => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                             if (child.material.map) child.material.map.dispose();
                             if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    }
                });
            });
            dominoes = []; 
            dominoData = [];
            showNotification('Canvas Cleared');
        }

        // --- UI Helpers ---
        function showNotification(message, isError = false) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.backgroundColor = isError ? 'rgba(200, 0, 0, 0.8)' : 'rgba(0, 0, 0, 0.7)';
            notification.style.opacity = '1';
            setTimeout(() => { notification.style.opacity = '0'; }, isError ? 3000 : 2000);
        }

        function toggleOrbitControls() {
            controls.enabled = !controls.enabled;
            document.getElementById('toggle-orbit').textContent = controls.enabled ? 'Lock Camera' : 'Unlock Camera';
            if (controls.enabled && (translationMode || rotationMode || isAddingDomino || isSelectingSimulationDirection)) {
                translationMode = false; rotationMode = false; isAddingDomino = false; isSelectingSimulationDirection = false;
                isMoving = false; isRotating = false;
                document.body.style.cursor = 'default';
                if (previewDomino) previewDomino.visible = false;
                if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup = null; previewBatchCount = 0; }
                if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup = null; previewCircleCount = 0; }
                clearSimulationArrows();
                if (rotationArrowSprite) scene.remove(rotationArrowSprite);
            }
        }

        function onStartDragDominoTemplate(event) {
            if (event.button !== 0) return; 
            if (isSimulating || !dominoModel) return;
            
            if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewBatchGroup = null; previewBatchCount = 0; }
            if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewCircleGroup = null; previewCircleCount = 0; }

            isAddingDomino = true;
            if (!previewDomino) createPreviewDomino(); 
            else previewDomino.visible = true; // Ensure it's visible if already created
            
            if (previewDomino) { // Should always exist now
                previewDomino.rotation.y = 0; 
            }
            controls.enabled = false; 
            document.body.style.cursor = 'grabbing';
            hideContextMenu();
        }

        function onAddBatch() { // For Batch Line
            if (isSimulating || !dominoModel) return;
            const numDominosStr = prompt("Enter number of dominos for the batch line (2-20):", "5");
            if (numDominosStr === null) return; 
            const n = parseInt(numDominosStr);
            if (isNaN(n) || n < 2 || n > 20) {
                showNotification("Invalid number. Please enter a value between 2 and 20.", true);
                return;
            }

            if (previewDomino) { previewDomino.visible = false; }
             previewDomino = null; 
            if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewCircleGroup = null; previewCircleCount = 0; }
            
            createPreviewBatch(n); 
            isAddingDomino = true; 
            controls.enabled = false;
            document.body.style.cursor = 'grabbing';
            hideContextMenu();
        }
        
        function onAddBatchCircle() { 
            if (isSimulating || !dominoModel) return;
            const numDominosStr = prompt("Enter number of pieces for the circle (20-40):", "30");
            if (numDominosStr === null) return; 
            const n = parseInt(numDominosStr);
            if (isNaN(n) || n < 20 || n > 40) {
                showNotification("Invalid number. Please enter a value between 20 and 40.", true);
                return;
            }

            if (previewDomino) { previewDomino.visible = false; }
            previewDomino = null;
            if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}}); previewBatchGroup = null; previewBatchCount = 0; }

            createPreviewCircle(n);
            isAddingDomino = true;
            controls.enabled = false;
            document.body.style.cursor = 'grabbing';
            hideContextMenu();
        }

        function createPreviewBatch(n) { // For Line Batch
            if (previewBatchGroup) { 
                scene.remove(previewBatchGroup);
                previewBatchGroup.traverse(child => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) child.material.forEach(m=>m.dispose());
                            else child.material.dispose();
                        }
                    }
                });
            }
            previewBatchGroup = new THREE.Group();
            const spacing = 1.0; 
            const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;

            for (let i = 0; i < n; i++) {
                const singlePreview = dominoModel.clone();
                singlePreview.traverse((child) => {
                    if (child.isMesh) {
                        child.material = child.material.clone();
                        child.material.transparent = true;
                        child.material.opacity = 0.6;
                        child.userData.isDomino = true;
                    }
                });
                const zPos = (i - (n - 1) / 2) * spacing; 
                singlePreview.position.set(0, 0 - modelPivotCorrection, zPos); 
                singlePreview.rotation.y = Math.PI / 2; 
                previewBatchGroup.add(singlePreview);
            }
            scene.add(previewBatchGroup);
            previewBatchCount = n;
        }

function createPreviewCircle(numberOfPieces) { 
    if (previewCircleGroup) {
        scene.remove(previewCircleGroup);
        previewCircleGroup.traverse(child => {
            if (child.isMesh) {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                    else child.material.dispose();
                }
            }
        });
    }
    previewCircleGroup = new THREE.Group();
    const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;
    const N = numberOfPieces;
    
    // Calculate radius based on desired circle size
    // Using the domino width for better spacing around the circle
    const radius = (DOMINO_WIDE * N) / (2 * Math.PI);
    const anglePerSegment = (2 * Math.PI) / N;
    
    for (let i = 0; i < N; i++) {
        const angle = i * anglePerSegment; // Angle of the domino's position on the circle
        const posX = radius * Math.cos(angle); 
        const posZ = radius * Math.sin(angle);
        const singlePreview = dominoModel.clone();
        singlePreview.traverse((child) => {
            if (child.isMesh) {
                child.material = child.material.clone();
                child.material.transparent = true;
                child.material.opacity = 0.6;
                child.userData.isDomino = true;
            }
        });
        
        // Position domino's visual bottom at (posX, 0, posZ) relative to group center
        singlePreview.position.set(posX, 0 - modelPivotCorrection, posZ);
        
        // Rotate domino so its wide face is perpendicular to the radius
        // This makes them look like hour markers on a clock
        //singlePreview.rotation.y = angle; // Point the domino's face toward the center
        singlePreview.rotation.y = (Math.PI/2) - angle;
        previewCircleGroup.add(singlePreview);
    }
    scene.add(previewCircleGroup);
    previewCircleCount = numberOfPieces;
}

        // --- Event Listeners Setup ---
        function initEventListeners() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                hideContextMenu();
            }, false);

            const canvasContainer = document.getElementById('canvas-container');
            canvasContainer.addEventListener('mousedown', onMouseDown, false);
            canvasContainer.addEventListener('mousemove', onMouseMove, false);
            canvasContainer.addEventListener('mouseup', onMouseUp, false);
            canvasContainer.addEventListener('contextmenu', onContextMenu, false); 

            window.addEventListener('keydown', onKeyDown, false);
            window.addEventListener('mousedown', (event) => {
                if (contextMenu.style.display === 'block' && !contextMenu.contains(event.target)) {
                    hideContextMenu();
                }
            }, true); 

            document.getElementById('domino-template').addEventListener('mousedown', onStartDragDominoTemplate);
            document.getElementById('add-batch-button').addEventListener('click', onAddBatch);
            document.getElementById('add-batch-circle-button').addEventListener('click', onAddBatchCircle); 
            document.getElementById('reset-button').addEventListener('click', resetSimulation);
            document.getElementById('clear-button').addEventListener('click', clearCanvas);
            document.getElementById('toggle-grid').addEventListener('change', (event) => { grid.visible = event.target.checked; });
            document.getElementById('toggle-orbit').addEventListener('click', toggleOrbitControls);
            document.getElementById('reset-camera').addEventListener('click', () => {
                controls.reset(); 
                camera.position.set(0, 20, 30); 
                camera.lookAt(0, 0, 0);
                controls.update(); 
                if (!controls.enabled) {
                    controls.enabled = true;
                    document.getElementById('toggle-orbit').textContent = 'Lock Camera';
                }
            });
            document.getElementById('help-button').addEventListener('click', () => { document.getElementById('modal-overlay').style.display = 'flex'; });
            document.getElementById('close-modal').addEventListener('click', () => { document.getElementById('modal-overlay').style.display = 'none'; });
            document.getElementById('modal-overlay').addEventListener('click', (event) => {
                if (event.target === document.getElementById('modal-overlay')) {
                    document.getElementById('modal-overlay').style.display = 'none';
                }
            });
        }

        function setArrowColor(arrow, color) {
            if (arrow && arrow.line && arrow.cone) {
                arrow.line.material.color.setHex(color);
                arrow.cone.material.color.setHex(color);
            }
        }

        function onMouseDown(event) {
            if (event.button !== 0) return; 
            
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            if (isSelectingSimulationDirection && simulationTargetData) {
                const simulationArrows = scene.children.filter(c => c.userData && c.userData.isSimulationArrow);
                const intersectsArrows = raycaster.intersectObjects(simulationArrows, true); 

                if (intersectsArrows.length > 0) {
                    let clickedArrowPart = intersectsArrows[0].object;
                    let actualArrow = clickedArrowPart.userData.parentArrow || (clickedArrowPart.userData.isSimulationArrow ? clickedArrowPart : null);
                    
                    if (actualArrow && actualArrow.userData.direction) {
                        const direction = actualArrow.userData.direction; 
                        let localImpulse = new CANNON.Vec3();
                        if (direction === 'positiveX') localImpulse.set(IMPULSE_MAGNITUDE, 0, 0); 
                        else localImpulse.set(-IMPULSE_MAGNITUDE, 0, 0); 
                        
                        const appPointLocal = new CANNON.Vec3(
                            direction === 'positiveX' ? -DOMINO_WIDE / 2 : DOMINO_WIDE / 2, 
                            DOMINO_TALL * 0.4, 
                            0
                        );
                        
                        const worldImpulse = simulationTargetData.body.quaternion.vmult(localImpulse);
                        const worldApplicationPoint = simulationTargetData.body.quaternion.vmult(appPointLocal);
                        worldApplicationPoint.vadd(simulationTargetData.body.position, worldApplicationPoint);
                        
                        startSimulation({
                            targetBody: simulationTargetData.body,
                            worldImpulse: worldImpulse,
                            worldApplicationPoint: worldApplicationPoint
                        });
                        return; 
                    }
                } else {
                    clearSimulationArrows();
                    showNotification("Simulation direction selection canceled.");
                }
                return; 
            }

            if (isMoving && translationMode && selectedDominoData) { 
                isMoving = false; translationMode = false;
                document.body.style.cursor = 'default'; controls.enabled = true;
                const modelPivotOffsetY = selectedDominoData.mesh.userData.modelPivotToBottomY || 0;
                const currentBasePosition = snapToGrid(selectedDominoData.mesh.position); 
                currentBasePosition.y = 0; 

                const collision = checkDominoCollision(currentBasePosition, selectedDominoData);
                setEmissive(selectedDominoData, collision ? COLLISION_COLOR : SELECT_COLOR, 1.5);
                if (collision) {
                    showNotification("Warning: Domino placement overlaps! Reverting.", true);
                    const oldBase = selectedDominoData.initialBasePosition;
                    selectedDominoData.mesh.position.set(oldBase.x, oldBase.y - modelPivotOffsetY, oldBase.z);
                    selectedDominoData.body.position.set(oldBase.x, oldBase.y + DOMINO_TALL / 2, oldBase.z);
                } else {
                    showNotification("Position fixed.");
                    selectedDominoData.initialBasePosition.copy(currentBasePosition); 
                    selectedDominoData.body.position.set(currentBasePosition.x, currentBasePosition.y + DOMINO_TALL / 2, currentBasePosition.z);
                }
                if (selectedDominoData.userData && selectedDominoData.userData.collisionHelper) {
                    selectedDominoData.userData.collisionHelper.position.copy(selectedDominoData.body.position);
                }
                return;
            }
            if (isRotating && rotationMode && selectedDominoData) { 
                isRotating = false; rotationMode = false;
                document.body.style.cursor = 'default'; controls.enabled = true;
                selectedDominoData.initialQuat.copy(selectedDominoData.body.quaternion); 
                setEmissive(selectedDominoData, SELECT_COLOR, 1.5);
                showNotification("Rotation fixed.");
                if (rotationArrowSprite) {
                    scene.remove(rotationArrowSprite);
                    rotationArrowSprite.visible = false;
                }
                return;
            }

            const intersectsDominoes = raycaster.intersectObjects(dominoes, true);
            if (intersectsDominoes.length > 0 && !isSimulating) {
                const clickedDominoData = findDominoDataFromObject(intersectsDominoes[0].object);
                if (clickedDominoData) {
                    selectDomino(clickedDominoData);
                } else {
                     if (!isSelectingSimulationDirection) selectDomino(null); 
                }
            } else {
                 if (!isSelectingSimulationDirection) selectDomino(null); 
            }
        }

        function onMouseMove(event) {
            if (!dominoModel) return; 

            const currentMouse = new THREE.Vector2(
                ((event.clientX - renderer.domElement.getBoundingClientRect().left) / renderer.domElement.width) * 2 - 1,
                -((event.clientY - renderer.domElement.getBoundingClientRect().top) / renderer.domElement.height) * 2 + 1
            );
            raycaster.setFromCamera(currentMouse, camera);
            const worldPos = mouseToWorld(event); 
            const modelPivotCorrection = dominoModel.userData.pivotToBottomY || 0;

            if (isAddingDomino && worldPos) {
                const snappedBasePos = snapToGrid(worldPos); 
                
                if (previewDomino) { 
                    previewDomino.position.set(snappedBasePos.x, snappedBasePos.y - modelPivotCorrection, snappedBasePos.z);
                    const collision = checkDominoCollision(snappedBasePos);
                    previewDomino.traverse((child) => {
                        if (child.isMesh && child.material) {
                            child.material.color.setHex(collision ? 0xff8888 : 0xffffff); 
                            child.material.opacity = collision ? 0.4 : 0.6;
                        }
                    });
                } else if (previewBatchGroup) { 
                    previewBatchGroup.position.copy(snappedBasePos); 
                    let collisionInBatch = false;
                    const tempWorldPosCheck = new THREE.Vector3(); 
                    for (let i = 0; i < previewBatchCount; i++) {
                        previewBatchGroup.children[i].getWorldPosition(tempWorldPosCheck);
                        const dominoBasePosInWorld = snapToGrid(tempWorldPosCheck); 
                        if (checkDominoCollision(dominoBasePosInWorld)) {
                            collisionInBatch = true; break;
                        }
                    }
                    previewBatchGroup.traverse((child) => { 
                        if (child.isMesh && child.material && child.userData.isDomino) { 
                            child.material.color.setHex(collisionInBatch ? 0xff8888 : 0xffffff);
                            child.material.opacity = collisionInBatch ? 0.4 : 0.6;
                        }
                    });
                } else if (previewCircleGroup) { 
                    previewCircleGroup.position.copy(snappedBasePos); 
                    let collisionInCircle = false;
                    const tempWorldPosCheck = new THREE.Vector3();
                    for (const childPreview of previewCircleGroup.children) {
                        childPreview.getWorldPosition(tempWorldPosCheck);
                        const childSnappedBasePos = snapToGrid(tempWorldPosCheck);
                        if (checkDominoCollision(childSnappedBasePos)) {
                            collisionInCircle = true; break;
                        }
                    }
                    previewCircleGroup.traverse((child) => {
                        if (child.isMesh && child.material && child.userData.isDomino) {
                            child.material.color.setHex(collisionInCircle ? 0xff8888 : 0xffffff);
                            child.material.opacity = collisionInCircle ? 0.4 : 0.6;
                        }
                    });
                }
            } 
            else if (selectedDominoData && isMoving && translationMode && worldPos) {
                const snappedBasePos = snapToGrid(worldPos); 
                selectedDominoData.mesh.position.set(snappedBasePos.x, snappedBasePos.y - modelPivotCorrection, snappedBasePos.z);
                selectedDominoData.body.position.set(snappedBasePos.x, snappedBasePos.y + DOMINO_TALL / 2, snappedBasePos.z);
                selectedDominoData.body.wakeUp(); 

                const collision = checkDominoCollision(snappedBasePos, selectedDominoData);
                setEmissive(selectedDominoData, collision ? COLLISION_COLOR : SELECT_COLOR, 1.5);

                if (selectedDominoData.userData && selectedDominoData.userData.collisionHelper) {
                    selectedDominoData.userData.collisionHelper.position.copy(selectedDominoData.body.position);
                }
            } 
            else if (isSelectingSimulationDirection) {
                const simulationArrows = scene.children.filter(c => c.userData && c.userData.isSimulationArrow);
                let intersectedArrowThisFrame = null;
                if (simulationArrows.length > 0) {
                    const intersects = raycaster.intersectObjects(simulationArrows, true);
                    if (intersects.length > 0) {
                        let obj = intersects[0].object;
                        intersectedArrowThisFrame = obj.userData.parentArrow || (obj.userData.isSimulationArrow ? obj : null);
                    }
                }

                if (hoveredSimulationArrow && hoveredSimulationArrow !== intersectedArrowThisFrame) {
                    setArrowColor(hoveredSimulationArrow, hoveredSimulationArrow.userData.originalColor);
                    hoveredSimulationArrow.userData.isPulsing = false;
                    if (hoveredSimulationArrow.cone) hoveredSimulationArrow.cone.scale.set(1, 1, 1); 
                }
                if (intersectedArrowThisFrame) {
                    setArrowColor(intersectedArrowThisFrame, ARROW_COLOR_HOVER);
                    intersectedArrowThisFrame.userData.isPulsing = true; 
                    document.body.style.cursor = 'pointer';
                } else {
                    document.body.style.cursor = 'default';
                }
                hoveredSimulationArrow = intersectedArrowThisFrame;
            } 
            else if (!isSimulating) {
                updateHoverEffect(event);
            }
            lastMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseUp(event) {
            if (event.button !== 0 || !dominoModel) return; 

            if (isAddingDomino) {
                const worldPos = mouseToWorld(event);
                if (worldPos) {
                    const snappedFinalPos = snapToGrid(worldPos); // Snapped position for the center of the action

                    if (previewDomino) { 
                        const collision = checkDominoCollision(snappedFinalPos);
                        if (!collision) {
                            createDomino(snappedFinalPos, previewDomino.rotation.y); 
                        } else {
                            showNotification("Placement overlaps existing domino!", true);
                        }
                        previewDomino.visible = false;
                    } else if (previewBatchGroup) { 
                        let collisionInBatch = false;
                        const finalPositionsAndRotations = [];
                        const tempWorldPosPlace = new THREE.Vector3();

                        for (let i = 0; i < previewBatchCount; i++) {
                            const childPreview = previewBatchGroup.children[i];
                            childPreview.getWorldPosition(tempWorldPosPlace);
                            const childSnappedBasePos = snapToGrid(tempWorldPosPlace); 

                            if (checkDominoCollision(childSnappedBasePos)) {
                                collisionInBatch = true; break;
                            }
                            finalPositionsAndRotations.push({
                                position: childSnappedBasePos,
                                rotationY: childPreview.rotation.y 
                            });
                        }

                        if (!collisionInBatch) {
                            finalPositionsAndRotations.forEach(pr => createDomino(pr.position, pr.rotationY));
                        } else {
                            showNotification("Batch line placement overlaps existing dominoes!", true);
                        }
                        scene.remove(previewBatchGroup); 
                        previewBatchGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}});
                        previewBatchGroup = null;
                        previewBatchCount = 0;
                    } else if (previewCircleGroup) { 
                        const circleCenterPos = snappedFinalPos; // Snapped mouse click for the circle's center
                        let collisionInCircle = false;
                        const finalDominosToCreate = [];

                        for (const childPreview of previewCircleGroup.children) {
                            // childPreview.position is the calculated local offset (radius*cos, y_offset, radius*sin)
                            // childPreview.rotation.y is the calculated orientation (angle - Math.PI / 2)

                            // Calculate the target world base position for this domino's center
                            const targetDominoBasePosition = new THREE.Vector3(
                                circleCenterPos.x + childPreview.position.x,
                                0, // Base Y is on the ground plane for createDomino
                                circleCenterPos.z + childPreview.position.z
                            );
                            
                            // checkDominoCollision will internally snap its input for grid-based checking
                            if (checkDominoCollision(targetDominoBasePosition)) { 
                                collisionInCircle = true;
                                break;
                            }
                            finalDominosToCreate.push({
                                position: targetDominoBasePosition, // Use the precise, un-snapped position for creation
                                rotationY: childPreview.rotation.y
                            });
                        }

                        if (!collisionInCircle) {
                            finalDominosToCreate.forEach(d => createDomino(d.position, d.rotationY));
                        } else {
                            showNotification("Batch circle placement overlaps existing dominoes!", true);
                        }
                        scene.remove(previewCircleGroup);
                        previewCircleGroup.traverse(c => {if(c.isMesh){if(c.material)c.material.dispose(); if(c.geometry)c.geometry.dispose();}});
                        previewCircleGroup = null;
                        previewCircleCount = 0;
                    }
                }
                isAddingDomino = false;
                document.body.style.cursor = 'default';
                controls.enabled = true;
            }
        }

        function onContextMenu(event) {
            event.preventDefault(); 
            if (isSimulating || isAddingDomino || isMoving || isRotating) return; 

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(dominoes, true);
            if (intersects.length > 0) {
                const targetData = findDominoDataFromObject(intersects[0].object);
                if (targetData) {
                    showContextMenu(event, targetData); 
                }
            } else {
                hideContextMenu(); 
                selectDomino(null); 
            }
        }

        function onKeyDown(event) {
            const key = event.key.toLowerCase();

            if (key === 'escape') {
                hideContextMenu();
                let modeCancelled = false;
                if (isAddingDomino) {
                    if (previewDomino) previewDomino.visible = false;
                    if (previewBatchGroup) { scene.remove(previewBatchGroup); previewBatchGroup = null; previewBatchCount = 0; }
                    if (previewCircleGroup) { scene.remove(previewCircleGroup); previewCircleGroup = null; previewCircleCount = 0; }
                    isAddingDomino = false;
                    modeCancelled = true;
                } else if (translationMode || rotationMode) { 
                    if (selectedDominoData) {
                        const basePos = selectedDominoData.initialBasePosition;
                        const modelPivotOffsetY = selectedDominoData.mesh.userData.modelPivotToBottomY || 0;
                        selectedDominoData.mesh.position.set(basePos.x, basePos.y - modelPivotOffsetY, basePos.z);
                        selectedDominoData.mesh.quaternion.copy(selectedDominoData.initialQuat);
                        selectedDominoData.body.position.set(basePos.x, basePos.y + DOMINO_TALL / 2, basePos.z);
                        selectedDominoData.body.quaternion.copy(selectedDominoData.initialQuat);
                        setEmissive(selectedDominoData, SELECT_COLOR, 1.5); 
                        if (rotationArrowSprite) { scene.remove(rotationArrowSprite); rotationArrowSprite.visible = false; }
                        if (selectedDominoData.userData && selectedDominoData.userData.collisionHelper) {
                            selectedDominoData.userData.collisionHelper.position.copy(selectedDominoData.body.position);
                            selectedDominoData.userData.collisionHelper.quaternion.copy(selectedDominoData.body.quaternion);
                        }
                    }
                    translationMode = false; rotationMode = false;
                    isMoving = false; isRotating = false;
                    modeCancelled = true;
                } else if (isSelectingSimulationDirection) {
                    clearSimulationArrows();
                    showNotification("Simulation direction selection canceled.");
                    return; 
                }

                if (modeCancelled) {
                    document.body.style.cursor = 'default';
                    controls.enabled = true;
                    showNotification("Action canceled.");
                } else if (!isSimulating) { 
                    selectDomino(null);
                }
                return; 
            }

            if (selectedDominoData && !translationMode && !rotationMode && !isSelectingSimulationDirection && !isSimulating) {
                switch (key) {
                    case 'delete': case 'backspace': deleteSelectedDomino(); break;
                    case 't': 
                        document.getElementById('context-move').onclick = () => { 
                            translationMode = true; rotationMode = false; isMoving = true; isRotating = false;
                            lastMousePosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 }; 
                            showNotification("Move: Domino follows mouse. Left-click to fix. Esc to cancel.");
                            document.body.style.cursor = 'move'; controls.enabled = false; hideContextMenu();
                        };
                        document.getElementById('context-move').onclick(); 
                        document.getElementById('context-move').onclick = null; 
                        break;
                    case 'r': 
                         document.getElementById('context-rotate').onclick = () => { 
                            rotationMode = true; translationMode = false; isRotating = true; isMoving = false;
                            lastMousePosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
                            showNotification("Rotate: Drag mouse horizontally. Left-click to fix. Esc to cancel.");
                            document.body.style.cursor = 'ew-resize'; controls.enabled = false;
                            animateRotation(selectedDominoData); hideContextMenu();
                        };
                        document.getElementById('context-rotate').onclick();
                        document.getElementById('context-rotate').onclick = null;
                        break;
                }
            }

            switch (key) {
                case 'g': 
                    if (!translationMode && !rotationMode && !isAddingDomino && !isSimulating) { 
                        const cb = document.getElementById('toggle-grid');
                        cb.checked = !cb.checked;
                        grid.visible = cb.checked;
                    }
                    break;
                case ' ': 
                    if (!isSimulating && !translationMode && !rotationMode && !isAddingDomino && !isSelectingSimulationDirection) {
                        if (dominoData.length > 0) {
                           startSimulation(); 
                        } else {
                            showNotification("Add dominoes before starting simulation.", true);
                        }
                        event.preventDefault(); 
                    }
                    break;
            }
        }

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        const pulseSpeed = 5; 
        const pulseMagnitude = 0.1;
        const fixedTimeStep = 1 / 60; 
        const maxSubSteps = 10;      

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.1); 

            if (isSimulating) {
                world.step(fixedTimeStep, deltaTime, maxSubSteps);
            }

            if (hoveredSimulationArrow && hoveredSimulationArrow.userData.isPulsing) {
                hoveredSimulationArrow.userData.pulseTime += deltaTime * pulseSpeed;
                const scale = 1 + Math.sin(hoveredSimulationArrow.userData.pulseTime) * pulseMagnitude;
                if (hoveredSimulationArrow.cone) hoveredSimulationArrow.cone.scale.set(scale, scale, scale);
            }
            
            dominoData.forEach((data) => {
                const body = data.body;
                const mesh = data.mesh;
                const modelPivotToBottomY_offset = mesh.userData.modelPivotToBottomY || 0;
                mesh.quaternion.copy(body.quaternion);
                const localOffsetToPivot = new THREE.Vector3(0, (-DOMINO_TALL / 2) - modelPivotToBottomY_offset, 0);
                const worldOffsetToPivot = localOffsetToPivot.clone().applyQuaternion(mesh.quaternion); 
                mesh.position.copy(body.position).add(worldOffsetToPivot);
            });

            controls.update(); 
            renderer.render(scene, camera);
        }

        // --- Initialization ---
        console.log("Initializing Domino Simulator...");
        initEventListeners();
        animate(); 
        console.log("Initialization Complete.");
    </script>
</html>
